##中子星NeutronStar233制作

import numpy as np
from manim import *
from math import *

config.background_color = ManimColor([250,250,230])
config.frame_width = 16
config.frame_height = 9
config.pixel_width = 1920
config.pixel_height = 1080

BACKGROUNDCOLOR = ManimColor([250,250,230])

class bkground(Scene):
    def construct(self):
        self.add(Mobject())

class s1(Scene):
    def construct(self):
        self.wait(1)
        equation1 = Tex(r"$$x^2+y^2=25$$",color=BLACK).to_corner(UL)
        equation2 = Tex(r"$$(3x+2y)_{max}=$$",color=BLACK).next_to(equation1,DOWN,aligned_edge=LEFT)
        tripleque = Tex(r"$$???$$",color=RED).next_to(equation2,RIGHT)
        self.play(Write(equation1))
        self.play(Write(equation2))
        self.play(Write(tripleque))
        self.wait(1)
        self.play(Transform(tripleque,Tex(r"$$k$$",color=BLACK).next_to(equation2,RIGHT)))
        equation3 = Tex(r"$$\Rightarrow y=\frac{k-3x}{2}=-\frac{3}{2}x+\frac{1}{2}k$$",color=BLACK).next_to(equation2,DOWN,aligned_edge=LEFT)
        self.play(Write(equation3))
        self.wait(1)
        axes = Axes(axis_config={"color":BLACK})
        circ = Circle(radius=2*axes.get_x_unit_size(),color=BLACK)
        line = Line(axes.coords_to_point(-20,30),axes.coords_to_point(20,-30),color=BLACK)
        self.play(Create(axes),Create(circ),Create(line))
        self.wait(1)
        halfk = Line(axes.coords_to_point(0,0),axes.coords_to_point(0,0.1),color=RED)
        tracker = ValueTracker(0)
        line.add_updater(lambda m:m.move_to(axes.coords_to_point(0,tracker.get_value())))
        halfk.add_updater(lambda m: m.put_start_and_end_on(axes.coords_to_point(0,0),axes.coords_to_point(0,tracker.get_value())))
        self.play(tracker.animate.set_value(sqrt(13)),halfk.animate.get_center())
        Thalfk = Tex(r"$$\frac{1}{2}k$$",color=RED).next_to(halfk,LEFT,aligned_edge=DOWN)
        pline = Line(axes.c2p(0,0),axes.c2p(sqrt(225/13)*2/5,(2/3)*sqrt(225/13)*2/5),color=BLUE)
        self.play(Write(Thalfk),Create(pline))
        angle1 = Angle(pline,halfk,color=BLUE,radius=0.5,quadrant=(1,1),stroke_width=10)
        angle2 = Angle(line, Line(LEFT,RIGHT), color=RED, radius=0.5, quadrant=(-1, -1),stroke_width=10)
        pangle = RightAngle(line,pline,color=BLACK,length=0.3,stroke_width=10,quadrant=(-1, -1))
        self.play(Write(angle1),Write(angle2),Write(pangle))
        self.wait(1)

class s2(Scene):
    def construct(self):
        self.wait(1)
        triangle = Polygon([0,0,0],[2,0,0],[0,1,0],color=BLACK).center()
        t1 = Tex(r"$$dx$$",color=BLACK).next_to(triangle,DOWN)
        t2 = Tex(r"$$dy$$",color=BLACK).next_to(triangle,LEFT)
        t3 = Tex(r"$$ds$$",color=BLACK).next_to(triangle,UR,buff=-0.5)
        group = VGroup(triangle,t1,t2,t3)
        self.play(Create(group))
        equation1 = Tex(r"$${ds}^2={dx}^2+{dy}^2$$",color=BLACK)
        self.play(Write(equation1),group.animate.next_to(equation1,UP,buff=0.5))
        self.wait(1)
        self.play(FadeOut(t1,t2,t3))
        self.remove(group)
        self.add(triangle)
        anothertriangle = Polygon([0,0,0],[2,0,0],[0,1,0],color=BLACK)
        sq1 = Square(side_length=1,color=BLACK,fill_opacity=0).next_to(anothertriangle,LEFT,buff=0)
        sq2 = Square(side_length=2, color=BLACK, fill_opacity=0).next_to(anothertriangle, DOWN,buff=0)
        sq3 = Polygon([2,0,0],[0,1,0],[1,3,0],[3,2,0],color=BLACK)
        l1 = Line([0,0,0],[1,3,0],color=BLACK)
        l2 = Line([0,1,0],[2,-2,0],color=BLACK)
        l3 = Line([0,0,0],[3,2,0],color=BLACK)
        l4 = Line([-1,1,0],[2,0,0],color=BLACK)
        op = 0.3
        pP1 = Polygon([-1,1,0],[2,0,0],[0,1,0],color=RED,fill_opacity=op,stroke_width=0)
        pP2 = Polygon([1, 3, 0], [0, 0, 0], [0, 1, 0], color=RED, fill_opacity=op,stroke_width=0)
        pP3 = Polygon([2, -2, 0], [2, 0, 0], [0, 1, 0], color=BLUE, fill_opacity=op,stroke_width=0)
        pP4 = Polygon([0, 0, 0], [2, 0, 0], [3, 2, 0], color=BLUE, fill_opacity=op,stroke_width=0)
        g2 = VGroup(anothertriangle,sq1,sq2,sq3,l1,l2,l3,l4,pP1,pP2,pP3,pP4).to_edge(LEFT)
        then = Tex(r"$$\Rightarrow$$",color=BLACK).next_to(g2)
        equation1c = equation1.copy().next_to(then,RIGHT)
        g3 = VGroup(anothertriangle,sq1,sq2,sq3,l1,l2,l3,l4,pP1,pP2,pP3,pP4,equation1c,then).center()
        self.play(Transform(triangle,anothertriangle),Write(sq1),Write(sq2),Write(sq3),Write(l1),
                  Write(l2),Write(l3),Write(l4),Write(pP1),Write(pP2),Write(pP3),Write(pP4),Write(then),Transform(equation1,equation1c))
        self.wait(1)

def mytitle(a,b):
    return VGroup(Text(a,color=BLACK),Text(b,color=BLACK)).arrange(DOWN).center()
def myNBfunction(func,m):
    return lambda x,y:func(m.p2c([x,y,0])[0],m.p2c([x,y,0])[1])

class s3(Scene):
    def construct(self):
        self.wait(1)
        numberplane = NumberPlane(axis_config={"color":BLACK})
        e1 = Vector(UP,color=BLACK)
        e2 = Vector(RIGHT,color=BLACK)
        self.play(Create(numberplane),Create(e1),Create(e2))
        t1 = mytitle("向量空间","Vector Space")
        self.play(Write(t1))
        self.wait(1)

        v1 = Vector(2*UP+3*RIGHT,color=RED)
        v2 = Vector(-3*UP+-1*RIGHT,color=PURPLE)
        self.play(FadeOut(t1),GrowArrow(v1),GrowArrow(v2))
        self.wait(1)

        t1 = Tex(r"$$\mathbf{a}=\begin{bmatrix} {a}_1\\ {a}_2\\ \vdots \\{a}_n\end{bmatrix}$$",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)

        t2 = Tex(r"$$ \mathbf{a}+\mathbf{b}= \begin{bmatrix} {a}_1\\ {a}_2\\ \vdots \\{a}_n\end{bmatrix}+ \begin{bmatrix} {b}_1\\ {b}_2\\ \vdots \\{b}_n\end{bmatrix}=\begin{bmatrix} {a}_1+{b}_1\\ {a}_2+{b}_2\\ \vdots \\{a}_n+{b}_n\end{bmatrix}$$",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        v3 = Vector(v1.get_vector()+v2.get_vector(),color=BLUE)
        self.play(Write(t2),v2.animate.shift(v1.get_vector()),GrowArrow(v3))
        self.wait(1)

        self.play(FadeOut(v2,v3),FadeOut(t1),Transform(t2,Tex(r"$$ \begin{bmatrix} {a}_1\\ {a}_2\\ \vdots \\{a}_n\end{bmatrix}+ \begin{bmatrix} {b}_1\\ {b}_2\\ \vdots \\{b}_n\end{bmatrix}=\begin{bmatrix} {a}_1+{b}_1\\ {a}_2+{b}_2\\ \vdots \\{a}_n+{b}_n\end{bmatrix}$$",color=BLACK).to_corner(UL)))
        v4 = v1.copy()
        t3 = Tex(r"$$x\mathbf{a}=x\begin{bmatrix} {a}_1\\ {a}_2\\ \vdots \\{a}_n\end{bmatrix}=\begin{bmatrix} x{a}_1\\ x{a}_2\\ \vdots \\x{a}_n\end{bmatrix}$$",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Transform(v4,Vector(1.5*v1.get_vector(),color=BLUE)),Write(t3))
        self.wait(1)

        self.play(Transform(t3,Tex(r"$$x\begin{bmatrix} {a}_1\\ {a}_2\\ \vdots \\{a}_n\end{bmatrix}=\begin{bmatrix} x{a}_1\\ x{a}_2\\ \vdots \\x{a}_n\end{bmatrix}$$",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)))
        self.wait(1)

        self.play(Uncreate(numberplane), Uncreate(e1), Uncreate(e2),FadeOut(v1,v4))
        self.wait(1)

        t4 = Tex(r"$$\mathbf{0}+\mathbf{v}=\mathbf{v}$$",color=BLACK).to_corner(UR)
        self.play(Write(t4))
        self.wait(1)
        self.play(Transform(t4,Tex(r"$$\mathbf{0}=\mathbf{v}-\mathbf{v}$$",color=BLACK).to_corner(UR)))
        self.wait(1)
        self.play(Transform(t4,Tex(r"$$\mathbf{0}=\begin{bmatrix} {v}_1-{v}_1\\ {v}_2-{v}_2\\ \vdots \\{v}_n-{v}_n\end{bmatrix}$$",color=BLACK).to_corner(UR)))
        self.wait(1)
        self.play(Transform(t4,Tex(r"$$\mathbf{0}=\begin{bmatrix} 0\\ 0\\ \vdots \\0\end{bmatrix}$$",color=BLACK).to_corner(UR)))
        self.wait(1)

        T1 = Tex(r"$$\mathbb{R}^n=\left\{ \begin{bmatrix} {v}_1\\ {v}_2\\ \vdots \\{v}_n\end{bmatrix} \mid {v}_1,{v}_2,\dots,{v}_n \in \mathbb{R} \right\}$$",color=BLACK).next_to(t4,DOWN,aligned_edge=RIGHT)
        notation = Text("注明：实际上，向量空间的定义更加广泛\n这只是众多种向量空间中在实数上的向量空间\n不难证明这样定义的实数上的向量空间满足向量空间的标准定义\n但那不是本视频要讨论的主要内容.",font_size=30,color=GRAY).to_corner(DR)
        self.play(Write(T1),Write(notation))
        self.wait(1)

class test(Scene):
    def construct(self):
        axes = Axes(axis_config={"color":BLACK})
        graph = axes.plot(Create(Arc()).rate_func,color = RED)
        self.add(axes,graph)


def HighLight(scene:Scene,target_:Mobject,color_:ManimColor = PURE_RED,buff_:float = 0.3,additional_animation:list = list()):
    target_box = Rectangle(color=color_,width=target_.get_right()[0]-target_.get_left()[0]+buff_,height=target_.get_top()[1]-target_.get_bottom()[1]+buff_).move_to(target_.get_center())
    for i in additional_animation:
        i.rate_func = lambda t:Create(Arc()).rate_func(t/2)
    scene.play(Create(target_box,rate_func=lambda t:2*Create(Arc()).rate_func(t/2)),*additional_animation)
    for i in additional_animation:
        i.rate_func = lambda t:Create(Arc()).rate_func(0.5+(t/2))
    scene.play(Uncreate(target_box.reverse_direction(),rate_func=lambda t:2*Create(Arc()).rate_func(t/2)),*additional_animation)

def TargetBox(target_:Mobject,color_:ManimColor = PURE_RED,buff_:float = 0.3):
    return Rectangle(color=color_,width=target_.get_right()[0]-target_.get_left()[0]+buff_,height=target_.get_top()[1]-target_.get_bottom()[1]+buff_).move_to(target_.get_center())

def HighLight_3D(scene:ThreeDScene,target_:Mobject,color_:ManimColor = PURE_RED,buff_:float = 0.3,additional_animation:list = list()):
    target_box = Rectangle(color=color_,width=target_.get_right()[0]-target_.get_left()[0]+buff_,height=target_.get_top()[1]-target_.get_bottom()[1]+buff_).move_to(target_.get_center())
    scene.add_fixed_in_frame_mobjects(target_box)
    for i in additional_animation:
        i.rate_func = lambda t:Create(Arc()).rate_func(t/2)
    scene.play(Create(target_box,rate_func=lambda t:2*Create(Arc()).rate_func(t/2)),*additional_animation)
    for i in additional_animation:
        i.rate_func = lambda t:Create(Arc()).rate_func(0.5+(t/2))
    target_box_reverse = target_box.reverse_direction()
    scene.add_fixed_in_frame_mobjects(target_box_reverse)
    scene.remove(target_box)
    scene.play(Uncreate(target_box_reverse,rate_func=lambda t:2*Create(Arc()).rate_func(t/2)),*additional_animation)


class s4(Scene):
    def construct(self):
        def projection(vertex,direction,force):
            return ((direction-vertex)/np.linalg.norm(direction-vertex))*(np.dot(direction-vertex,force-vertex)/np.linalg.norm(direction-vertex))+vertex
        self.wait(1)
        a = Vector([2,0,0],color=RED)
        b = Vector([cos(3*pi/4),sin(3*pi/4),0],color=BLUE)
        pab = Line([0,0,0],projection([0,0,0],a.get_vector(),b.get_vector()),color=GREEN,stroke_width=10)
        pbv = DashedLine(b.get_vector(),projection([0,0,0],a.get_vector(),b.get_vector()),color=GRAY)
        self.play(GrowArrow(a),GrowArrow(b))
        t1 = Tex(r"$\left( \mathbf{a},\mathbf{b} \right) = \left | \mathbf{a} \right | \cdot The\, Signed\, Projection\, From\, \mathbf{b}\, to\; \mathbf{a}$").set_color_by_gradient([RED,BLUE]).to_corner(UL)
        self.play(Write(pab),FadeIn(pbv),Write(t1))
        tracker = ValueTracker(3*pi/4)
        timepoint = 1
        b.add_updater(lambda m:m.put_start_and_end_on([0,0,0],
                                                      [(1+((np.linalg.norm(a.get_vector())-1)*((3*pi/4)-tracker.get_value())/(3*pi/4)))*cos(tracker.get_value()),
                                                       (1+((np.linalg.norm(a.get_vector())-1)*((3*pi/4)-tracker.get_value())/(3*pi/4)))*sin(tracker.get_value()),0]) if timepoint == 1 else m)
        pab.add_updater(lambda m:m.put_start_and_end_on([0,0,0],projection([0,0,0],a.get_vector(),b.get_vector())).set_color(GREEN if tracker.get_value()>pi/2 else PURPLE) if timepoint == 1 else m)
        pbv.add_updater(
            lambda m: m.put_start_and_end_on(b.get_vector(), projection([0, 0, 0], a.get_vector(), b.get_vector())))
        self.play(tracker.animate.set_value(0),run_time=3)
        self.remove(pbv)
        self.wait(1)
        t2 = Tex(r"$$\left( \mathbf{a},\mathbf{a} \right) \ge 0\wedge \left( a,a \right)=0 \Leftrightarrow \mathbf{a}=\mathbf{0}$$",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        timepoint = 2
        pab.add_updater(lambda m:m.put_start_and_end_on([0,0,0],a.get_vector()) if timepoint == 2 else m)
        tracker.set_value(2)
        a.add_updater(lambda m:m.put_start_and_end_on([0,0,0],[tracker.get_value(),0,0]) if timepoint == 2 else m)
        b.add_updater(lambda m: m.put_start_and_end_on([0, 0, 0], a.get_vector()) if timepoint == 2 else m)
        self.play(tracker.animate.set_value(0.1),FadeOut(a,b,pab),Write(t2))
        timepoint = 3
        b.remove_updater(lambda m:m.put_start_and_end_on([0,0,0],
                                                      [(1+((np.linalg.norm(a.get_vector())-1)*((3*pi/4)-tracker.get_value())/(3*pi/4)))*cos(tracker.get_value()),
                                                       (1+((np.linalg.norm(a.get_vector())-1)*((3*pi/4)-tracker.get_value())/(3*pi/4)))*sin(tracker.get_value()),0]) if timepoint == 1 else m)
        b.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], a.get_vector()) if timepoint == 2 else m)
        a.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], [tracker.get_value(), 0, 0]) if timepoint == 2 else m)
        pab.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], a.get_vector()) if timepoint == 2 else m)
        pab.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], projection([0, 0, 0], a.get_vector(),
                                                                               b.get_vector())).set_color(
            GREEN if tracker.get_value() > pi / 2 else PURPLE) if timepoint == 1 else m)
        pbv.remove_updater(
            lambda m: m.put_start_and_end_on(b.get_vector(), projection([0, 0, 0], a.get_vector(), b.get_vector())))
        a = Vector([2, 0, 0], color=RED)
        b = Vector([cos(3 * pi / 4), sin(3 * pi / 4), 0], color=BLUE)
        pab = Line([0, 0, 0], projection([0, 0, 0], a.get_vector(), b.get_vector()), color=GREEN, stroke_width=10)
        pbv = DashedLine(b.get_vector(), projection([0, 0, 0], a.get_vector(), b.get_vector()), color=GRAY)
        self.wait(1)
        self.play(FadeIn(a,b,pab,pbv))
        tr2 = ValueTracker(1)
        b.add_updater(lambda m:m.put_start_and_end_on([0,0,0],[cos(3 * pi / 4)*tr2.get_value(), sin(3 * pi / 4)*tr2.get_value(), 0]))
        pab.add_updater(lambda m: m.put_start_and_end_on([0, 0, 0], projection([0, 0, 0], a.get_vector(),
                                                                                  b.get_vector())))
        pbv.add_updater(
            lambda m: m.put_start_and_end_on(b.get_vector(), projection([0, 0, 0], a.get_vector(), b.get_vector())))
        a.add_updater(lambda m:m.put_start_and_end_on([0,0,0],[2/tr2.get_value(), 0, 0]))
        t3 = Tex(r"$$\left( x\mathbf{a},y\mathbf{b} \right) = xy\left( \mathbf{a},\mathbf{b} \right)$$",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(tr2.animate.set_value(3),Write(t3),pab.animate.get_center(),pbv.animate.get_center())
        self.wait(1)
        b.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], [cos(3 * pi / 4) * tr2.get_value(),
                                                                   sin(3 * pi / 4) * tr2.get_value(), 0]))
        pab.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], projection([0, 0, 0], a.get_vector(),
                                                                               b.get_vector())))
        pbv.remove_updater(
            lambda m: m.put_start_and_end_on(b.get_vector(), projection([0, 0, 0], a.get_vector(), b.get_vector())))
        a.remove_updater(lambda m: m.put_start_and_end_on([0, 0, 0], [2 / tr2.get_value(), 0, 0]))
        self.play(FadeOut(a,b,pab,pbv))
        vec_a = Vector([1,2,0],color=RED)
        vec_b = Vector([2,1,0],color=BLUE)
        vec_b_c = vec_b.copy()
        self.play(GrowArrow(vec_a),GrowArrow(vec_b))
        vec_c = Vector(vec_a.get_vector()+vec_b.get_vector(),color=GREEN)
        self.play(vec_b_c.animate.shift(vec_a.get_vector()),GrowArrow(vec_c))
        vec_d = Vector([4,0,0],color=BLACK)
        self.play(GrowArrow(vec_d))
        def projection_line(direction_1,direction_2,force_1,force_2,color_,stroken_width_):
            return Line(projection(direction_1,direction_2,force_1),projection(direction_1,direction_2,force_2),color=color_,stroke_width=stroken_width_)
        def projection_perpendiculars(direction_1,direction_2,force_1,force_2):
            return VGroup(DashedLine(projection(direction_1,direction_2,force_1),force_1,color=GRAY),DashedLine(projection(direction_1,direction_2,force_2),force_2,color=GRAY))
        def projection_group(direction_1,direction_2,force_1,force_2,color_,stroken_width_):
            return VGroup(DashedLine(projection(direction_1, direction_2, force_1), force_1, color=GRAY),
                          DashedLine(projection(direction_1, direction_2, force_2), force_2, color=GRAY),
                          Line(projection(direction_1,direction_2,force_1),projection(direction_1,direction_2,force_2),color=color_,stroke_width=stroken_width_))
        prad = projection_group(np.array([0,0,0]),vec_d.get_vector(),np.array([0,0,0]),vec_a.get_vector(),PURE_RED,10)
        prbd = projection_group(np.array([0,0,0]), vec_d.get_vector(), np.array([0,0,0]), vec_b.get_vector(), PURE_BLUE, 10)
        self.play(Write(prad),Write(prbd))
        ppcd = projection_perpendiculars(np.array([0,0,0]),vec_d.get_vector(),np.array([0,0,0]),vec_c.get_vector())
        self.play(prbd.animate.shift(RIGHT),FadeIn(ppcd))
        pcd = projection_line(np.array([0,0,0]),vec_d.get_vector(),np.array([0,0,0]),vec_c.get_vector(),PURE_GREEN,10)
        t4 = MathTex(r"\left( \mathbf{a+b},\mathbf{d}\right) = \left( \mathbf{a},\mathbf{d}\right) + \left( \mathbf{b},\mathbf{d}\right)",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(FadeIn(pcd),Write(t4))
        self.wait(1)
        self.play(FadeOut(prad,prbd,ppcd,pcd,vec_a,vec_b,vec_c,vec_d,vec_b_c))
        vec_u_a = Vector([1,0,0],color=RED_E)
        vec_u_b = Vector([cos(60*DEGREES),sin(60*DEGREES),0],color=BLUE_E)
        vec_a = Vector([3,0,0],color=RED)
        vec_b = Vector([2*cos(60*DEGREES),2*sin(60*DEGREES),0], color=BLUE)
        self.play(GrowArrow(vec_u_b),GrowArrow(vec_u_a))
        prab = projection_group(np.array([0, 0, 0]), vec_u_a.get_vector(), np.array([0, 0, 0]), vec_u_b.get_vector(),
                                PURE_BLUE, 10)
        prba = projection_group(np.array([0, 0, 0]), vec_u_b.get_vector(), np.array([0, 0, 0]), vec_u_a.get_vector(),
                                PURE_RED, 10)
        self.play(Write(prab),Write(prba))
        t5 = MathTex(r"\left( \mathbf{\frac{a}{\left| a \right|}},\mathbf{\frac{b}{\left| b \right|}}\right) = \left( \mathbf{\frac{b}{\left| b \right|}},\mathbf{\frac{a}{\left| a \right|}}\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5),Transform(prba,projection_group(np.array([0, 0, 0]), vec_u_b.get_vector(), np.array([0, 0, 0]), vec_u_a.get_vector(),
                                PURE_GREEN, 10)),Transform(prab,projection_group(np.array([0, 0, 0]), vec_u_a.get_vector(), np.array([0, 0, 0]), vec_u_b.get_vector(),
                                PURE_GREEN, 10)))
        self.wait(0.5)
        self.play(Transform(t5,MathTex(r"\left| a \right|\left| b \right|\left( \mathbf{\frac{a}{\left| a \right|}},\mathbf{\frac{b}{\left| b \right|}}\right) = \left| a \right|\left| b \right|\left( \mathbf{\frac{b}{\left| b \right|}},\mathbf{\frac{a}{\left| a \right|}}\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)),
                  Transform(prab,projection_group(np.array([0, 0, 0]), vec_a.get_vector(), np.array([0, 0, 0]), vec_b.get_vector(),
                                PURE_BLUE, 10)),Transform(prba,projection_group(np.array([0, 0, 0]), vec_b.get_vector(), np.array([0, 0, 0]), vec_a.get_vector(),
                                PURE_RED, 10)),Transform(vec_u_a,vec_a),Transform(vec_u_b,vec_b))

        self.wait(0.5)
        self.play(Transform(t5,MathTex(r"\left( \mathbf{a},\mathbf{b}\right) = \left( \mathbf{b},\mathbf{a}\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)))
        self.wait(1)
        self.play(FadeOut(vec_u_a,vec_u_b,prab,prba))
        self.wait(1)
        t6 = MathTex(r"\left(\cdot,\cdot\right):\mathbb{R}^n\times \mathbb{R}^n\rightarrow \mathbb{R}").set_color_by_gradient([RED,BLUE]).to_corner(UL)
        self.play(Transform(t1,t6),t2.animate.next_to(t1,DOWN,aligned_edge=LEFT),t3.animate.next_to(t2,DOWN,aligned_edge=LEFT),t4.animate.next_to(t3,DOWN,aligned_edge=LEFT),t5.animate.next_to(t4,DOWN,aligned_edge=LEFT))
        HighLight(self,t1)
        self.wait(1)
        HighLight(self, VGroup(t2,t3,t4,t5))
        self.wait(1)

        T1 = MathTex(r"\mathbf{e}_1=\begin{bmatrix}1 \\0 \\\vdots \\0\end{bmatrix},\mathbf{e}_2=\begin{bmatrix}0 \\1 \\\vdots \\0\end{bmatrix},...,\mathbf{e}_n=\begin{bmatrix}0 \\0 \\\vdots \\1\end{bmatrix}",color=BLACK).to_corner(UR)
        self.play(Write(T1))
        self.wait(1)

        T2 = MathTex(r"\forall i,j\in[1,n]\cap \mathbb{N}",color=BLACK).next_to(T1,DOWN,aligned_edge=RIGHT)
        T3 = MathTex(r" \left(\mathbf{e}_i,\mathbf{e}_i\right)=1, \left(\mathbf{e}_i,\mathbf{e}_j\right)=0",color=BLACK).next_to(T2,DOWN,aligned_edge=RIGHT)
        self.play(Write(T2),Write(T3))
        HighLight(self,VGroup(T2, T3))
        self.wait(1)

        T4 = MathTex(r"\mathbf{a}=\begin{bmatrix}a_1 \\a_2 \\\vdots \\a_n\end{bmatrix}=a_1\begin{bmatrix}1 \\0 \\\vdots \\0\end{bmatrix}+a_2\begin{bmatrix}0 \\1 \\\vdots \\0\end{bmatrix}+\cdots+a_n\begin{bmatrix}0 \\0 \\\vdots \\1\end{bmatrix}"
                     ,color=BLACK).next_to(T3,DOWN,aligned_edge=RIGHT)
        self.play(Write(T4))
        self.wait(0.5)
        self.play(Transform(T4,MathTex(r"\mathbf{a}=a_1\mathbf{e}_1+a_2\mathbf{e}_2+\cdots+a_n\mathbf{e}_n",color=BLACK).next_to(T3,DOWN,aligned_edge=RIGHT)))
        self.wait(0.5)
        T5 = MathTex(r"\mathbf{b}=\sum_{i=1}^{n}b_i\mathbf{e}_i ",color=BLACK).next_to(MathTex(r"\mathbf{a}=\sum_{i=1}^{n}a_i\mathbf{e}_in",color=BLACK).next_to(T3,DOWN,aligned_edge=RIGHT),DOWN,aligned_edge=RIGHT)
        self.play(Write(T5),Transform(T4,MathTex(r"\mathbf{a}=\sum_{i=1}^{n}a_i\mathbf{e}_in",color=BLACK).next_to(T3,DOWN,aligned_edge=RIGHT)))
        T6 = MathTex(r"\left(\mathbf{a},\mathbf{b}\right)=\left(\sum_{i=1}^{n}a_i\mathbf{e}_i ,\sum_{j=1}^{n}b_j\mathbf{e}_j \right)",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        T7 = MathTex(r"= \sum_{i=1}^{n}\sum_{j=1}^{n}a_ib_j\left(\mathbf{e}_i,\mathbf{e}_j\right)=\sum_{i=1}^{n}a_ib_i",color=BLACK).next_to(T6,DOWN,aligned_edge=LEFT)
        self.play(Write(T6),Write(T7))
        self.wait(0.5)
        self.play(FadeOut(T6),Transform(T7,MathTex(r"\left(\mathbf{a},\mathbf{b}\right)=\sum_{i=1}^{n}a_ib_i",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT))
                  ,FadeOut(T1,T2,T3,T4,T5))
        HighLight(self,T7)
        self.wait(1)

class s5(Scene):
    def construct(self):
        t1 = MathTex(r"\forall \mathbf{a},\mathbf{b} \in \mathbb{R}^n,\left(\mathbf{f}\left(\mathbf{a}\right)-\mathbf{f}\left(\mathbf{0}\right),\mathbf{f}\left(\mathbf{b}\right)-\mathbf{f}\left(\mathbf{0}\right)\right)=\left(\mathbf{a},\mathbf{b}\right)"
                     ,color=BLACK).to_corner(UL).set_z_index(3)
        self.wait(1)
        self.play(Write(t1))
        self.wait(1)
        t4 = MathTex(
            r"\Rightarrow \forall \mathbf{a},\mathbf{f}\left(k\mathbf{a}\right)-\mathbf{f}\left(\mathbf{0}\right)=k\left(\mathbf{f}\left(\mathbf{a}\right)-\mathbf{f}\left(\mathbf{0}\right)\right)",
            color=BLACK).next_to(t1, DOWN, aligned_edge=LEFT)
        t7 = MathTex(
            r"\Rightarrow\forall\mathbf{c},\mathbf{f}\left(\mathbf{a}+\mathbf{c}\right)-\mathbf{f}\left(\mathbf{0}\right)=\mathbf{f}\left(\mathbf{a}\right)+\mathbf{f}\left(\mathbf{c}\right)-2\mathbf{f}\left(\mathbf{0}\right)",
            color=BLACK).next_to(t4, DOWN, aligned_edge=LEFT)
        self.play(Write(t4),Write(t7))
        HighLight(self,VGroup(t4,t7))
        self.wait(1)
        t8 = MathTex(r"\Rightarrow \mathbf{f}\left(\mathbf{a}\right)=\mathbf{T}\mathbf{a}+\mathbf{v}",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        HighLight(self, VGroup(t8))
        self.wait(1)
        T1 = MathTex(r"\left(\mathbf{T}\mathbf{a}+\mathbf{v}-\left(\mathbf{T}\mathbf{0}+\mathbf{v}\right),\mathbf{T}\mathbf{b}+\mathbf{v}-\left(\mathbf{T}\mathbf{0}+\mathbf{v}\right)\right)=\left(\mathbf{a},\mathbf{b}\right)"
                     ,color=BLACK).to_corner(UL)
        T2 = MathTex(r"\Rightarrow \left(\mathbf{T}\mathbf{a},\mathbf{T}\mathbf{b}\right)=\left(\mathbf{a},\mathbf{b}\right)",color=BLACK).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(FadeOut(t1,t4,t7,t8),Write(T1),Write(T2))
        self.wait(1)
        self.play(Transform(T2,MathTex(r"\forall \mathbf{a},\mathbf{b},\left(\mathbf{T}\mathbf{a},\mathbf{T}\mathbf{b}\right)=\left(\mathbf{a},\mathbf{b}\right)",color=BLACK).to_corner(UL))
                  ,FadeOut(T1))
        self.wait(1)
        TT1 = MathTex(r"\mathbf{T}=\begin{bmatrix} \mathbf{t}_1 &\mathbf{t}_2   &\cdots  &\mathbf{t}_n \end{bmatrix}",color=BLACK).to_corner(UR)
        self.play(Write(TT1))
        self.wait(1)
        tt1 = MathTex(r"\left(\mathbf{T}\mathbf{a},\mathbf{T}\mathbf{b}\right)=\left(\sum\mathbf{t}_ia_i,\sum\mathbf{t}_ib_i\right)",color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)
        tt2 = MathTex(r"=\sum\sum a_ib_j\left(\mathbf{t}_i,\mathbf{t}_j\right)=\mathbf{a}^\top\begin{bmatrix}\left(\mathbf{t}_1,\mathbf{t}_1\right) &\left(\mathbf{t}_1,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_1,\mathbf{t}_n\right)\\ \left(\mathbf{t}_2,\mathbf{t}_1\right) &\left(\mathbf{t}_2,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_2,\mathbf{t}_n\right)\\ \vdots &\vdots  & \ddots  &\vdots\\ \left(\mathbf{t}_n,\mathbf{t}_1\right) &\left(\mathbf{t}_n,\mathbf{t}_2\right)  &\cdots  &\left(\mathbf{t}_n,\mathbf{t}_n\right)\end{bmatrix}\mathbf{b} "
                      ,color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        self.play(Write(tt1))
        self.play(Write(tt2))
        self.wait(1)
        self.play(Transform(tt2,MathTex(r"\Rightarrow\mathbf{a}^\top\begin{bmatrix}\left(\mathbf{t}_1,\mathbf{t}_1\right) &\left(\mathbf{t}_1,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_1,\mathbf{t}_n\right)\\ \left(\mathbf{t}_2,\mathbf{t}_1\right) &\left(\mathbf{t}_2,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_2,\mathbf{t}_n\right)\\ \vdots &\vdots  & \ddots  &\vdots\\ \left(\mathbf{t}_n,\mathbf{t}_1\right) &\left(\mathbf{t}_n,\mathbf{t}_2\right)  &\cdots  &\left(\mathbf{t}_n,\mathbf{t}_n\right)\end{bmatrix}\mathbf{b}=\left(\mathbf{a},\mathbf{b}\right) =\mathbf{a}^\top\mathbf{b}"
                                        ,color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)),FadeOut(tt1))
        self.wait(1)
        self.play(Transform(tt2,MathTex(r"\Rightarrow\mathbf{a}^\top\begin{bmatrix}\left(\mathbf{t}_1,\mathbf{t}_1\right) &\left(\mathbf{t}_1,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_1,\mathbf{t}_n\right)\\ \left(\mathbf{t}_2,\mathbf{t}_1\right) &\left(\mathbf{t}_2,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_2,\mathbf{t}_n\right)\\ \vdots &\vdots  & \ddots  &\vdots\\ \left(\mathbf{t}_n,\mathbf{t}_1\right) &\left(\mathbf{t}_n,\mathbf{t}_2\right)  &\cdots  &\left(\mathbf{t}_n,\mathbf{t}_n\right)\end{bmatrix}\mathbf{b}=\mathbf{a}^\top\mathbf{b}"
                                        ,color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)))
        self.wait(1)
        HighLight(self,tt2[0][4:107],additional_animation=[tt2[0][4:107].animate.set_color(RED)])
        t_ps = mytitle(r"度量矩阵",r"Metric Matrix").to_edge(DOWN)
        self.play(Write(t_ps))
        self.wait(1)
        self.play(tt2[0][4:107].animate.set_color(BLACK),FadeOut(t_ps))
        self.wait(1)
        tt3 = MathTex(r"\Rightarrow\begin{bmatrix}\left(\mathbf{t}_1,\mathbf{t}_1\right) &\left(\mathbf{t}_1,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_1,\mathbf{t}_n\right)\\ \left(\mathbf{t}_2,\mathbf{t}_1\right) &\left(\mathbf{t}_2,\mathbf{t}_2\right)  & \cdots & \left(\mathbf{t}_2,\mathbf{t}_n\right)\\ \vdots &\vdots  & \ddots  &\vdots\\ \left(\mathbf{t}_n,\mathbf{t}_1\right) &\left(\mathbf{t}_n,\mathbf{t}_2\right)  &\cdots  &\left(\mathbf{t}_n,\mathbf{t}_n\right)\end{bmatrix}=\begin{bmatrix} 1 & 0 & \cdots &0 \\  0& 1 & \cdots &0 \\  \vdots&  \vdots& \ddots & \vdots\\0  & 0 & \cdots &1\end{bmatrix}"
                      ,color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        self.play(Write(tt3))
        self.wait(1)
        tt4 = MathTex(r"\Rightarrow \forall i,j=1,2,\cdots,n,\left(\mathbf{t}_i,\mathbf{t}_i\right)=1,\left(\mathbf{t}_i,\mathbf{t}_j\right)=0",color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4))
        self.wait(1)
        self.play(FadeOut(TT1,T2,tt2,tt3,tt4))
        T_T1 = MathTex(r"\mathbf{O}\left(n\right)=\left \{ \begin{bmatrix} \mathbf{t}_1 &\mathbf{t}_2  &\cdots  &\mathbf{t}_n\end{bmatrix}\in \mathbb{R}^{n\times n} \mid \forall i,j=1,2,\cdots,n,\left(\mathbf{t}_i,\mathbf{t}_i\right)=1,\left(\mathbf{t}_i,\mathbf{t}_j\right)=0\right \}  "
                       ,color=BLACK,font_size=40)
        self.play(Write(T_T1))
        self.wait(1)
        T_TT1 = MathTex(r"\mathbf{A},\mathbf{B} \in \mathbf{O}\left( n \right)",color=BLACK).to_corner(UL)
        T_TT2 = MathTex(r"\Leftrightarrow \mathbf{A}\mathbf{B} \in \mathbf{O}\left( n \right)",color=BLACK).next_to(T_TT1,DOWN,aligned_edge=LEFT)
        self.play(ReplacementTransform(T_T1,T_TT1))
        self.play(Write(T_TT2))
        self.wait(1)
        t_ps_2 = mytitle(r"正交变换群",r"Orthogonal Transformation Group").to_edge(DOWN)
        self.play(Write(t_ps_2))
        self.wait(1)
        self.play(FadeOut(t_ps_2))
        T_TT3 = MathTex(r"\mathbf{A}^{-1}\mathbf{A}=\mathbf{E}\in \mathbf{O}\left( n \right)",color=BLACK).next_to(T_TT2,DOWN,aligned_edge=LEFT)
        T_TT4 = MathTex(r"\mathbf{A}\in \mathbf{O}\left( n \right) \Leftrightarrow \mathbf{A}^{-1}\in\mathbf{O}\left(n\right)",color=BLACK).next_to(T_TT2,DOWN,aligned_edge=LEFT)
        self.play(Write(T_TT3))
        self.play(ReplacementTransform(T_TT3,T_TT4))
        self.wait(1)
        T_TT5 = MathTex(r"\mathbf{A}^{\top}\mathbf{A}=\begin{bmatrix}\mathbf{a}_{1}^{\top}  \\\mathbf{a}_{2}^{\top}\\\vdots \\\mathbf{a}_{n}^{\top}\end{bmatrix}\begin{bmatrix}\mathbf{a}_{1} &  \mathbf{a}_{2}&\cdots &\mathbf{a}_{n}\end{bmatrix}"
                        ,color=BLACK).next_to(T_TT4,DOWN,aligned_edge=LEFT)
        T_TT6 = MathTex(r"=\begin{bmatrix}\mathbf{a}_{1}^{\top}\mathbf{a}_{1}  &\mathbf{a}_{1}^{\top}\mathbf{a}_{2}  &\cdots  &\mathbf{a}_{1}^{\top}\mathbf{a}_{n} \\ \mathbf{a}_{2}^{\top}\mathbf{a}_{1}  &\mathbf{a}_{2}^{\top}\mathbf{a}_{2}  &\cdots  &\mathbf{a}_{2}^{\top}\mathbf{a}_{n} \\\vdots &\vdots  & \ddots &\vdots \\\mathbf{a}_{n}^{\top}\mathbf{a}_{1}  &\mathbf{a}_{n}^{\top}\mathbf{a}_{2}  &\cdots  &\mathbf{a}_{n}^{\top}\mathbf{a}_{n}\end{bmatrix}=\begin{bmatrix}1  & 0 &\cdots  &0 \\0  & 1 & \cdots&0 \\  \vdots&\vdots & \ddots &\vdots \\ 0 &0  &\cdots  &1\end{bmatrix}"
                        ,color=BLACK).next_to(T_TT5,DOWN,aligned_edge=LEFT)
        self.play(Write(T_TT5))
        self.play(Write(T_TT6))
        self.wait(1)
        T_TT7 = MathTex(r"\mathbf{A}\in \mathbf{O}\left( n \right) \Leftrightarrow \mathbf{A}^{-1} =\mathbf{A}^{\top} \in\mathbf{O}\left(n\right)",color=BLACK).next_to(T_TT4,DOWN,aligned_edge=LEFT)
        self.play(FadeOut(T_TT5,T_TT6),Write(T_TT7))
        self.wait(1)

def RotateMatrix(theta:float):
    return np.array([[cos(theta),-sin(theta)],[sin(theta),cos(theta)]])
def Get_Angle(v1,v2):
    return np.arccos(np.dot(v1,v2)/(np.linalg.norm(v1)*np.linalg.norm(v2)))
def Write_In_Group_Althernately(group):
    g = [Write(i) for i in group]
    return Succession(*g)
def Write_In_Group(group):
    return AnimationGroup(*[Write(i)for i in group])

class s6(Scene):
    def construct(self):
        number_plane = NumberPlane(axis_config={"color":BLACK})
        v = Vector([2,1,0],color=RED)
        dot = Dot([2,1,0],color=PURE_RED)
        t1 = MathTex(r" A\, Point  = \left \{  \mathbf{p}  \right \}  , \mathbf{p}\in\mathbf{V}",color=PURE_RED).to_corner(UL)
        self.wait(1)
        self.play(Create(number_plane))
        self.play(GrowArrow(v))
        self.play(Write(dot))
        self.play(Write(t1))
        HighLight(self,t1)
        self.wait(1)
        t2 = t1.copy()
        self.play(Transform(t2,MathTex(r"A\, Point = \mathbf{p} \,\, ???",color=PURE_BLUE).next_to(t1,DOWN,aligned_edge=LEFT)))
        self.wait(1)
        self.play(Transform(t2,MathTex(r"A\, Point = \mathbf{p}",color=PURE_BLUE).next_to(t1,DOWN,aligned_edge=LEFT)))
        self.wait(1)
        self.play(FadeOut(t2,v))
        line = Line([2,1,0],[2,1,0],color=PURE_RED)
        self.play(line.animate.put_start_and_end_on([2,1,0],[-2,-2,0]),dot.animate.move_to([-2,-2,0]))
        t3 = MathTex(r"A\, Shape \subseteq \mathbf{V}",color=PURE_RED).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t3),FadeOut(dot))
        sqr = Polygon([2,1,0],[-2,-2,0],[-1,1,0],[-1,1,0],color=RED,fill_opacity=0.5)
        sqrr = Polygon([2, 1, 0], [-2, -2, 0], [-2, -2, 0], [2, 1, 0], color=RED,fill_opacity=0.5)
        self.play(Transform(sqrr,sqr),line.animate.put_start_and_end_on([-1,1,0],[-1,1,0]))
        self.play(line.animate.put_start_and_end_on([2,1,0],[-2,-2,0]))
        self.wait(1)

def plot_function(axes:Axes,func):
    return lambda x:axes.c2p(np.array([0, func(axes.p2c(np.array([x, 0, 0]))[0]), 0]))[0][1]

def plot_impl(axes,func):
    return lambda x,y:func(*axes.p2c([x,y,0]))

def Two_to_Three(vec):
    return np.array([vec[0],vec[1],0])

def linear_insert_manimcolor(color1:ManimColor,color2:ManimColor,factor:float):
    def color_time(c:ManimColor,x:float):
        return ManimColor(x*c.to_rgb())
    return ManimColor(color_time(color1,1-factor).to_rgb()+color_time(color2,factor).to_rgb())

class s6_1(ThreeDScene):
    def fadeclear(self):
        self.play(FadeOut(*self.mobjects))
    def construct(self):
        t1 = MathTex(r"\mathbb{R}^n=\left\{ \begin{pmatrix}x_1 \\x_2 \\\vdots \\x_n\end{pmatrix} \mid x_1,x_2,\cdots,x_n \in \mathbb{R} \right\}",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\mathbf{f}:\mathbb{R}^n \leftrightarrow \mathbf{S}",color=BLACK).to_corner(UL)
        self.play(ReplacementTransform(t1,t2))
        self.wait(1)
        nbp = NumberPlane(axis_config={"color":BLACK})
        self.play(Create(nbp))
        self.add_fixed_in_frame_mobjects(t2)
        t_ps = Text("此处是n=2时的，即两个实数（二维坐标轴上的点代表它）映射到唯一确定的一个形状上的点（红色的）",color=GRAY,font_size=20).to_corner(DR)
        self.add_fixed_in_frame_mobjects(t_ps)
        shape = Surface(lambda u,v:[u,v,0.3*(u*u+(v*v))],
                        u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        self.move_camera(phi=60*DEGREES,theta=-30*DEGREES,added_anims=[Create(shape),Write(t_ps)])
        self.wait(1)
        sh = Surface(lambda u,v:[u,v,0],
                        u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[BLUE,BLUE_E],fill_opacity=0.5,resolution=4)
        d1 = Dot3D([-1,1,0],color=PURE_BLUE)
        d2 = Dot3D([-1,1,0],color=PURE_BLUE)
        ld12 = DashedLine([-1,1,0],[-1,1,0],color=GREY)
        self.play(FadeIn(sh,d1))
        t3 = MathTex(r"\begin{pmatrix}-1 \\-1\end{pmatrix}\mapsto f\left(\begin{pmatrix}-1 \\-1\end{pmatrix}\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t3[0][0:6].set_color(BLUE)
        t3[0][8:].set_color(RED)
        self.add_fixed_in_frame_mobjects(t3)
        self.play(Transform(sh,shape),d2.animate.become(Dot3D([-1,1,0.6],color=PURE_RED)),ld12.animate.become(DashedLine([-1,1,0],[-1,1,0.6],color=GREY)),Write(t3))
        self.wait(1)
        self.play(FadeOut(t_ps))
        self.play(FadeOut(t2,t3,ld12,d1,d2,nbp,shape,sh))
        self.set_camera_orientation(phi=0,theta=-90*DEGREES)
        t4 = MathTex(r"\exists f:\mathbb{R}^n\leftrightarrow \mathbf{A} \Leftrightarrow \mathbf{A}\, is\, n-dimentional",color=BLACK)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"?",color=RED,font_size=160)
        self.play(Write(t5))
        self.wait(1)
        self.play(t4.animate.to_corner(UL),FadeOut(t5))
        t6 = MathTex(r"when:1)\,\,\,\lnot\exists\mathbf{g}:\mathbb{R}^a\leftrightarrow \mathbf{A} \,\, s.t.\, a<n",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\mathbf{f}:\mathbb{R}\leftrightarrow \mathbf{A}",color=RED).to_corner(UR)
        t8 = MathTex(r"\mathbf{g}\left(\begin{pmatrix}x_1 \\x_2\\\vdots\\x_{114514}\end{pmatrix}\right)=:\mathbf{f}\left(x_1\right)"
                     ,color=RED).next_to(t7,DOWN,aligned_edge=RIGHT)
        t9 = MathTex(r":\mathbb{R}^{114514}\leftrightarrow\mathbf{A}",color=RED).next_to(t8,DOWN,aligned_edge=LEFT)
        t10 = MathTex(r"dimention\left(\mathbf{A}\right)=???",color=PURE_RED).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t7,t8,t9,t10]))
        self.wait(1)
        self.play(FadeOut(t7,t8,t9,t10))
        self.wait(1)
        t11 = MathTex(r"2)\,\,\, \left | \left\{\mathbf{x}\in\mathbb{R}^n\mid \frac{d\mathbf{f}}{d\mathbf{x}}\,is\,undifined\right\} \right | <\aleph_0",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        t_psps = VGroup(Text("如果一个集合内的元素可以用部分或全体自然数一个个标上序号，则称这个集合是可数的",color=GRAY,font_size=20)
                        ,Text("且，全体自然数的“个数”叫做可数无穷",color=GRAY,font_size=20)
                        ,Text("这里称不可导点的个数不大于可数无穷，意思就是这些不可导点组成的集合是可数的",color=GRAY,font_size=20)).arrange(DOWN).to_corner(DR)
        self.play(Write(t11),Write(t_psps))
        self.wait(1)
        T0 = MathTex(r"\exists q:\mathbb{R}\leftrightarrow\mathbb{R}^n",color=PURE_RED).to_corner(UR)
        self.play(Write(T0),FadeOut(t_psps))
        self.wait(1)
        self.play(FadeOut(t4,t6,t11),T0.animate.become(T0.copy().set_color(BLACK).to_corner(UL)))
        self.wait(1)
        TT1 = MathTex(r"\mathbf{f}:\mathbb{R}^n \leftrightarrow \mathbf{A}",color=BLACK).next_to(T0,DOWN,aligned_edge=LEFT)
        TT2 = MathTex(r"\mathbf{g}\left(x\right)=\mathbf{f}\left(q\left(x\right)\right):\mathbb{R}\leftrightarrow\mathbf{A}",color=BLACK).next_to(TT1,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([TT1,TT2]))
        self.wait(1)
        self.play(FadeOut(TT1,TT2))
        T1 = MathTex(r"1)\,Proof:\,\exists y:\left(0,1\right)\leftrightarrow\mathbb{R}",color=BLACK).next_to(T0,DOWN,aligned_edge=LEFT)
        self.play(Write(T1))
        self.wait(1)
        axes = Axes(axis_config={"color":BLACK})
        self.play(Create(axes))
        tangr = FunctionGraph(plot_function(axes,lambda x:np.tan(x)),color=BLUE)
        self.play(Create(tangr))
        t_und = Text("未定义！！！",color=PURE_RED,font_size=80)
        self.play(Write(t_und))
        self.wait(1)
        self.play(FadeOut(tangr,t_und))
        self.wait(1)
        g_1ox = ImplicitFunction(plot_impl(axes,lambda x,y:x*y-1),color=RED)
        self.play(Create(g_1ox))
        self.wait(1)
        g_01ox = ImplicitFunction(plot_impl(axes,lambda x,y:x*y-1),color=BLUE,x_range=[0,axes.get_x_unit_size()])
        self.play(Create(g_01ox))
        self.wait(1)
        g_m1_0ox = ImplicitFunction(plot_impl(axes,lambda x,y:x*y-1),color=GREEN,x_range=[axes.get_x_unit_size()*-1,0],y_range=[-20,0])
        self.play(Create(g_m1_0ox))
        self.wait(1)
        self.play(g_m1_0ox.animate.shift(axes.get_x_unit_size()*2*RIGHT+axes.get_y_unit_size()*2*UP),FadeOut(g_1ox))
        self.play(g_m1_0ox.animate.set_color(BLUE))
        self.wait(1)
        gadss = VGroup(g_m1_0ox,g_01ox)
        self.play(gadss.animate.stretch(factor=0.5,dim=0,about_edge=LEFT))
        t_ttt = MathTex(r"y\left(x\right)=\begin{cases}\frac{1}{2x},0<x\le 0.5 \\\frac{1}{2x-2}+2,0.5<x< 1 \end{cases}",color=BLACK).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(Write(t_ttt))
        self.wait(1)
        self.play(Transform(T1,MathTex(r"1)\,\exists y:\left(0,1\right)\leftrightarrow\mathbb{R}",color=BLACK).next_to(T0,DOWN,aligned_edge=LEFT)),FadeOut(t_ttt,gadss,axes))
        self.wait(1)
        T2 = MathTex(r"2)\,\exists \mathbf{j}:\mathbf{A}\leftrightarrow\mathbb{R}^n,\mathbf{A}=\left\{\begin{pmatrix}x_1 \\ x_2\\ \vdots\\x_3\end{pmatrix}\mid x_1,x_2,\cdots,x_3\in\left(0,1\right)\right\}"
                     ,color=BLACK).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(Write(T2))
        t_ttt2 = MathTex(r"\mathbf{j}\left(\mathbf{x}\right)=\begin{pmatrix}y\left(x_1\right) \\ y\left(x_2\right)\\ \vdots\\y\left(x_3\right)\end{pmatrix}",color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)
        self.play(Write(t_ttt2))
        self.play(Transform(T1,MathTex(r"1)\,\exists y:\mathbf{B}\leftrightarrow\mathbb{R},\mathbf{B}=\left(0,1\right)",color=BLACK).next_to(T0,DOWN,aligned_edge=LEFT))
                  ,T2.animate.next_to(T1,DOWN,aligned_edge=LEFT),t_ttt2.animate.next_to(T2,DOWN,aligned_edge=LEFT))
        self.wait(1)
        self.play(FadeOut(t_ttt2))
        self.wait(1)
        TTT = MathTex(r"\exists\mathbf{h}:\mathbf{A}\leftrightarrow\mathbf{B}\Rightarrow\exists\mathbf{f}:\mathbb{R}\leftrightarrow\mathbb{R}^n",color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)
        self.play(Write(TTT))
        self.wait(1)
        self.play(FadeOut(T1,T2),Transform(TTT,MathTex(r"3)\,Proof:\,\,\exists\mathbf{h}:\mathbf{A}\leftrightarrow\mathbf{B}",color=BLACK).next_to(T0,DOWN,aligned_edge=LEFT)))
        self.wait(1)
        nbpp = NumberPlane(axis_config={"color":BLACK}).scale(2)
        self.play(Create(nbpp))
        self.wait(1)
        dot222 = Vector([5*0.1357,5*0.2468],color=GREEN)
        Tdot = MathTex(r"\mathbf{a}=\begin{bmatrix} 0.a_{11}a_{12}a_{13}\cdots\\0.a_{21}a_{22}a_{23}\cdots \\\vdots\end{bmatrix}=\begin{bmatrix} 0.1357\cdots\\0.2468\cdots \\\vdots\end{bmatrix}",color=BLACK).next_to(TTT,DOWN,aligned_edge=LEFT)
        Tdot[0][0].set_color(GREEN)
        Tdot[0][7:19].set_color(PURE_RED)
        Tdot[0][21:33].set_color(PURE_BLUE)
        Tb = MathTex(r"b=0.a_{11}a_{21}\cdots a_{12}a_{22}\cdots = 0.12345678\cdots",color=BLACK).next_to(Tdot,DOWN,aligned_edge=LEFT)
        Tb[0][4:7].set_color(PURE_RED)
        Tb[0][7:10].set_color(PURE_BLUE)
        Tb[0][13:16].set_color(PURE_RED)
        Tb[0][16:19].set_color(PURE_BLUE)
        for i in range(0,8):
            Tb[0][25+i].set_color(PURE_RED if i % 2 == 0 else PURE_BLUE)
        area = Square(stroke_color=BLACK,fill_color=BLACK,fill_opacity=0.1).move_to([0,0,0],aligned_edge=DL)
        te = MathTex(r"A",color=BLACK).move_to(area.get_center())
        self.play(Create(dot222),Write(Tdot),FadeIn(area,te))
        self.wait(1)
        self.play(Write(Tb),Rotate(dot222,angle=-30*DEGREES,about_point=[0,0,0]))
        self.play(Rotate(dot222,angle=30*DEGREES,about_point=[0,0,0]))
        self.wait(1)
        self.play(FadeOut(area,te,dot222,Tdot,Tb,nbpp))
        ttttt = MathTex(r"\mathbf{q}\left(x\right)=\mathbf{h}\left(y^{-1}\left(x\right)\right):\mathbb{R}\leftrightarrow\mathbb{R}^{n}",color=RED).next_to(TTT,DOWN,aligned_edge=LEFT)
        self.play(Write(ttttt))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        the = -5*DEGREES
        ba = -10
        lin = ParametricFunction(lambda t:np.array([RotateMatrix(the*DEGREES).dot(np.array([t+ba,sin(t+ba)]))[0],RotateMatrix(the*DEGREES).dot(np.array([t+ba,sin(t+ba)]))[1],0]),t_range=(0,0),color=RED,stroke_width=4)
        trac = ValueTracker(0)
        lin.add_updater(lambda m:m.become(ParametricFunction(lambda t:np.array([RotateMatrix(the*DEGREES).dot(np.array([t+ba,sin(t+ba)]))[0]
                                                                                   ,RotateMatrix(the*DEGREES).dot(np.array([t+ba,sin(t+ba)]))[1],0])
                                                             ,t_range=(0,trac.get_value()),color=RED,stroke_width=4)))
        arr = Arrow(Two_to_Three(RotateMatrix(the*DEGREES).dot(np.array([ba,sin(ba)]))),Two_to_Three(RotateMatrix(the*DEGREES).dot(np.array([ba,0.5*sin(ba)])))
                    +Two_to_Three(RotateMatrix(the*DEGREES).dot([0.5,0.5*cos(ba)])),color=BLACK,buff=0)
        arr.add_updater(lambda m:m.become(Arrow(Two_to_Three(RotateMatrix(the*DEGREES).dot(np.array([trac.get_value()+ba,sin(trac.get_value()+ba)])))
                                                ,Two_to_Three(RotateMatrix(the*DEGREES).dot(np.array([trac.get_value()+ba,sin(trac.get_value()+ba)])))
                                                +Two_to_Three(RotateMatrix(the*DEGREES).dot([0.5,0.5*cos(trac.get_value()+ba)])),color=BLACK,buff=0)))
        self.add(lin,arr)
        self.play(trac.animate.set_value(7*PI),run_time = 7,rate_function=lambda t:t)
        self.wait(1)
        lin2 = ParametricFunction(lambda t:3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([t+ba,0.2*cos(t+ba)])),t_range=(0,0),color=BLUE,stroke_width=4)
        ar2 = Arrow(3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([ba,0.2*cos(ba)])),3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([0.5,-0.2*sin(ba)]))+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([ba,0.2*cos(ba)])),color=BLACK,buff=0)
        tra2 = ValueTracker(0)
        lin2.add_updater(lambda m:m.become(ParametricFunction(lambda t:3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([t+ba,0.2*cos(t+ba)])),t_range=(0,tra2.get_value()),color=BLUE,stroke_width=4)))
        ar2.add_updater(lambda m:m.become(Arrow(3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([tra2.get_value()+ba,0.2*cos(tra2.get_value()+ba)])),3*UP+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([0.5,-0.1*sin(tra2.get_value()+ba)]))+Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([tra2.get_value()+ba,0.2*cos(tra2.get_value()+ba)])),color=BLACK,buff=0)))
        self.add(lin2,ar2)
        self.play(tra2.animate.set_value(7*PI),ar2.animate.get_center(),run_time = 7,rate_function=lambda t:t)
        self.wait(1)
        item_number = 5
        lines = VGroup(*[ParametricFunction(lambda t:(item_number-i-2+0.5)*UP
                                                     +Two_to_Three(RotateMatrix(-2.5*DEGREES).dot([t+ba,0.2*cos(t+ba)]))
                                            ,t_range=(0,7*PI),color=linear_insert_manimcolor(BLUE,RED,(item_number-i)/item_number)
                                            ,stroke_width=4)for i in range(item_number)])

        fs = 20
        T_PSPS = VGroup(Text("这是因为自然数集的测度是0",font_size=fs,color=GRAY),Text("但这并不是这期视频讨论的主要内容，所以用不严谨的直观动画来解释",font_size=fs,color=GRAY)).arrange(DOWN).to_corner(DR)
        self.play(Create(lines),Write(T_PSPS),run_time=2)
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        dots_number = 5
        dots = VGroup(*[Dot(np.array([cos(i*2*PI/dots_number),sin(i*2*PI/dots_number),0]),color=BLACK)for i in range(dots_number)])
        z_d = Text("仍是零维形",color=BLACK).next_to(dots,DOWN)
        self.play(Succession(*[Create(i)for i in dots]),Write(z_d))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        te222 = MathTex(r"\mathbf{A}_i\,\,is\,n-dimensional\Rightarrow Dimension\left(\bigcup\mathbf{A}_i\right) = n",color=BLACK).to_corner(UL)
        te333 = MathTex(r"\exists u:\bigcup\left(a_i,b_i\right)\leftrightarrow\mathbb{R}"
                        ,color=BLACK).next_to(te222,DOWN,aligned_edge=LEFT)
        self.play(Write(te222))
        self.wait(1)
        self.play(Write(te333))
        self.wait(1)
        self.fadeclear()
        t_final1 = MathTex(r"\mathbf{A}\,\,is\,n-dimensional",color=BLACK).to_corner(UL)
        t_final2 = MathTex(r"\Leftrightarrow",color=BLACK).next_to(t_final1,DOWN,aligned_edge=LEFT)
        t_final3 = MathTex(r"1)\exists \mathbf{f}:\mathbb{N}\times\mathbb{R}^n \leftrightarrow \mathbf{A}",color=BLACK).next_to(t_final2,DOWN,aligned_edge=LEFT)
        t_final4 = MathTex(r"2)\left\{\mathbf{p}\in\mathbb{N}\times\mathbb{R}\mid\frac{d\mathbf{f}}{d\mathbf{p}}\,\,is\,undefined\right\}\,\,is\,countable"
                           ,color=BLACK).next_to(t_final3,DOWN,aligned_edge=LEFT)
        t_final5 = MathTex(r"3)\neg\exists \mathbf{k}:\mathbb{N}\times\mathbb{R}^a\leftrightarrow\mathbf{A}\,s.t.\,a<n",color=BLACK).next_to(t_final4,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t_final1,t_final2,t_final3]))
        self.wait(1)
        self.play(Write(t_final4))
        self.wait(1)
        self.play(Write(t_final5))
        self.wait(1)

class s7(Scene):
    def construct(self):
        text = Text("一条线",color=BLACK).to_corner(UL)
        tex = MathTex(r"\mathbf{S}^1",color=RED).next_to(text,RIGHT)
        self.wait(1)
        self.play(Write_In_Group_Althernately([text,tex]))
        self.wait(1)
        ba = -PI
        en = PI
        tra = ValueTracker(0)
        tranag = ValueTracker(0)
        tra2 = ValueTracker(0)
        cent = always_redraw(lambda:Dot(tra2.get_value()*np.array([3,1,0]),color=BLACK))
        graph = always_redraw(lambda:ParametricFunction(lambda t:np.array([t,0.5*sin(t),0])+tra2.get_value()*np.array([3,1,0]),t_range=(tranag.get_value(),tra.get_value()),color=RED,stroke_width=4))
        dot = always_redraw(lambda:Dot(np.array([tra.get_value(),0.5*sin(tra.get_value()),0]+tra2.get_value()*np.array([3,1,0])),color=BLACK))
        dotdot = always_redraw(lambda:Dot(np.array([tranag.get_value(),0.5*sin(tranag.get_value()),0]+tra2.get_value()*np.array([3,1,0])),color=BLACK))
        texttt = always_redraw(lambda:MathTex(r"\mathbf{f}"+r"\left({:.1f}\right)".format((tra.get_value())/(en)),color=BLACK).next_to(dot.get_center(),UR))
        texTTT = always_redraw(
            lambda: MathTex(r"\mathbf{f}" + r"\left(-{:.1f}\right)".format((tranag.get_value()) / (ba)),
                            color=BLACK).next_to(dotdot.get_center(), UR))
        t1 = MathTex(r"\mathbf{f}:\left(a,b\right)\rightarrow \mathbf{S}^1",color=BLACK).next_to(VGroup(text,tex),DOWN,aligned_edge=LEFT)
        t1[0][len(t1[0])-2:len(t1[0])].set_color(RED)
        self.add(graph,dot,texttt,cent)
        titfirst = mytitle("（瞬时）位置函数","Position Function").to_edge(DOWN)
        self.play(Write(t1),Write(titfirst))
        self.wait(1)
        titzero = MathTex(r"\mathbf{f}\left(0\right)=\mathbf{0}",color=GRAY).to_corner(UR)
        self.play(Write(titzero))
        self.play(FadeOut(titfirst,titzero))
        self.play(tra.animate.set_value(en),run_time=4)
        self.add(dotdot,texTTT)
        self.play(tranag.animate.set_value(ba),run_time=4)
        self.wait(1)
        self.play(FadeOut(texTTT))
        t2 = MathTex(r"\mathbf{S}^1 = \left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(t\right),t\in\left(a,b\right)\right\}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        T1 = mytitle("时域","Time Domain").to_edge(DOWN)
        t_psps = Text(r"注明：这里的区间也可以是闭区间",font_size=30,color=PURE_RED).to_corner(UR)
        self.play(Write(T1),Write(t_psps))
        HighLight(self,t1[0][3:7])
        HighLight(self,t2[0][len(t2[0])-5:len(t2[0])-1])
        self.wait(1)
        self.play(FadeOut(T1,t_psps))
        arr = always_redraw(lambda:Arrow([0,0,0],tra2.get_value()*np.array([3,1,0]),color=YELLOW_D,buff=0))
        graph.remove_updater(lambda m:m.become(ParametricFunction(lambda t:np.array([t,0.5*sin(t),0]),t_range=(ba,tra.get_value()),color=RED,stroke_width=4)))
        dot.remove_updater(lambda m:m.move_to(np.array([tra.get_value(),0.5*sin(tra.get_value()),0])))
        wdwdwdw = MathTex(r"\mathbf{f}" + r"\left({:.1f}\right)".format((tra.get_value() - ba) / (en - ba)), color=BLACK).next_to(
            dot.get_center(), UR)
        adadada = MathTex(r"\mathbf{f}" + r"\left({:.1f}\right)".format((tra.get_value() - ba) / (en - ba)) + r"+\mathbf{A}", color=BLACK).next_to(
            dot.get_center(), UR)
        self.remove(texttt)
        self.add(arr,wdwdwdw)
        self.play(tra2.animate.set_value(1),Transform(t2
                                                      ,MathTex(r"\mathbf{S}^1 = \left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(t\right)+\mathbf{A},t\in\left(a,b\right)\right\}"
                                                               ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)),Transform(wdwdwdw,adadada))
        self.wait(1)
        tit3 = mytitle("绝对原点","Absolute Origin").to_edge(DOWN)
        self.play(Write(tit3))
        HighLight(self,t2[0][15])
        self.wait(1)
        self.play(FadeOut(tit3))
        tit3_1 = mytitle("相对原点","Relative Origin").to_corner(DOWN)
        self.play(Write(tit3_1))
        HighLight(self,cent)
        self.wait(1)

        self.play(FadeOut(tit3_1))
        self.wait(1)
        t3 = MathTex(r"\exists j:\left(a,b\right)\leftrightarrow\mathbb{R}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t4 = MathTex(r"\mathbf{F}\left(z,t\right)=\mathbf{f}\left(j^{-1}\left(t\right)\right)+\mathbf{A}:\mathbb{N}\times\mathbb{R}\leftrightarrow\mathbf{S}^1"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t3,t4]))
        self.wait(1)
        self.play(FadeOut(t3,t4))
        t5 = MathTex(r"\frac{d\mathbf{f}}{dt}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        tit4 = mytitle("（瞬时）速度函数","Velocity Function").to_edge(DOWN)
        self.play(Write(tit4))
        HighLight(self,t5)
        self.wait(1)
        self.play(FadeOut(tit4,t5))
        self.wait(1)

        # The start of s7_1 which on the draft
        # s7_1
        # s7_1
        # s7_1
        # The start of s7_1 which on the draft
        self.wait(1)

        tra3 = ValueTracker(0)
        tra4 = ValueTracker(0)
        dot2 = always_redraw(lambda:Dot(np.array([tra3.get_value(),0.5*sin(tra3.get_value()),0]+tra2.get_value()*np.array([3,1,0])),color=PURE_BLUE))
        dot3 = always_redraw(lambda:Dot(np.array([tra4.get_value(),0.5*sin(tra4.get_value()),0]+tra2.get_value()*np.array([3,1,0])),color=PURE_GREEN))
        self.add(dot2,dot3)
        self.play(tra3.animate.set_value(en))
        self.play(tra4.animate.set_value(ba))
        tit5 = mytitle("下终时","Down End Time").to_edge(DOWN)
        self.play(Write(tit5))
        HighLight(self,t2[0][len(t2[0])-5])
        #HighLight(self,dot_start)
        self.wait(1)
        self.play(FadeOut(tit5))
        tit6 = mytitle("上终时","Up End Time").to_edge(DOWN)
        self.play(Write(tit6))
        HighLight(self,t2[0][len(t2[0])-3])
        #HighLight(self, dot2)
        self.wait(1)
        self.play(FadeOut(tit6,wdwdwdw))
        self.wait(1)
        tds = MathTex(r"\mathbf{f}\left(a\right)+\mathbf{A}",color=PURE_GREEN).next_to(dot3,DR)
        tdf = MathTex(r"\mathbf{f}\left(b\right)+\mathbf{A}",color=PURE_BLUE).next_to(dot2,DL)
        self.play(Write_In_Group_Althernately([tds,tdf]))
        tit7 = mytitle("下终点","Down End Point").to_edge(DOWN)
        tit8 = mytitle("上终点","Up End Point").to_edge(DOWN)
        self.play(Write(tit7))
        HighLight(self,dot3)
        self.wait(1)
        self.play(FadeOut(tit7))
        self.play(Write(tit8))
        HighLight(self, dot2)
        self.wait(1)
        self.play(FadeOut(*self.mobjects))

        # The start of s7_2 which on the draft
        # s7_2
        # s7_2
        # s7_2
        # The start of s7_2 which on the draft
        self.wait(1)

        textc = Text(r"一条直线",color=BLACK).to_corner(UL)
        texc = MathTex(r"\mathbf{L}^1",color=RED).next_to(textc,RIGHT)
        self.play(Write_In_Group_Althernately([textc,texc]))
        tt1 = MathTex(r"\mathbf{L}^1=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(t\right)+\mathbf{A},t\in\left(a,b\right)\right\}"
                      ,color=BLACK).next_to(VGroup(textc,texc),DOWN,aligned_edge=LEFT)
        tt2 = MathTex(r"\frac{d\mathbf{f}}{dt}=\mathbf{q}",color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        self.play(Write(titzero),Write_In_Group_Althernately([tt1,tt2]))
        self.wait(1)
        tt3 = MathTex(r"\mathbf{f}\left(t\right)=\int_{0}^{t}\mathbf{f}'\left(x\right)dx=\mathbf{q}t",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)

        def f(t):
            return (t*Q)+(TRAA.get_value()*A)

        TRA1 = ValueTracker(0)
        TRA2 = ValueTracker(0)
        TRAA = ValueTracker(0)

        Q = normalize(np.array([2,-1,0]))
        A = normalize(np.array([1,1,0]))

        DOTCENT = always_redraw(lambda :Dot(TRAA.get_value()*A,color=BLACK))
        DOTUP = always_redraw(lambda :Dot(f(TRA1.get_value()),color=BLACK))
        DOTDOWN = always_redraw(lambda: Dot(f(TRA2.get_value()), color=BLACK))
        line2 = always_redraw(lambda:ParametricFunction(lambda t:f(t),t_range=(TRA2.get_value(),TRA1.get_value()),color=RED,stroke_width=4))

        Q_UP = always_redraw(lambda :VGroup(Arrow(f(TRA1.get_value()),f(TRA1.get_value())+Q,color=RED_E,buff=0)
                                            ,MathTex(r"\frac{d\mathbf{f}}{dt}",color=RED_E).next_to(
                Arrow(f(TRA1.get_value()),f(TRA1.get_value())+Q,color=RED_E,buff=0),UR)))
        Q_DOWN = always_redraw(lambda: VGroup(Arrow(f(TRA2.get_value()), f(TRA2.get_value()) - Q, color=GREEN_E, buff=0)
                                            , MathTex(r"-\frac{d\mathbf{f}}{dt}", color=GREEN_E).next_to(
                Arrow(f(TRA2.get_value()), f(TRA2.get_value()) - Q, color=GREEN_E, buff=0), UR)))
        A_ARR = Vector(A,color=YELLOW_E)

        self.play(Write(tt3))
        self.add(DOTUP,DOTCENT,DOTDOWN,line2,Q_UP)
        self.play(TRA1.animate.set_value(4),run_time=2)
        self.add(Q_DOWN)
        self.play(TRA2.animate.set_value(-4),run_time=2)
        self.wait(1)
        self.play(FadeOut(Q_DOWN))
        Q_UP_ = VGroup(Arrow(f(4),f(4)+Q,color=RED_E,buff=0)
                                            ,MathTex(r"\frac{d\mathbf{f}}{dt}",color=RED_E).next_to(
                Arrow(f(4),f(4)+Q,color=RED_E,buff=0),UR))
        self.remove(Q_UP)
        self.add(Q_UP_)
        self.play(TRAA.animate.set_value(1),GrowArrow(A_ARR),Q_UP_.animate.shift(A))
        t_straightline = MathTex(r"\mathbf{L}^1=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{q}t+\mathbf{A},t\in\left(a,b\right)\right\}",color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(t_straightline))
        HighLight(self,t_straightline)
        self.wait(1)
        TIT_1 = mytitle("基向量","Base Vector").to_edge(DOWN)
        self.play(Write(TIT_1))
        HighLight(self,Q_UP_)
        self.play(FadeOut(TIT_1))
        self.wait(1)

class s7_3(Scene):
    def construct(self):
        self.wait(1)

        A = np.array([-1,0,0])
        B = np.array([2,1,0])
        Q_A = Dot(A,color=RED_E)
        Q_B = Dot(B,color=DARK_BLUE)
        AB = Line(A,B).set_color_by_gradient([BLUE,RED])
        self.play(Create(Q_A),Create(Q_B))
        self.play(Write(AB))
        self.wait(1)
        self.play(FadeOut(AB))
        self.wait(1)

        vec = Arrow(A,B,color=GREEN_E,buff=0)
        t_vec = MathTex(r"\mathbf{B}-\mathbf{A}",color=GREEN_E).next_to(vec,UR)
        self.play(GrowArrow(vec),Write(t_vec))
        self.wait(1)

        def _AB(t):
            return (B-A)*t+A

        tra1 = ValueTracker(0)

        P = always_redraw(lambda:Dot(_AB(tra1.get_value()),color=BLACK))
        AB = always_redraw(lambda:Line(A,P).set_color_by_gradient([BLUE,RED]))
        t_p = always_redraw(
            lambda: MathTex(r"(\mathbf{B}-\mathbf{A})" + r"{:.1f}".format(tra1.get_value()) + r"+\mathbf{A}",
                            color=BLACK).next_to(P, UR))
        self.add(P,AB,t_p)
        self.play(tra1.animate.set_value(1),vec.animate.shift(B-A),t_vec.animate.shift(B-A),run_time=4)
        self.wait(1)
        t_lab = MathTex(r"\overline{\mathbf{AB}}=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\left(\mathbf{B-A}\right)t+\mathbf{A},t\in\left(0,1\right)\right\} ",color=BLACK).to_corner(UL)
        t_ps = VGroup(Text(r"此处",color=BLACK),MathTex(r"\overline{\mathbf{AB}}",color=BLACK),Text(r"指以A、B为端点的有限直线",color=BLACK)).arrange(RIGHT).to_corner(DR)
        self.play(Write(t_lab),Write(t_ps))
        self.wait(1)
        self.play(FadeOut(t_ps))
        t1 = MathTex(r"\left(\mathbf{B-A}\right)0+\mathbf{A}=\mathbf{A}",color=BLACK).next_to(t_lab,DOWN,aligned_edge=LEFT)
        t2 = MathTex(r"\left(\mathbf{B-A}\right)1+\mathbf{A}=\mathbf{B}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t1,t2]))
        HighLight(self,VGroup(t1,t2))
        self.wait(1)
        te = MathTex(r"\left\{\begin{matrix}\mathbf{q}\cdot0+\mathbf{A}=\mathbf{A} \\\mathbf{q}\cdot1+\mathbf{A}=\mathbf{B} \end{matrix}\right.\Rightarrow\mathbf{q}=\mathbf{B}-\mathbf{A}"
                     ,color=BLACK).to_edge(LEFT)
        self.play(Write(te))
        self.wait(1)
        self.play(te.animate.set_color(GRAY))
        self.wait(1)

class s8(ThreeDScene):
    def construct(self):
        self.wait(1)

        axes = ThreeDAxes(axis_config={"color": BLACK})
        self.set_camera_orientation(phi=60*DEGREES,theta=-30*DEGREES)
        surface = Surface(lambda u,v:axes.c2p([u,v,0.1*(u*u+(v*v))])[0],
                        u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        self.play(Create(axes))
        self.play(Create(surface))
        self.wait(1)
        t0 = VGroup(Text(r"一个面",color=BLACK),MathTex(r"\mathbf{S}^2",color=RED)).arrange(RIGHT).to_corner(UL)
        t1 = MathTex(
            r"\mathbf{S}^2=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\begin{bmatrix}t_1 \\t_2\end{bmatrix}\right)+\mathbf{A},t_1\in\left(a,b\right),t_2\in\left(c,d\right)\right\}"
            , color=BLACK).next_to(t0,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t0)
        self.play(Write(t0))
        self.add_fixed_in_frame_mobjects(t1)
        self.play(Write(t1))
        self.wait(1)
        HighLight_3D(self,t1[0][10])
        t3 = MathTex(r"\mathbf{f}:\mathbb{R}^2\rightarrow\mathbf{V}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t3)
        self.play(Write(t3))
        self.wait(1)
        T1 = MathTex(r"\mathbf{f}\left(\mathbf{0}\right)=0",color=GRAY).to_corner(UR)
        self.add_fixed_in_frame_mobjects(T1)
        self.play(Write(T1))
        self.wait(1)

        self.play(FadeOut(surface))
        self.wait(1)

        TraU_Up = ValueTracker(0)
        TraU_Down = ValueTracker(0)
        TraV = ValueTracker(0)
        TraV_Down = ValueTracker(0)
        line = always_redraw(lambda: ParametricFunction(lambda t:axes.c2p(np.array([TraV.get_value(),t,0.1*(TraV.get_value()**2+(t**2))]))[0]
                                                        ,t_range=(TraU_Down.get_value(),TraU_Up.get_value()),color=DARK_BLUE))
        line2 = always_redraw(lambda: ParametricFunction(lambda t:axes.c2p(np.array([TraV_Down.get_value(),t,0.1*(TraV_Down.get_value()**2+(t**2))]))[0]
                                                        ,t_range=(TraU_Down.get_value(),TraU_Up.get_value()),color=DARK_BLUE))
        dots = always_redraw(lambda: VGroup(Dot3D(axes.c2p(np.array([TraV.get_value(),TraU_Up.get_value(),0.1*(TraV.get_value()**2+(TraU_Up.get_value()**2))]))[0],color=GREEN_E)
                                            ,Dot3D(axes.c2p(np.array([TraV.get_value(),TraU_Down.get_value(),0.1*(TraV.get_value()**2+(TraU_Down.get_value()**2))]))[0],color=GREEN)))
        dot_start_text = always_redraw(lambda:MathTex(r"\mathbf{f}\left(\begin{bmatrix}"+r"{:.1f}".format(TraU_Up.get_value())+r"\\{:.1f}".format(TraV.get_value())+r"\end{bmatrix}\right)"
                                                      ,color=GREEN_E).next_to(dots[0],OUT+UP))

        surface_movable = always_redraw(lambda: Surface(lambda u,v:axes.c2p([v,u,0.1*(u*u+(v*v))])[0],
                        u_range=[TraU_Up.get_value(), TraU_Down.get_value()], v_range=[TraV_Down.get_value(), TraV.get_value()],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4))
        self.add(line,dots)
        self.add_fixed_orientation_mobjects(dot_start_text)
        self.play(TraU_Up.animate.set_value(2))
        self.play(TraU_Down.animate.set_value(-2))
        self.wait(1)
        self.add(line2,surface_movable)
        self.play(TraV.animate.set_value(2))
        self.play(TraV_Down.animate.set_value(-2))
        self.wait(1)
        tit1 = mytitle("第一时域","The First Time Domain").to_edge(DOWN)
        HighLight_3D(self,t1[0][23:28])
        self.add_fixed_in_frame_mobjects(tit1)
        self.play(Write(tit1))
        self.play(FadeOut(tit1))
        self.wait(1)
        tit2 = mytitle("第二时域", "The Second Time Domain").to_edge(DOWN)
        HighLight_3D(self, t1[0][32:37])
        self.add_fixed_in_frame_mobjects(tit2)
        self.play(Write(tit2))
        self.play(FadeOut(tit2))
        self.wait(1)
        self.play(FadeOut(line,line2,dots,dot_start_text))
        TraX = ValueTracker(0)
        TraY = ValueTracker(0)
        Q_T = always_redraw(lambda:Vector(axes.c2p(np.array([TraY.get_value(),TraX.get_value(),0]))[0],color=BLUE_E).shift(3*DL))
        Q_P = always_redraw(lambda:Dot3D(axes.c2p([TraY.get_value(),TraX.get_value(),0.1*(TraX.get_value()**2+(TraY.get_value()**2))])[0],color=RED_E))
        V_P = always_redraw(lambda:Arrow3D([0,0,0],Q_P.get_center(),color=RED_E))
        T_P = always_redraw(lambda:MathTex(r"\mathbf{f}\left(\begin{bmatrix}t_1\\t_2\end{bmatrix}\right)",color=RED_E).next_to(Q_P,OUT+UP))
        T_T = always_redraw(lambda:MathTex(r"\begin{bmatrix}t_1\\t_2\end{bmatrix}",color=BLUE_E).next_to(Q_T,UR))
        self.add(Q_P,V_P)
        self.add_fixed_orientation_mobjects(T_P)
        self.add_fixed_in_frame_mobjects(Q_T,T_T)
        self.play(TraX.animate.set_value(1))
        self.play(TraY.animate.set_value(1))
        self.wait(1)
        g = [i for i in self.mobjects if not i in [Q_T,V_P,T_T,T_P] ].copy()
        gp = [i for i in self.mobjects if not i in [Q_T,V_P,T_T,T_P] ]
        self.remove(*[i for i in self.mobjects if not i in [Q_T,V_P,T_T,T_P] ])
        self.add(*g)
        self.play(FadeOut(*[i for i in self.mobjects if not i in [Q_T,V_P,T_T,T_P] ]))
        self.wait(1)

        # INSERT
        # INSERT
        # s8_insert
        # s8_insert
        # s8_insert
        # INSERT
        # INSERT

        self.play(FadeIn(*gp),FadeOut(T_P))
        self.wait(1)
        Q_DF1 = always_redraw(lambda:Arrow3D(Q_P.get_center(),axes.c2p(np.array([TraY.get_value(),TraX.get_value(),0.1*(TraX.get_value()**2+(TraY.get_value()**2))])
                                                                       +np.array([0,1,0.2*TraX.get_value()]))[0],color=RED_E))
        Q_DF2 = always_redraw(lambda:Arrow3D(Q_P.get_center(),axes.c2p(np.array([TraY.get_value(),TraX.get_value(),0.1*(TraX.get_value()**2+(TraY.get_value()**2))])
                                                                       +np.array([1,0,0.2*TraY.get_value()]))[0],color=BLUE_E))
        T_DF1 = always_redraw(lambda:MathTex(r"\frac{\partial\mathbf{f}}{\partial t_1}",color=RED_E).next_to(Q_DF1,OUT+UP))
        T_DF2 = always_redraw(
            lambda: MathTex(r"\frac{\partial\mathbf{f}}{\partial t_1}", color=BLUE_E).next_to(Q_DF2, IN + DOWN))
        self.add(Q_DF1,Q_DF2)
        self.add_fixed_orientation_mobjects(T_DF1,T_DF2)
        self.play(TraX.animate.set_value(-1))
        self.play(TraY.animate.set_value(-1))
        self.wait(1)


class s8_insert(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\frac{d\mathbf{f}\left(\begin{bmatrix}t_1\\t_2\end{bmatrix}\right)}{d\begin{bmatrix}t_1\\t_2\end{bmatrix}}=",color=BLACK).to_corner(UL)
        t1[0][1:10].set_color(RED_E)
        t1[0][12:len(t1[0])-1].set_color(BLUE_E)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(
            r"\begin{bmatrix} \frac{\partial f_1}{\partial t_1} & \frac{\partial f_1}{\partial t_2} \\  \frac{\partial f_2}{\partial t_1} &\frac{\partial f_2}{\partial t_2} \\   \frac{\partial f_3}{\partial t_1} & \frac{\partial f_3}{\partial t_2}\end {bmatrix}",
            color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        for i in range(6):
            t2[0][i * 7 + 4:i * 7 + 6].set_color(RED_E)
            t2[0][i * 7 + 8:i * 7 + 10].set_color(BLUE_E)
        self.play(Write(t2))
        self.wait(1)
        T1 = MathTex(r"\frac{d\mathbf{f}}{d\mathbf{t}}d\mathbf{t}=d\mathbf{f}",color=BLACK).to_corner(UR)
        T1[0][0:2].set_color(RED)
        T1[0][3:7].set_color(BLUE)
        T1[0][8:].set_color(RED)
        self.play(Write(T1))
        t3 = MathTex(
            r"\begin{bmatrix} \frac{\partial f_1}{\partial t_1} & \frac{\partial f_1}{\partial t_2} \\  \frac{\partial f_2}{\partial t_1} &\frac{\partial f_2}{\partial t_2} \\   \frac{\partial f_3}{\partial t_1} & \frac{\partial f_3}{\partial t_2}\end {bmatrix}\begin{bmatrix}dt_1\\dt_2\end {bmatrix}=dt_1\begin{bmatrix}\frac{\partial f_1}{\partial t_1}\\\frac{\partial f_2}{\partial t_1}\\\frac{\partial f_3}{\partial t_1}\end {bmatrix}+dt_2\begin{bmatrix}\frac{\partial f_1}{\partial t_2}\\\frac{\partial f_2}{\partial t_2}\\\frac{\partial f_3}{\partial t_2}\end{bmatrix}=\begin{bmatrix}df_1 \\df_2 \\df_3\end{bmatrix}",
            color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        for i in range(6):
            t3[0][i * 7 + 4:i * 7 + 6].set_color(RED_E)
            t3[0][i * 7 + 8:i * 7 + 10].set_color(BLUE_E)
        t3[0][48:56].set_color(BLUE)
        t3[0][57:60].set_color(BLUE_E)
        t3[0][60:87].set_color(RED_E)
        t3[0][88:91].set_color(BLUE_E)
        t3[0][91:118].set_color(RED_E)
        t3[0][119:].set_color(RED)
        self.play(Write(t3))
        self.wait(1)

class s8_1(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)
        self.wait(1)
        axes = ThreeDAxes(axis_config={"color":BLACK})
        base_vector_x = np.array([1,0,-0.5])
        base_vector_y = np.array([0,1,0])
        X = ValueTracker(0)
        Y = ValueTracker(0)
        x = ValueTracker(0)
        y = ValueTracker(0)
        point = always_redraw(lambda:Dot3D(axes.c2p(np.array(X.get_value()*base_vector_x+Y.get_value()*base_vector_y))[0],color=BLACK))
        line = always_redraw(lambda:ParametricFunction(lambda t:axes.c2p(np.array(t*base_vector_x+Y.get_value()*base_vector_y))[0]
                                                        ,t_range=(x.get_value(),X.get_value()),color=RED_E))
        plane = always_redraw(lambda:Surface(lambda x,y:axes.c2p(x*base_vector_x+y*base_vector_y)[0],u_range=[x.get_value(),X.get_value()],v_range=[y.get_value(),Y.get_value()]
                                             ,checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4))
        Q_bvx = always_redraw(lambda:Arrow3D(point.get_center(),point.get_center()+axes.c2p(base_vector_x)[0],color=BLUE_E))
        Q_bvy = always_redraw(
            lambda: Arrow3D(point.get_center(), point.get_center() + axes.c2p(base_vector_y)[0], color=GREEN_E))
        T_x = always_redraw(lambda:MathTex(r"\mathbf{q}",color=BLUE_E).next_to(Q_bvx,DOWN+OUT))
        T_y = always_redraw(lambda: MathTex(r"\mathbf{g}", color=GREEN_E).next_to(Q_bvy,UP+OUT))
        text = VGroup(Text(r"一个平面",color=BLACK),MathTex(r"\mathbf{L}^2",color=RED)).arrange(RIGHT).to_corner(UL)
        t_0_1 = MathTex(r"\mathbf{L}^2=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\begin{bmatrix}t_1\\t_2\end{bmatrix}\right)+\mathbf{A},t_1\in\left(a,b\right),t_2\in\left(c,d\right)\right\}"
                        ,color=BLACK).next_to(text,DOWN,aligned_edge=LEFT)
        t_p_1 = MathTex(r"\mathbf{f}\left(\mathbf{0}\right)=\mathbf{0}",color=GRAY).to_corner(UR)
        t1 = MathTex(r"\frac{\partial \mathbf{f}}{\partial t_1}=\mathbf{q}",color=BLACK).next_to(t_0_1,DOWN,aligned_edge=LEFT)
        t2 = MathTex(r"\frac{\partial \mathbf{f}}{\partial t_2}=\mathbf{g}",color=BLACK).next_to(t1, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(text,t1,t2,t_p_1,t_0_1)
        self.play(Create(axes),Write(t1),Write(t2),Write(text),Write(t_0_1))
        self.add(plane,line,Q_bvx,Q_bvy,point)
        self.add_fixed_orientation_mobjects(T_x,T_y)
        self.play(X.animate.set_value(2))
        self.play(Y.animate.set_value(2))
        self.wait(1)
        t3 = MathTex(r"\mathbf{f}\left(\begin{bmatrix}t_1\\t_2\end{bmatrix}\right)=t_1\mathbf{q}+t_2\mathbf{g}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t3)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\mathbf{L}^2=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\begin{bmatrix}\mathbf{q} & \mathbf{g}\end{bmatrix}\begin{bmatrix}t_1\\t_2\end{bmatrix}+\mathbf{A},t_1\in\left(a,b\right),t_2\in\left(c,d\right)\right\}"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t4)
        self.play(Write(t4))
        HighLight_3D(self,t4[0][10:22])
        self.wait(1)

class s8_1_append(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)
        self.wait(1)

        t0 = VGroup(Text(r"一个面", color=BLACK), MathTex(r"\mathbf{S}^2", color=RED)).arrange(RIGHT).to_corner(UL)
        t1 = MathTex(
            r"\mathbf{S}^2=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\begin{bmatrix}t_1 \\t_2\end{bmatrix}\right)+\mathbf{A},t_1\in\left(a,b\right),t_2\in\left(c,d\right)\right\}"
            , color=BLACK).next_to(t0, DOWN, aligned_edge=LEFT)

        self.add_fixed_in_frame_mobjects(t0)
        self.play(Write(t0))
        self.add_fixed_in_frame_mobjects(t1)
        self.play(Write(t1))

        axes = ThreeDAxes(axis_config={"color":BLACK})

        UP_1 = ValueTracker(0)
        DOWN_1 = ValueTracker(0)
        UP_2 = ValueTracker(0)
        DOWN_2 = ValueTracker(0)
        UP_3 = ValueTracker(0)
        DOWN_3 = ValueTracker(0)
        UP_4 = ValueTracker(0)
        DOWN_4 = ValueTracker(0)

        rotate = False
        rotation = ValueTracker(0)
        X = ValueTracker(0)
        Y = ValueTracker(0)
        X.add_updater(lambda m:m.set_value(cos(rotation.get_value()))if rotate else m)
        Y.add_updater(lambda m: m.set_value(sin(rotation.get_value())) if rotate else m)

        Q_T = always_redraw(lambda:Vector(axes.c2p([X.get_value(),Y.get_value(),0])[0],color=BLUE_E).shift(2*DR+2*RIGHT))
        RANGE_T = Square(side_length=axes.get_x_unit_size()*4,color=DARK_BLUE).shift(2*DR+2*RIGHT)

        surface = Surface(lambda u,v:axes.c2p([u,v,0.1*(u*u+(v*v))])[0],
                        u_range=[-2,2], v_range=[-2,2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        point = always_redraw(lambda:Dot3D(axes.c2p([X.get_value(),Y.get_value(),0.1*(X.get_value()**2+(Y.get_value()**2))])[0],color=BLACK))

        nex = True

        edge_1st_down = always_redraw(
            lambda: ParametricFunction(lambda t: axes.c2p(np.array([-2, t, 0.1 * (2 ** 2 + (t ** 2))]))[0]
                                       , t_range=(DOWN_1.get_value(), UP_1.get_value()), color=GREEN if nex else BLACK))
        edge_1st_up = always_redraw(
            lambda: ParametricFunction(lambda t: axes.c2p(np.array([2, t, 0.1 * (2 ** 2 + (t ** 2))]))[0]
                                       , t_range=(DOWN_2.get_value(), UP_2.get_value()), color=BLUE if nex else BLACK))
        edge_2st_down = always_redraw(
            lambda: ParametricFunction(lambda t: axes.c2p(np.array([t, -2, 0.1 * (2 ** 2 + (t ** 2))]))[0]
                                       , t_range=(DOWN_3.get_value(), UP_3.get_value()), color=GREEN_E if nex else BLACK))
        edge_2st_up = always_redraw(
            lambda: ParametricFunction(lambda t: axes.c2p(np.array([t, 2, 0.1 * (2 ** 2 + (t ** 2))]))[0]
                                       , t_range=(DOWN_4.get_value(), UP_4.get_value()), color=BLUE_E if nex else BLACK))

        self.play(Create(axes))
        self.play(Create(surface))
        self.add(point)
        self.add_fixed_in_frame_mobjects(Q_T,RANGE_T)
        rotate = True
        self.play(rotation.animate.set_value(2*PI),X.animate.get_value(),Y.animate.get_value())
        self.wait(1)
        rotate = False
        self.play(X.animate.set_value(2))
        self.add(edge_1st_up)
        self.play(UP_2.animate.set_value(2),Y.animate.set_value(2))
        self.play(DOWN_2.animate.set_value(-2),Y.animate.set_value(-2))
        self.wait(1)
        self.play(FadeOut(edge_1st_up))

        HighLight_3D(self,t1[0][26],additional_animation=[t1[0][26].animate.set_color(GREEN)])
        titu1 = mytitle("第一下终时","The First Down End Time").to_edge(DOWN).set_color(GREEN)
        self.add_fixed_in_frame_mobjects(titu1)
        self.play(Write(titu1))
        self.wait(1)
        self.play(FadeOut(titu1))
        self.wait(1)

        HighLight_3D(self, t1[0][28], additional_animation=[t1[0][28].animate.set_color(BLUE)])
        titu2 = mytitle("第一上终时", "The First Up End Time").to_edge(DOWN).set_color(BLUE)
        self.add_fixed_in_frame_mobjects(titu2)
        self.play(Write(titu2))
        self.wait(1)
        self.play(FadeOut(titu2))
        self.wait(1)

        HighLight_3D(self, t1[0][35], additional_animation=[t1[0][35].animate.set_color(GREEN_E)])
        titu3 = mytitle("第二下终时", "The Second Down End Time").to_edge(DOWN).set_color(GREEN_E)
        self.add_fixed_in_frame_mobjects(titu3)
        self.play(Write(titu3))
        self.wait(1)
        self.play(FadeOut(titu3))
        self.wait(1)

        HighLight_3D(self, t1[0][37], additional_animation=[t1[0][37].animate.set_color(DARK_BLUE)])
        titu4 = mytitle("第二上终时", "The Second Up End Time").to_edge(DOWN).set_color(DARK_BLUE)
        self.add_fixed_in_frame_mobjects(titu4)
        self.play(Write(titu4))
        self.wait(1)
        self.play(FadeOut(titu4))
        self.wait(1)

        UP_2.set_value(0)
        DOWN_2.set_value(0)
        textd1 = always_redraw(lambda:MathTex(r"\mathbf{f}\left(\begin{bmatrix}a\\"+r"{:.1f}".format(Y.get_value())+r"\end{bmatrix}\right)",color=GREEN).next_to(point,OUT))
        self.play(X.animate.set_value(-2))
        self.play(Y.animate.set_value(0))
        self.add(edge_1st_down)
        self.add_fixed_orientation_mobjects(textd1)
        self.play(UP_1.animate.set_value(2),Y.animate.set_value(2))
        self.play(DOWN_1.animate.set_value(-2),Y.animate.set_value(-2))
        tited1 = mytitle("第一下终线","The First Down End Line").to_edge(DOWN).set_color(GREEN)
        self.add_fixed_in_frame_mobjects(tited1)
        self.play(Write(tited1))
        self.wait(1)
        self.play(FadeOut(tited1,textd1))

        UP_2.set_value(0)
        DOWN_2.set_value(0)
        textu1 = always_redraw(lambda: MathTex(
            r"\mathbf{f}\left(\begin{bmatrix}b\\" + r"{:.1f}".format(Y.get_value()) + r"\end{bmatrix}\right)",
            color=BLUE).next_to(point, OUT))
        self.play(X.animate.set_value(2))
        self.play(Y.animate.set_value(0))
        self.add(edge_1st_up)
        self.add_fixed_orientation_mobjects(textu1)
        self.play(UP_2.animate.set_value(2), Y.animate.set_value(2))
        self.play(DOWN_2.animate.set_value(-2), Y.animate.set_value(-2))
        titeu1 = mytitle("第一上终线", "The First Up End Line").to_edge(DOWN).set_color(BLUE)
        self.add_fixed_in_frame_mobjects(titeu1)
        self.play(Write(titeu1))
        self.wait(1)
        self.play(FadeOut(titeu1, textu1))

        UP_3.set_value(0)
        DOWN_3.set_value(0)
        textd2 = always_redraw(lambda: MathTex(
            r"\mathbf{f}\left(\begin{bmatrix}" + r"{:.1f}".format(X.get_value())+r"\\c" + r"\end{bmatrix}\right)",
            color=GREEN_E).next_to(point, OUT))
        self.play(X.animate.set_value(0))
        self.play(Y.animate.set_value(-2))
        self.add(edge_2st_down)
        self.add_fixed_orientation_mobjects(textd2)
        self.play(UP_3.animate.set_value(2), X.animate.set_value(2))
        self.play(DOWN_3.animate.set_value(-2), X.animate.set_value(-2))
        tited2 = mytitle("第二下终线", "The Second Down End Line").to_edge(DOWN).set_color(GREEN_E)
        self.add_fixed_in_frame_mobjects(tited2)
        self.play(Write(tited2))
        self.wait(1)
        self.play(FadeOut(tited2, textd2))

        UP_4.set_value(0)
        DOWN_4.set_value(0)
        textu2 = always_redraw(lambda: MathTex(
            r"\mathbf{f}\left(\begin{bmatrix}" + r"{:.1f}".format(X.get_value())+r"\\d" + r"\end{bmatrix}\right)",
            color=BLUE_E).next_to(point, OUT))
        self.play(X.animate.set_value(0))
        self.play(Y.animate.set_value(2))
        self.add(edge_2st_up)
        self.add_fixed_orientation_mobjects(textu2)
        self.play(UP_4.animate.set_value(2), X.animate.set_value(2))
        self.play(DOWN_4.animate.set_value(-2), X.animate.set_value(-2))
        titeu2 = mytitle("第二上终线", "The Second Up End Line").to_edge(DOWN).set_color(BLUE_E)
        self.add_fixed_in_frame_mobjects(titeu2)
        self.play(Write(titeu2))
        self.wait(1)
        self.play(FadeOut(titeu2, textu2))
        self.wait(1)
        self.play(edge_1st_down.animate.set_color(BLACK),edge_1st_up.animate.set_color(BLACK)
                  ,edge_2st_down.animate.set_color(BLACK),edge_2st_up.animate.set_color(BLACK))
        titedge = mytitle("边界","Extremity").to_edge(DOWN).to_edge(DOWN)
        self.add_fixed_in_frame_mobjects(titedge)
        nex = False
        self.play(Write(titedge))
        self.wait(1)

class s8_2(Scene):
    def construct(self):
        self.wait(1)
        t1 = VGroup(Text(r"一个n维形",color=BLACK),MathTex(r"\mathbf{S}^n",color=RED)).arrange(RIGHT).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\mathbf{S}^n=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{A},t_1\in\mathbf{T}_1,t_2\in\mathbf{T}_2,\cdots,t_n\in\mathbf{T}_n\right\}"
                     ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)

        t3 = MathTex(r"\mathbf{T}_i=\left[a,b\right]",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        HighLight(self,t2[0][29:32])
        tit1 = mytitle("第i时域","The i-th Time Domain").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        HighLight(self,t3[0][4])
        tit2 = mytitle("第i下终时","The i-th Down End Time").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(tit2))
        HighLight(self, t3[0][6])
        tit3 = mytitle("第i上终时", "The i-th Up End Time").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)
        self.play(FadeOut(tit3))
        self.wait(1)

class s8_2_append(Scene):
    def construct(self):
        self.wait(1)
        t1 = VGroup(Text(r"一个n维平直形",color=BLACK),MathTex(r"\mathbf{L}^n",color=RED)).arrange(RIGHT).to_corner(UL)
        self.play(Write(t1))
        t2 = MathTex(
            r"\mathbf{L}^n=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{A},t_1\in\mathbf{T}_1,t_2\in\mathbf{T}_2,\cdots,t_n\in\mathbf{T}_n\right\}"
            , color=BLACK).next_to(t1, DOWN, aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\frac{\partial \mathbf{f}}{\partial t_i}=\mathbf{q}_i",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\Rightarrow \mathbf{f}\left(\mathbf{t}\right) = \sum t_i\mathbf{q}_i = \begin{bmatrix}\mathbf{q}_1 & \mathbf{q}_2 &\cdots & \mathbf{q}_n\end{bmatrix}\mathbf{t}=\mathbf{W}\mathbf{t}"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        HighLight(self,t4[0][len(t4[0])-2],additional_animation=[t4[0][len(t4[0])-2].animate.set_color(RED)])
        tit1 = mytitle("基矩阵","Base Matrix").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1),t4[0][len(t4[0])-2].animate.set_color(BLACK))
        self.wait(1)

class s8_3(Scene):
    def construct(self):
        self.wait(1)
        ARRAY_W = np.array([[2, 1], [1, 1.5]])
        numberplane = NumberPlane(axis_config={"color":BLACK})
        nmpw = NumberPlane(axis_config={"color": GRAY}, background_line_style={"stroke_color": YELLOW_D},
                    x_axis_config={"unit_size": sqrt(ARRAY_W[0][0] ** 2 + ARRAY_W[0][1] ** 2),
                                   "rotation": atan(ARRAY_W[0][1] / ARRAY_W[0][0])},
                    y_axis_config={"unit_size": sqrt(ARRAY_W[1][0] ** 2 + ARRAY_W[1][1] ** 2),
                                   "rotation": atan(ARRAY_W[1][1] / ARRAY_W[1][0])})
        Q_T = Vector(np.array([1,1,0]),color=RED)
        Q_T_ = Vector(np.array([3,2.5,0]),color=BLUE)##中子星NeutronStar233制作

        T_T = MathTex(r"\mathbf{v}",color=RED).to_corner(UL)
        T_T2 = MathTex(r"\mathbf{v}'=\mathbf{W}\mathbf{v}",color=BLUE).next_to(T_T,DOWN,aligned_edge=LEFT)

        self.play(Create(numberplane))
        self.play(GrowArrow(Q_T),Write(T_T))
        self.wait(1)
        self.play(Transform(numberplane.copy(),nmpw),Transform(Q_T.copy(),Q_T_),Write(T_T2))
        self.wait(1)

class  s8_3_append(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)
        self.wait(1)
        axes = ThreeDAxes(axis_config={"color":BLACK})
        base_vector_x = np.array([1, 0, -0.5])
        base_vector_y = np.array([0, 1, 0])
        plane = Surface(lambda x,y:axes.c2p(x*base_vector_x+y*base_vector_y)[0],u_range=[-2,2],v_range=[-2,2]
                                             ,checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)

        X = ValueTracker(0)
        Y = ValueTracker(0)
        Rotation = ValueTracker(0)
        X.add_updater(lambda m:m.set_value(cos(Rotation.get_value())))
        Y.add_updater(lambda m: m.set_value(sin(Rotation.get_value())))

        Q_T = always_redraw(
            lambda: Vector(axes.c2p([X.get_value(), Y.get_value(), 0])[0], color=BLUE_E).shift(2 * DR + 2 * RIGHT))
        RANGE_T = Square(side_length=axes.get_x_unit_size() * 4, color=DARK_BLUE).shift(2 * DR + 2 * RIGHT)
        point = always_redraw(lambda:Dot3D(axes.c2p(X.get_value()*base_vector_x+Y.get_value()*base_vector_y)[0],color=BLACK))
        vec_point = always_redraw(
            lambda: Arrow3D(np.array([0,0,0]),axes.c2p(X.get_value() * base_vector_x + Y.get_value() * base_vector_y)[0], color=BLACK))

        self.play(Create(axes))
        self.add_fixed_in_frame_mobjects(RANGE_T,Q_T)
        self.play(Create(plane),FadeIn(Q_T,RANGE_T,point,vec_point))
        self.wait(1)
        self.play(Rotation.animate.set_value(2*PI),X.animate.get_value(),Y.animate.get_value(),run_time = 5)
        self.wait(1)

class s9(Scene):
    def construct(self):
        self.wait(1)
        t1 = VGroup(Text(r"一个n维形", color=BLACK), MathTex(r"\mathbf{S}^n", color=RED)).arrange(RIGHT).to_corner(
            UL)
        self.play(Write(t1))
        t2 = MathTex(r"\mathbf{S}^n=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{A},t_1\in\mathbf{T}_1,\cdots,t_n\in\mathbf{T}_n\right\}"
                     ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\mathbf{S}^n:\left\{\mathbf{t}\in\mathbb{R}^n\mid t_1\in\mathbf{T}_1,\cdots,t_n\in\mathbf{T}_n\right\}\leftrightarrow\mathbf{S}^n"
                     ,color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t3[0][0:2].set_color(RED)
        self.play(Write(t3))
        HighLight(self,t3[0][0:2])
        self.wait(1)
        t4 = MathTex(r"\mathbf{S}^n\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{A},t_1\in\mathbf{T}_1,\cdots,t_n\in\mathbf{T}_n"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        HighLight(self,t4,additional_animation=[t4[0][0:2].animate.set_color(RED)])
        self.wait(1)
        self.play(FadeOut(t4[0][12:]))
        self.wait(1)

class s9_1(Scene):
    def construct(self):
        self.wait(1)
        nbp = NumberPlane(axis_config={"color":BLACK})
        shape = Square(color=RED,fill_opacity=0.2).shift(1.5*UR).rotate(30*DEGREES)
        shape_centre = Dot(shape.get_center(),color=BLACK)
        v_shape_centre = Vector(shape_centre.get_center(),color=BLACK)
        t_shape = MathTex(r"\mathbf{A}\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}",color=RED).to_corner(UL)
        t_shape[0][len(t_shape[0])-1].set_color(BLACK)
        point = Dot([-2,-1,0],color=GREEN_E)
        t_point = MathTex(r"\mathbf{p}",color=GREEN_E).next_to(t_shape,DOWN,aligned_edge=LEFT)
        v_point = Vector(point.get_center(),color=GREEN_E)
        self.play(Create(nbp))
        self.play(Create(shape),Write(t_shape),Write(t_point),Create(point),Create(shape_centre),GrowArrow(v_shape_centre),GrowArrow(v_point))
        self.wait(1)
        v_point_A = Arrow(shape_centre.get_center(),point.get_center(),color=YELLOW_E,buff=0)
        ralative_position = MathTex(r"\mathbf{p}-\mathbf{O}",color=YELLOW_E).next_to(t_point,DOWN,aligned_edge=LEFT)
        self.play(GrowArrow(v_point_A),Write(ralative_position))
        HighLight(self,ralative_position)
        tit = mytitle("相对位置","Relative Position").to_edge(DOWN)
        HighLight(self,v_point_A)
        self.play(Write(tit))
        self.wait(1)

class s9_2(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)
        self.wait(1)

        axes = ThreeDAxes(axis_config={"color":BLACK})

        q = np.array([1, 0, -0.5])
        g = np.array([0, 1, 0])
        O = np.array([0,0,1])

        def f(x,y):
            return axes.c2p(x*q+y*g+O)[0]

        plane = Surface(f,
                        u_range=[-2,2], v_range=[-2,2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        line = ParametricFunction(lambda t:f(0.5*t+1,t),t_range=[-2,2],color=BLACK)
        Q_O = Dot3D(O,color=BLACK)
        Q_Q = Arrow3D(O,O+q,color=BLUE_E)
        Q_G = Arrow3D(O,O+g,color=GREEN_E)

        t = ValueTracker(1)

        Q_P = always_redraw(lambda:Dot3D(f(0.5*t.get_value()+1,t.get_value()),color=BLACK))
        Q_P_X = always_redraw(lambda:DashedLine(f(0,t.get_value()),Q_P.get_center(),color=BLUE_E))
        Q_P_Y = always_redraw(lambda: DashedLine(f(0.5*t.get_value()+1, 0), Q_P.get_center(), color=GREEN_E))

        t1 = VGroup(Text(r"某个维度的平直形", color=BLACK), MathTex(r"\mathbf{L}", color=RED)).arrange(RIGHT).to_corner(
            UL)
        t2 = MathTex(r"\mathbf{L}\left(\mathbf{t}\right)=\mathbf{W}\mathbf{t}+\mathbf{O}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t3 = VGroup(Text(r"在这个平直形上的某个维度的形", color=BLACK), MathTex(r"\mathbf{A}", color=RED)).arrange(RIGHT).to_corner(
            UL).next_to(t2,DOWN,aligned_edge=LEFT)
        t4 = MathTex(r"\mathbf{A}\subseteq\mathbf{L}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = MathTex(r"\Leftrightarrow \forall\mathbf{p}\in\mathbf{A},\exists\mathbf{t},\mathbf{p}-\mathbf{O}=\mathbf{W}\mathbf{t}",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)

        Q_T = always_redraw(lambda:Vector([0.5*t.get_value()+1,t.get_value(),0],color=RED_C).shift(2 * DR + 2 * RIGHT))
        RANGE_T = Square(side_length=4, color=RED_E).shift(2 * DR + 2 * RIGHT)
        Q_Q_INTRISIC = Vector([1,0,0],color=BLUE_E).shift(2 * DR + 2 * RIGHT)
        Q_G_INTRISIC = Vector([0, 1, 0], color=GREEN_E).shift(2 * DR + 2 * RIGHT)
        Q_P_X_INTRISIC = always_redraw(lambda:Line(np.array([0.5 * t.get_value() + 1,0,0]),np.array([0.5*t.get_value()+1,t.get_value(),0]),color=BLUE_E).shift(2 * DR + 2 * RIGHT))
        Q_P_Y_INTRISIC = always_redraw(
            lambda: Line(np.array([0,t.get_value(),0]), np.array([0.5 * t.get_value() + 1, t.get_value(), 0]),
                               color=GREEN_E).shift(2 * DR + 2 * RIGHT))

        Q_V_P = always_redraw(lambda:Arrow3D([0,0,0],Q_P.get_center(),color=YELLOW_E))

        self.add_fixed_in_frame_mobjects(t1,t2,t3,t4,t5)
        self.play(*[Write(i)for i in [t1,t2,t3,t4,t5]])
        HighLight_3D(self,t5[0][len(t5[0])-1])
        tit = mytitle("内蕴位置","Intrinsic Position").to_edge(DOWN)
        self.add_fixed_in_frame_mobjects(tit)
        self.play(Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))
        self.play(Create(axes))
        self.add_fixed_in_frame_mobjects(Q_T,RANGE_T,Q_Q_INTRISIC,Q_G_INTRISIC,Q_P_X_INTRISIC,Q_P_Y_INTRISIC)
        self.play(Create(Q_V_P),Create(plane),Create(Q_O),Create(Q_Q),Create(Q_G),Write(line),Create(Q_P),Write(Q_P_X),Write(Q_P_Y),FadeIn(Q_T,RANGE_T,Q_Q_INTRISIC,Q_G_INTRISIC,Q_P_X_INTRISIC,Q_P_Y_INTRISIC))
        self.wait(1)
        self.play(t.animate.set_value(2),run_time=2)
        self.play(t.animate.set_value(-2),run_time=2)
        self.play(t.animate.set_value(1),run_time=2)
        self.wait(1)

class s9_3(Scene):
    def construct(self):
        self.wait(1)
        t1 = VGroup(Text(r"一个形", color=BLACK), MathTex(r"\mathbf{S}", color=RED)).arrange(RIGHT).to_corner(
            UL)
        t2 = MathTex(r"\mathbf{S}\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t3 = VGroup( MathTex(r"\mathbf{a}", color=RED),Text(r"对于", color=BLACK)
                     , MathTex(r"\mathbf{O}", color=BLACK), Text(r"的相对位置", color=BLACK)
                     , MathTex(r"\mathbf{a}'", color=BLACK)).arrange(RIGHT).next_to(t2,DOWN,aligned_edge=LEFT)
        t4 = MathTex(r"\mathbf{a}'=\mathbf{a}-\mathbf{O}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = VGroup(MathTex(r"\mathbf{b}", color=RED), Text(r"对于", color=BLACK)
                    , MathTex(r"\mathbf{O}", color=BLACK), Text(r"的相对位置", color=BLACK)
                    , MathTex(r"\mathbf{b}'", color=BLACK)).arrange(RIGHT).next_to(t4, DOWN, aligned_edge=LEFT)
        t6 = MathTex(r"\mathbf{b}'=\mathbf{b}-\mathbf{O}", color=BLACK).next_to(t5, DOWN, aligned_edge=LEFT)
        self.play(FadeIn(*[t1,t2,t3,t4,t5,t6]))
        self.wait(1)
        t7 = MathTex(r"\left(\mathbf{a}',\mathbf{b}'\right)",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        HighLight(self,t7)
        tit = mytitle("相对内积","Relative Scalar Product").to_edge(DOWN)
        self.play(Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))
        self.wait(1)
        ct2 = MathTex(r"\mathbf{S}\left(\mathbf{t}\right)=\mathbf{W}\mathbf{t}+\mathbf{O}",color=BLACK).to_corner(UL)
        ct4 = t4.copy().next_to(ct2,DOWN,aligned_edge=LEFT)
        ct6 = t6.copy().next_to(ct4, DOWN, aligned_edge=LEFT)
        self.play(FadeOut(t1,t3,t5),Transform(t2,ct2),Transform(t4,ct4),Transform(t6,ct6),t7.animate.next_to(ct6,DOWN,aligned_edge=LEFT))
        self.wait(1)
        t8 = VGroup( MathTex(r"\mathbf{a}", color=RED),Text(r"在", color=BLACK)
                     , MathTex(r"\mathbf{S}", color=BLACK), Text(r"中的相对位置", color=BLACK)
                     , MathTex(r"\mathbf{a}''", color=BLACK)).arrange(RIGHT).next_to(t7,DOWN,aligned_edge=LEFT)
        t9 = MathTex(r"\mathbf{a}''=\mathbf{W}^{-1}\mathbf{a}'",color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        t10 = VGroup(MathTex(r"\mathbf{b}", color=RED), Text(r"在", color=BLACK)
                    , MathTex(r"\mathbf{S}", color=BLACK), Text(r"中的相对位置", color=BLACK)
                    , MathTex(r"\mathbf{b}''", color=BLACK)).arrange(RIGHT).next_to(t9, DOWN, aligned_edge=LEFT)
        t11 = MathTex(r"\mathbf{b}''=\mathbf{W}^{-1}\mathbf{b}'", color=BLACK).next_to(t10,DOWN,aligned_edge=LEFT)
        self.play(FadeIn(*[t8,t9,t10,t11]))
        self.wait(1)
        t12 = MathTex(r"\left(\mathbf{a}'',\mathbf{b''}\right)",color=BLACK).next_to(t11,DOWN,aligned_edge=LEFT)
        self.play(Write(t12))
        HighLight(self,t12)
        tit2 = mytitle("内蕴内积","Intrinsic Scalar Product").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        T_ISP = MathTex(r"\left(\mathbf{a}'',\mathbf{b}''\right)=\left(\mathbf{W}^{-1}\mathbf{a}',\mathbf{W}^{-1}\mathbf{b}'\right)",color=BLACK).to_corner(UL)
        nbp = NumberPlane(axis_config={"color":BLACK})
        S = Square(color=RED,fill_opacity=0.2).shift(1.5*UR).rotate(30*DEGREES)
        O = S.get_center()
        T = ValueTracker(2*PI/12)
        def Q(t):
            return np.array([cos(t),sin(t),0])
        def G(t):
            return np.array([sin(t),cos(t),0])
        Q_Q = always_redraw(lambda :Arrow(O,O+Q(T.get_value()),buff=0,color=BLACK))
        Q_G = always_redraw(lambda: Arrow(O, O + G(T.get_value()), buff=0, color=GRAY))

        S_nbp = always_redraw(lambda:NumberPlane(background_line_style={"stroke_color":GRAY},x_axis_config={"color":BLACK,"rotation":T.get_value()}
                                                 ,y_axis_config={"color":GRAY,"rotation":PI/2-T.get_value()}).move_to(O))
        self.play(Create(nbp))
        self.play(Create(S),GrowArrow(Q_Q),GrowArrow(Q_G),FadeIn(S_nbp))
        self.play(Write(T_ISP),nbp.animate.move_to(O))
        self.wait(1)
        self.play(T.animate.set_value(-2*PI/12))
        self.play(T.animate.set_value(2*PI/12))
        self.wait(1)
        self.play(T.animate.set_value(0))
        T_ = VGroup(Text(r"当",color=BLACK),MathTex(r"\mathbf{W}",color=RED),Text("正交时",color=BLACK)).arrange(RIGHT).next_to(T_ISP,DOWN,aligned_edge=LEFT)
        T__ = MathTex(r"\left(\mathbf{a}'',\mathbf{b}''\right)=\left(\mathbf{a}',\mathbf{b}'\right)",color=BLACK).next_to(T_,DOWN,aligned_edge=LEFT)
        self.play(Write(T_),Write(T__))
        self.wait(1)

class s10(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{S}\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}",color=BLACK).to_corner(UL)
        t1[0][0].set_color(RED)
        nbp = NumberPlane(axis_config={"color":BLACK})
        S = Polygon([0,0,0],[1,0,0],[2,1,0],color=RED,fill_color=RED,fill_opacity=0.2)
        Q_O = Dot(S.get_center(),color=BLACK)
        self.play(Write(t1),Create(nbp),Create(S),Create(Q_O))
        self.wait(1)
        self.play(nbp.animate.move_to(S.get_center()))
        self.play(FadeOut(nbp))

        t2 = MathTex(r"\mathbf{S}_1\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}_1",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t2[0][0:2].set_color(BLUE_E)
        S1 = S.copy().shift(2*UP).set_color(BLUE_E)
        Q_O1 = Dot(S1.get_center(),color=BLACK)
        nbp1 = NumberPlane(axis_config={"color": BLACK}, background_line_style={"stroke_color": GRAY}).move_to(S1.get_center())
        self.play(Write(t2),ReplacementTransform(S.copy(),S1),ReplacementTransform(Q_O.copy(),Q_O1),ReplacementTransform(nbp.copy(),nbp1))
        self.wait(1)
        self.play(FadeOut(nbp1),FadeIn(nbp))
        nbp2 = NumberPlane(axis_config={"color":BLACK},background_line_style={"stroke_color": GRAY}).rotate(30*DEGREES).move_to(S.get_center())
        t3 = MathTex(r"\mathbf{S}_2\left(\mathbf{t}\right)=\mathbf{W}\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}",
                     color=BLACK).next_to(t2, DOWN, aligned_edge=LEFT)
        t3[0][0:2].set_color(GREEN_E)
        S2 = S.copy().rotate(30*DEGREES).set_color(GREEN_E)
        self.play(Write(t3),ReplacementTransform(S.copy(),S2),ReplacementTransform(nbp.copy(),nbp2))
        self.wait(1)

def Congruent_Translation(scene:Scene,m:Mobject,begin:float,rotation:float,translation:np.ndarray,start_color:ManimColor,color:ManimColor):
    C_m = Dot(m.get_center(),color=BLACK)
    tr = ValueTracker(0)
    arc = always_redraw(lambda:Arc(start_angle=begin,angle=tr.get_value(),radius=0.5,stroke_width=10,color=GREEN_E).shift(m.get_center()))
    m_ = m.copy().set_color(linear_insert_manimcolor(start_color,color,0.5)).rotate(rotation)
    scene.add(arc,m)
    scene.play(Transform(m,m_),tr.animate.set_value(rotation))
    arr = Arrow(m.get_center(),m.get_center()+translation,color=YELLOW_E,buff=0)
    m_ = m.copy().set_color(color).shift(translation)
    scene.play(FadeOut(arc),GrowArrow(arr),Transform(m,m_),C_m.animate.shift(translation))
    scene.play(FadeOut(arr))

class s11(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{A}\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{O}_A",color=BLACK).to_corner(UL)
        t1[0][0].set_color(RED)
        t1_ = MathTex(r"\mathbf{B}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t1_[0][0].set_color(BLUE)
        A = Polygon([0,0,0],[1,0,0],[2,1,0],color=RED,fill_color=RED,fill_opacity=0.2)
        B = Polygon([0,0,0],[1,0,0],[2,1,0],color=BLUE,fill_color=BLUE,fill_opacity=0.2).rotate(30*DEGREES).shift(2*UP)
        C_A = Dot(A.get_center(),color=BLACK)
        C_B = Dot(B.get_center(),color=BLACK)
        self.play(Create(A),Create(B),Write(t1),Create(C_A),Create(C_B),Write(t1_))
        self.wait(1)

        t1__ = MathTex(r"\mathbf{A}\cong \mathbf{B}",color=BLACK).next_to(t1_,DOWN,aligned_edge=LEFT)
        t1__[0][0].set_color(RED)
        t1__[0][3].set_color(BLUE)
        self.play(Write(t1__))
        a = A.copy()
        Congruent_Translation(self,a,atan(0.5),30*DEGREES,2*UP,RED,BLUE)
        self.play(FadeOut(a))
        self.wait(1)

        t1___ = MathTex(r"\mathcal{E}\left(\mathbf{v},\mathbf{W}\right)\left(\mathbf{S}\right)\left(\mathbf{t}\right)=\mathbf{W}\mathbf{f}_S\left(\mathbf{t}\right)+\mathbf{O}_S+\mathbf{v}"
                        ,color=BLACK).next_to(t1__,DOWN,aligned_edge=LEFT)
        self.play(Write(t1___))
        self.wait(1)
        _E = t1___[0][0]
        TB_E = TargetBox(_E)
        _vW = t1___[0][2:5]
        self.play(Create(TB_E),_E.animate.set_color(RED),_vW.animate.set_color(BLUE))
        self.play(_vW.copy().animate.become(_vW.copy().move_to(_E.get_center()).fade(1)))
        self.wait(1)

        _EvW = t1___[0][0:6]
        TB_EvW = TargetBox(_EvW)
        _S = t1___[0][7]
        self.play(FadeOut(TB_E),_EvW.animate.set_color(RED),Create(TB_EvW),_S.animate.set_color(BLUE))
        self.play(_S.copy().animate.become(_S.copy().move_to(_EvW.get_center()).fade(1)))
        self.wait(1)

        _EvWs = t1___[0][0:9]
        TB_EvWs = TargetBox(_EvWs)
        _t = t1___[0][10]
        self.play(FadeOut(TB_EvW), _EvWs.animate.set_color(RED), Create(TB_EvWs), _t.animate.set_color(BLUE))
        self.play(_t.copy().animate.become(_t.copy().move_to(_EvWs.get_center()).fade(1)))
        self.wait(1)

        _all = t1___[0][:12]
        TB_all = TargetBox(_all)
        _right = t1___[0][13:]
        TB_right = TargetBox(_right)
        self.play(FadeOut(TB_EvWs), _all.animate.set_color(RED), Create(TB_all))
        self.play(ReplacementTransform(TB_all,TB_right),_all.animate.set_color(BLACK),_right.animate.set_color(RED))
        self.wait(1)
        self.play(FadeOut(TB_right),_right.animate.set_color(BLACK))
        self.wait(1)

        t1___1 = MathTex(r"\mathcal{E}\left(\mathbf{v}_1,\mathbf{W}_1\right)\left(\mathcal{E}\left(\mathbf{v},\mathbf{W}\right)\left(\mathbf{S}\right)\right)\left(\mathbf{t}\right)"
                         ,color=BLACK).next_to(t1___,DOWN,aligned_edge=LEFT)
        t1___2 = MathTex(r"=\mathbf{W}_1\mathbf{W}\mathbf{f}_S\left(\mathbf{t}\right)+\mathbf{O}_S+\mathbf{v}+\mathbf{v}_1"
                         ,color=BLACK).next_to(t1___1,DOWN,aligned_edge=LEFT)
        t1___3 = MathTex(
            r"=\mathcal{E}\left(\mathbf{v}+\mathbf{v}_1,\mathbf{W}_1\mathbf{W}\right)\left(\mathbf{S}\right)\left(\mathbf{t}\right)"
            , color=BLACK).next_to(t1___2, DOWN, aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t1___1,t1___2,t1___3]))
        HighLight(self,VGroup(t1___1,t1___2,t1___3))
        self.wait(1)

        t2 = MathTex(r"\mathbf{B}\left(\mathbf{t}\right)=\mathbf{W}\mathbf{t}+\mathbf{O}_A+\mathbf{v}"
                     , color=BLACK).next_to(t1___3, DOWN, aligned_edge=LEFT)
        t3 = MathTex(r"=\mathbf{W}\left(\mathbf{A}\left(\mathbf{t}\right)-\mathbf{O}_A\right)+\mathbf{O}_A+\mathbf{v}",
                     color=BLACK).next_to(t2, DOWN, aligned_edge=LEFT)
        t2[0][0].set_color(BLUE)
        t3[0][3].set_color(RED)
        self.play(Write(t2))
        self.play(Write(t3))
        self.wait(1)
        self.play(FadeOut(t1___1,t1___2,t1___3),t2.animate.next_to(t1___,DOWN,aligned_edge=LEFT))
        self.play(t3.animate.next_to(t2,DOWN,aligned_edge=LEFT))
        self.wait(1)
        t4 = MathTex(r"\mathcal{C}\left(\mathbf{v},\mathbf{W},\mathbf{A}\right)\left(\mathbf{p}\right)=\mathbf{W}\left(\mathbf{p}-\mathbf{O}_A\right)+\mathbf{O}_A+\mathbf{v}:\mathbf{A}\leftrightarrow\mathbf{B}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        HighLight(self,t4[0])
        tit = mytitle("全等映射","Congruent Mapping").to_edge(DOWN)
        self.play(Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))
        t5 = MathTex(r"\mathcal{C}\left(\mathbf{v},\mathbf{W},\mathbf{A}\right)^{-1}\left(\mathbf{q}\right)=\mathbf{W}^{-1}\left(\mathbf{q}-\mathbf{O}_A-\mathbf{v}\right)+\mathbf{O}_A"
                     ,color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        t6 = MathTex(r"=\mathbf{W}^{-1}\left(\mathbf{q}-\left(\mathbf{O}_A+\mathbf{v}\right)\right)+\left(\mathbf{O}_A+\mathbf{v}\right)-\mathbf{v}",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        t7 = MathTex(r"=\mathbf{W}^{-1}\left(\mathbf{q}-\mathbf{O}_B\right)+\mathbf{O}_B-\mathbf{v}=\mathcal{C}\left(-\mathbf{q},\mathbf{W}^{-1},\mathbf{B}\right)\left(\mathbf{q}\right)"
                     ,color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t5,t6,t7]))
        HighLight(self,t7[0][16:])
        T1 = MathTex(r"\mathbf{A}\cong\mathbf{B}\Rightarrow\mathbf{B}\cong\mathbf{A}",color=BLACK).to_corner(UR)
        self.play(Write(T1))
        b = B.copy()
        Congruent_Translation(self,b,atan(0.5)+30*DEGREES,-30*DEGREES,-2*UP,BLUE,RED)
        self.play(FadeOut(b))
        self.wait(1)
        self.play(FadeOut(t6,t7),Transform(t5,MathTex(r"\mathcal{C}\left(\mathbf{v},\mathbf{W},\mathbf{A}\right)^{-1}\left(\mathbf{q}\right)=\mathcal{C}\left(-\mathbf{q},\mathbf{W}^{-1},\mathbf{B}\right)\left(\mathbf{q}\right)"
                     ,color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)))
        t8 = MathTex(r"\mathcal{C}\left(\mathbf{v}_1,\mathbf{W}_1,\mathbf{B}\right)\left(\mathbf{q}\right):\mathbf{B}\leftrightarrow\mathbf{C}",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        t8[0][len(t8[0])-3].set_color(BLUE)
        t8[0][len(t8[0]) - 1].set_color(GREEN_E)
        self.play(Write(t8))
        C = B.copy()
        Congruent_Translation(self, C, atan(0.5) + 30 * DEGREES, -15 * DEGREES, 2 * RIGHT, BLUE, GREEN_E)
        self.wait(1)
        t9 = MathTex(r"\mathcal{C}\left(\mathbf{v}_1,\mathbf{W}_1,\mathbf{B}\right)\left(\mathcal{C}\left(\mathbf{v},\mathbf{W},\mathbf{A}\right)\left(\mathbf{p}\right)\right):\mathbf{A}\leftrightarrow\mathbf{C}"
                     ,color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        t10 = MathTex(r"\mathcal{C}\left(\mathbf{v}_1,\mathbf{W}_1,\mathbf{B}\right)\left(\mathcal{C}\left(\mathbf{v},\mathbf{W},\mathbf{A}\right)\left(\mathbf{p}\right)\right)=\mathcal{C}\left(\mathbf{v}_1+\mathbf{v},\mathbf{W}_1\mathbf{W},\mathbf{A}\right)\left(\mathbf{p}\right)"
                      ,color=BLACK).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        self.play(Write(t10))
        HighLight(self,t10[0][24:])
        T2 = MathTex(r"\mathbf{A}\cong\mathbf{B},\mathbf{B}\cong\mathbf{C}\Rightarrow\mathbf{A}\cong\mathbf{C}",color=BLACK).next_to(T1,DOWN,aligned_edge=RIGHT)
        self.play(Write(T2))
        c = C.copy()
        Congruent_Translation(self,c,atan(0.5)+15*DEGREES,-15*DEGREES,-2*RIGHT-2*UP,GREEN_E,RED)
        self.play(FadeOut(c))
        self.wait(1)

class s12(Scene):
    def construct(self):
        self.wait(1)
        t1 = Text(r"从任一点到任一点可作一条直线",color=BLACK).to_corner(UL)
        tt1 = MathTex(r"\mathbf{D}_\mathbf{AB}\left(t\right)=\mathbf{A}+t\left(\mathbf{B}-\mathbf{A}\right),t\in\left[0,1\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        A = np.array([0,0,0])
        B = np.array([2,1,0])
        Q_A = Dot(A,color=RED)
        Q_B = Dot(B,color=BLUE)
        Lambda = ValueTracker(1)
        Q_AB = always_redraw(lambda:Line(A,A+Lambda.get_value()*(B-A)).set_color_by_gradient([BLUE,RED]))
        self.play(Write(t1),Create(Q_A),Create(Q_B))
        self.play(Write(tt1),Write(Q_AB))
        self.wait(1)
        t2 = Text(r"一条有限直线可沿直线继续延长",color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        tt2 = MathTex(r"\mathbf{D}_\mathbf{AB}^{'}\left(t\right)=\mathbf{D}_\mathbf{AB}\left(t\right),t\in\left[0,\lambda\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.play(Lambda.animate.set_value(2),Write(tt2))
        self.wait(1)


def range_text(start: np.array, end: np.array, n: int):
    str_r = str()
    for i in range(n):
        str_r += r"\left[\right)"
    result = MathTex(str_r, color=BLACK).rotate(
        atan((end - start)[1] / (end - start)[0]) if (end - start)[0] != 0 else asin(
            (end - start)[1] / np.linalg.norm(end - start)))
    for i in range(n):
        result[0][2 * i].move_to(start + (end - start) * (i / n))
        result[0][2 * i + 1].move_to(start + (end - start) * ((i + 1) / n))
    return result

class s13(Scene):
    def construct(self):
        self.wait(1)
        t = ValueTracker(0)
        shape = always_redraw(lambda:Rectangle(height=t.get_value(),stroke_width=10,color=RED,fill_opacity=0.2))
        t1 = MathTex(r"\mathbf{A}",color=RED).to_corner(UL)

        self.play(FadeIn(shape),Write(t1))
        T_R = range_text(shape.get_left(),shape.get_right(),4)
        T_LAMBDA = MathTex(r"{:.1f}".format(0),color=BLACK).to_edge(DOWN)
        self.play(FadeIn(T_LAMBDA))
        self.play(Succession(*[Write(T_R[0][2*i]) for i in range(4)]),Succession(*[Write(T_R[0][2*i+1]) for i in range(4)])
                  ,Succession(*[Transform(T_LAMBDA,MathTex(r"{:.1f}".format(i+1),color=BLACK).to_edge(DOWN))for i in range(4)]))
        self.wait(1)
        self.play(Transform(T_LAMBDA,MathTex(r"\lambda\left(\mathbf{A}\right)",color=BLACK).to_edge(DOWN)))
        self.wait(1)
        tit = mytitle("测度","Measure").to_edge(DOWN)
        self.play(T_LAMBDA.animate.next_to(tit,UP),Write(tit))
        self.wait(1)
        self.play(FadeOut(tit),Transform(T_LAMBDA,MathTex(r"\lambda^n\left(\mathbf{A}\right)",color=BLACK).to_edge(DOWN)))
        self.wait(1)
        tit = mytitle("长度", "Length").to_edge(DOWN)
        self.play(Transform(T_LAMBDA,MathTex(r"\lambda^1\left(\mathbf{A}\right)",color=BLACK).next_to(tit,UP)), Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))
        tit = mytitle("面积", "Area").to_edge(DOWN)
        self.play(Transform(T_LAMBDA, MathTex(r"\lambda^2\left(\mathbf{A}\right)", color=BLACK).next_to(tit, UP)),
                  Write(tit))
        self.play(t.animate.set_value(2),T_R.animate.shift(DOWN))
        T_R2 = range_text(shape.get_bottom()+2*LEFT,shape.get_top()+2*LEFT,2)
        Pieces = VGroup(*[Square(side_length=1,color=GRAY,stroke_width=5,fill_opacity=0.2).shift(1.5*LEFT+0.5*DOWN).shift(j*UP+i*RIGHT)for j in range(2) for i in range(4)])
        self.play(Succession(*[Write(T_R2[0][2*i]) for i in range(2)]),Succession(*[Write(T_R2[0][2*i+1]) for i in range(2)]),Succession(*[Create(i)for i in Pieces]),run_time=1)
        self.wait(1)
        self.play(FadeOut(tit))
        tit = mytitle("体积", "Volume").to_edge(DOWN)
        self.play(Transform(T_LAMBDA, MathTex(r"\lambda^3\left(\mathbf{A}\right)", color=BLACK).next_to(tit, UP)),
                  Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))
        tit = mytitle("测度", "Measure").to_edge(DOWN)
        self.play(Transform(T_LAMBDA, MathTex(r"\lambda\left(\mathbf{A}\right)", color=BLACK).next_to(tit, UP)),
                  Write(tit))
        self.wait(1)

class s13_1(Scene):
    def construct(self):
        self.wait(1)
        T = Text(r"定义：",color=RED).to_corner(UL)
        t1 = MathTex(r"\mathbf{A}\cap\mathbf{B}=\emptyset\Rightarrow\lambda\left(\mathbf{A}\cup\mathbf{B}\right)=\lambda\left(\mathbf{A}\right)+\lambda\left(\mathbf{B}\right)"
                     ,color=BLACK).next_to(T,DOWN,aligned_edge=LEFT)
        self.play(Write(T))
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\Rightarrow \left(\mathbf{A}\subseteq\mathbf{C}\Rightarrow\lambda\left(\complement_\mathbf{C}\mathbf{A}\right)=\lambda\left(\mathbf{C}\right)-\lambda\left(\mathbf{A}\right)\right)"
                     ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\mathbf{A}\cong\mathbf{B}\Rightarrow\lambda\left(\mathbf{A}\right)=\lambda\left(\mathbf{B}\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\mathbf{D}^n_{UNIT}\left(\mathbf{t}\right)=\mathbf{E}_{a\times n}\mathbf{t},t_1,...,t_n\in\left[0,1\right)"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        tit1 = mytitle("单位平直形","Unit Linear Shape").to_edge(DOWN)
        self.play(Write(t4))
        HighLight(self,t4)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        self.wait(1)
        shape = Line(0.5*LEFT,0.5*RIGHT,color=RED,stroke_width=10)
        self.play(Write(shape))
        self.wait(1)
        shape_ = Square(side_length=1,color=RED,fill_opacity=0.2)
        self.play(FadeOut(shape),FadeIn(shape_))
        self.wait(1)
        self.play(FadeOut(shape_))
        self.wait(1)
        t5 = MathTex(r"\lambda^n\left(\mathbf{D}^n_{UNIT}\right)=1",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)

class s14(ThreeDScene):
    def construct(self):
        self.wait(1)
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)

        axes = ThreeDAxes(axis_config={"color":BLACK})
        def f(u,v):
            return axes.c2p(np.array([u,v,0.1*(u*u+(v*v))]))[0]
        surface = Surface(f,
                        u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        ls = VGroup(*[Polygon(f(-2+i,-2+j),f(-2+i,-2+j+1),f(-2+i+1,-2+j+1),f(-2+i+1,-2+j),color=BLUE,fill_opacity=0.2)for i in range(4) for j in range(4)])

        self.play(Create(axes))
        self.play(Create(surface))
        self.play(Create(ls))
        self.wait(1)
        aa = ls[6].copy()
        self.remove(ls[6])
        self.play(aa.animate.set_color(GREEN),ls.animate.fade(0.8))
        self.wait(1)

class s14_1(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{D}^1_{\left[a,b\right)}\left(t\right)=\begin{pmatrix}1 \\\mathbf{0}\end{pmatrix}t,t\in\left[a,b\right)",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\mathbf{D}^1_{UNIT}",color=RED).next_to(t1,DOWN,aligned_edge=LEFT)
        Q_D_UNIT = Line(start=0*RIGHT,end=2*RIGHT,color=RED,stroke_width=10)
        self.play(Write(t2),Write(Q_D_UNIT))
        self.wait(1)
        t3 = MathTex(r"a\in\mathbb{N}^+",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t_range = range_text(0*RIGHT,2*RIGHT,4)
        t4 = MathTex(r"\bigcup_{i=1} \mathbf{D}^1_{\left[\frac{i-1}{a},\frac{i}{a}\right)}=\mathbf{D}^1_{UNIT}"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t4_1 = MathTex(r"\Rightarrow\sum_{i=1} \lambda^1\left(\mathbf{D}^1_{\left[\frac{i-1}{a},\frac{i}{a}\right)}\right)=1",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Succession(*[Write(t_range[0][2*i])for i in range(4)]),Succession(*[Write(t_range[0][2*i+1])for i in range(4)]),Succession(Write(t4),Write(t4_1)))
        self.wait(1)
        t5 = MathTex(r"\lambda^1\left(\mathbf{D}^1_{\left[0,\frac{1}{a}\right)}\right)=\frac{1}{a}",color=BLACK).next_to(t4_1,DOWN,aligned_edge=LEFT)
        Q_D_ = Line(start=0*RIGHT,end=0.5*RIGHT,color=BLUE,stroke_width=20)
        self.play(Write(t5),Write(Q_D_))
        self.wait(1)
        t6 = MathTex(r"b\in\mathbb{N}^+,\lambda^1\left(\mathbf{D}^1_{\left[0,\frac{b}{a}\right)}\right)=\frac{b}{a}",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Q_D_.animate.put_start_and_end_on(0*RIGHT,RIGHT),Write(t6))
        self.wait(1)
        t7 = MathTex(r"c\in\mathbb{Q}\cap\left(0,+\infty\right),\lambda^1\left(\mathbf{D}^1_{\left[0,c\right)}\right)=c",color=BLACK).to_corner(UR)
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\mathbb{R}!!!!!", color=PURE_RED, stroke_width=10, font_size=777)
        self.play(Write(t8))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        Q_D_C = Line(0*RIGHT,e*RIGHT,color=RED,stroke_width=10)
        T1 = MathTex(r"c\in\mathbb{R}^+,a\in\mathbb{N}^+,b\in\mathbb{N}^+",color=BLACK).to_corner(UL)
        T2 = MathTex(r"\mathbf{D}^1_{\left[0,c\right)}",color=RED).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(Write(T1))
        self.play(Write(T2),Write(Q_D_C))
        self.wait(1)
        T3 = MathTex(r"\frac{b}{a}< c <\frac{b+1}{a}",color=BLACK).next_to(T2,DOWN,aligned_edge=LEFT)
        T3[0][0:3].set_color(BLUE)
        T3[0][4].set_color(RED)
        T3[0][6:].set_color(GREEN)
        Q_D_B = Line(0*RIGHT,2.5*RIGHT,color=BLUE,stroke_width=10).shift(.5*UP)
        Q_D_BP1 = Line(0*RIGHT,3*RIGHT,color=GREEN,stroke_width=10).shift(.5*DOWN)
        T_R_B = range_text(Q_D_B.get_left(),Q_D_B.get_right(),5)
        T_R_BP1 = range_text(Q_D_BP1.get_left(), Q_D_BP1.get_right(), 6)
        self.play(Write(T3),Write(Q_D_B),Write(Q_D_BP1),Succession(*[Write(T_R_B[0][2*i])for i in range(5)]),Succession(*[Write(T_R_B[0][2*i+1])for i in range(5)])
                  ,Succession(*[Write(T_R_BP1[0][2*i])for i in range(6)]),Succession(*[Write(T_R_BP1[0][2*i+1])for i in range(6)]))
        self.wait(1)
        T4 = MathTex(r"\mathbf{D}^1_{\left[0,\frac{b}{a}\right)}\subset\mathbf{D}^1_{\left[0,c\right)}\subset\mathbf{D}^1_{\left[0,\frac{b+1}{a}\right)}",color=BLACK).next_to(T3,DOWN,aligned_edge=LEFT)
        T5 = MathTex(r"\frac{b}{a}=\lambda^1\left(\mathbf{D}^1_{\left[0,\frac{b}{a}\right)}\right)<\lambda^1\left(\mathbf{D}^1_{\left[0,c\right)}\right)<\lambda^1\left(\mathbf{D}^1_{\left[0,\frac{b+1}{a}\right)}\right)=\frac{b+1}{a}"
                     ,color=BLACK).next_to(Q_D_BP1,DOWN).to_edge(LEFT)
        self.play(Write_In_Group_Althernately([T4,T5]))
        self.wait(1)
        g = [*self.mobjects]
        g.remove(T4)
        g.remove(T5)
        self.play(FadeOut(*g),VGroup(T4,T5).animate.to_corner(UL))
        T6 = MathTex(r"\left|\lambda^1\left(\mathbf{D}^1_{\left[0,c\right)}\right)-c\right|<\frac{b+1}{a}-\frac{b}{a}=\frac{1}{a}",color=BLACK).next_to(T5,DOWN,aligned_edge=LEFT)
        self.play(Write(T6))
        T7 = MathTex(r"\lim_{a\to+\infty}\left|\lambda^1\left(\mathbf{D}^1_{\left[0,c\right)}\right)-c\right|=0\Rightarrow\lambda^1\left(\mathbf{D}^1_{\left[0,c\right)}\right)=c"
                     ,color=BLACK).next_to(T6,DOWN,aligned_edge=LEFT)
        self.play(Write(T7))
        self.wait(1)

def shape_range(a:np.array,b:np.array,c:np.array,d:np.array,x:int,y:int):
    return VGroup(*[Polygon(a+(i*np.linalg.norm(a-b)/x)*RIGHT+(j*np.linalg.norm(c-b)/y)*UP,a+((i+1)*np.linalg.norm(a-b)/x)*RIGHT+(j*np.linalg.norm(c-b)/y)*UP
                            ,a+((i+1)*np.linalg.norm(a-b)/x)*RIGHT+((j+1)*np.linalg.norm(c-b)/y)*UP
                            , a + ((i) * np.linalg.norm(a - b)/x) * RIGHT + ((j + 1) * np.linalg.norm(c - b)/y) * UP
                            ,color=GRAY,fill_opacity=0.2)for i in range(x)for j in range(y)])

class s14_2(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{D}^n\left(\mathbf{u},\mathbf{v}\right)\left(\mathbf{t}\right)=\mathbf{E}_{\sigma\times n}\mathbf{t}+\mathbf{u},t_1\in\left[0,v_1\right),\cdots, t_n\in\left[0,v_n\right)",
                     color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\mathbf{D}^n_{UNIT}",color=RED).next_to(t1,DOWN,aligned_edge=LEFT)
        Q_D_UNIT = Polygon([0,0,0],[0,2,0],[2,2,0],[2,0,0],color=RED,fill_opacity=0.2)
        self.play(Write(t2),Write(Q_D_UNIT))
        self.wait(1)
        t3 = MathTex(r"a\in\mathbb{N}^+",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        sr = shape_range(np.array([0,0,0]),np.array([0,2,0]),np.array([2,2,0]),np.array([2,0,0]),4,4)
        t4 = MathTex(r"\sum_{\mathbf{i}=\mathbf{0}}\lambda^n\left(\mathbf{D}^n\left(\mathbf{i},\begin{bmatrix}\frac{1}{a}\\\vdots\\\end{bmatrix}\right)\right)=1"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t3),Write(t4),Succession(*[Write(i)for i in sr]),run_time=1)
        self.wait(1)
        t5 = MathTex(r"\Rightarrow \lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\begin{bmatrix}\frac{1}{a}\\\vdots\\\end{bmatrix}\right)\right)=a^{-n}"
                     ,color=DARK_BLUE).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5),sr[0].animate.set_color(DARK_BLUE))
        self.wait(1)
        t6 = MathTex(r"b_1,b_2,\cdots,b_n\in\mathbb{N}^+",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        t7 = MathTex(r"\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\begin{bmatrix}\frac{b_1}{a}\\\frac{b_2}{a}\\\vdots\\\frac{b_n}{a}\\\end{bmatrix}\right)\right)=b_1b_2\cdots b_na^{-n}"
                     ,color=BLACK).to_corner(DR)
        self.play(Write(t7),sr[0:8].animate.set_color(DARK_BLUE))
        self.wait(1)
        t8 = MathTex(r"\mathbb{R!!!!!}", color=PURE_RED, stroke_width=10, font_size=777)
        self.play(Write(t8))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))

        fontsize = 25

        T1 = MathTex(r"c_1,\cdots,c_n\in\mathbb{R}^+,a\in\mathbb{N}^+,b_1,\cdots,b_n\in\mathbb{N}^+",color=BLACK,font_size=fontsize).to_corner(UL)
        self.play(Write(T1))
        self.wait(1)
        T2 = MathTex(r"\frac{b_j}{a}<c_j<\frac{b_j+1}{a}",color=BLACK,font_size=fontsize).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(Write(T2))
        self.wait(1)
        T3 = MathTex(r"b_1b_2\cdots b_na^{-n}<c_1c_2\cdots c_n<\left(b_1+1\right)\left(b_2+1\right)\cdots\left(b_n+1\right)a^{-n}"
                     ,color=BLACK,font_size=fontsize).next_to(T2,DOWN,aligned_edge=LEFT)
        self.play(Write(T3))
        self.wait(1)
        T4 = MathTex(r"b_1b_2\cdots b_na^{-n}=\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\frac{1}{a}\mathbf{b}\right)\right)<\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\mathbf{c}\right)\right)<\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\frac{1}{a}\mathbf{b}+\begin{bmatrix}1\\\vdots\end{bmatrix}\right)\right)=\left(b_1+1\right)\left(b_2+1\right)\cdots\left(b_n+1\right)a^{-n}"
                     ,color=BLACK,font_size=fontsize).next_to(T3,DOWN,aligned_edge=LEFT)
        Q_S1 = Polygon([0,0,0],[0,-e,0],[2*e,-e,0],[2*e,0,0],color=RED,fill_opacity=0.2)
        #Q_S2 = Polygon([0, 0, 0], [0, -3, 0], [6, -3, 0], [6, 0, 0], color=GRAY, fill_opacity=0.1)
        #Q_S3 = Polygon([0, 0, 0], [0, -2.5, 0], [5, -2.5, 0], [5, 0, 0], color=GRAY, fill_opacity=0.1)
        sr__ = shape_range(np.array([0,-3,0]),np.array([6*(11/12),-3,0]),np.array([6*(11/12),0,0]),np.array([0,0,0]),11,6)
        sr_ = shape_range(np.array([0, -2.5, 0]), np.array([5, -2.5, 0]), np.array([5, 0, 0]), np.array([0, 0, 0]), 10, 5).set_color(BLUE)
        self.play(Write(T4),Write(Q_S1),Succession(*[Write(i)for i in sr__]),Succession(*[Write(i)for i in sr_]),run_time=1)
        self.wait(1)
        T5 = MathTex(r"\left|\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\mathbf{c}\right)\right)-c_1c_2\cdots c_n\right|<\frac{\left(b_1+1\right)\left(b_2+1\right)\cdots\left(b_n+1\right)-b_1b_2\cdots b_n}{a^n}"
                     ,color=BLACK,font_size=fontsize).next_to(T4,DOWN,aligned_edge=LEFT)
        self.play(Write(T5))
        self.wait(1)
        T6 = MathTex(r"<\frac{K}{a}",color=BLACK,font_size=fontsize).next_to(T5,DOWN,aligned_edge=LEFT)
        self.play(Write(T6))
        self.wait(1)
        T_1 = MathTex(r"\frac{b_1b_2\cdots b_n+b_1b_2\cdots b_{n-1}+\cdots+b_2b_3\cdots b_n+\cdots+1-b_1b_2\cdots b_n}{a^n}",color=BLACK,font_size=fontsize).next_to(T6,DOWN,aligned_edge=LEFT)
        T_2 = MathTex(r"=\frac{b_1b_2\cdots b_{n-1}+\cdots+b_2b_3\cdots b_n+\cdots+1}{a^n}",color=BLACK,font_size=fontsize).next_to(T_1,DOWN,aligned_edge=LEFT)
        T_3 = MathTex(r"\frac{b_{i_1}b_{i_2}\cdots b_{i_n}}{a^n}<c_{i_1}c_{i_2}\cdots c_{i_n}",color=RED,font_size=fontsize).next_to(T_2,DOWN,aligned_edge=LEFT)
        T_4 = MathTex(r"\Rightarrow\frac{b_1b_2\cdots b_{n-1}+\cdots+b_2b_3\cdots b_n+\cdots+1}{a^n}<\frac{c_1c_2\cdots c_{n-1}+\cdots}{a}=\frac{K}{a}"
                      ,color=BLACK,font_size=fontsize).next_to(T_3,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([T_1,T_2,T_3,T_4]))
        self.wait(1)
        T7 = MathTex(r"\lim_{a \to +\infty}\left|\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\mathbf{c}\right)\right)-c_1c_2\cdots c_n\right|=0 ",color=BLACK,font_size=fontsize).to_corner(UR)
        T8 = MathTex(r"\lambda^n\left(\mathbf{D}^n\left(\mathbf{0},\mathbf{c}\right)\right)=c_1c_2\cdots c_n",color=RED,font_size=fontsize).next_to(T7,DOWN,aligned_edge=LEFT)
        self.play(Write(T7))
        self.play(Write(T8))
        self.wait(1)

class s15(ThreeDScene):
    def construct(self):
        self.set_camera_orientation(phi=60 * DEGREES, theta=-30 * DEGREES)
        self.wait(1)
        axes = ThreeDAxes(axis_config={"color":BLACK})
        def f(x,y):
            return axes.c2p(np.array([x,y,0.1*(x**2+y**2)]))[0]
        def df_x(x):
            return axes.c2p(np.array([1,0,0.1*(2*x)]))[0]
        def df_y(y):
            return axes.c2p(np.array([0,1,0.1*(2*y)]))[0]
        shape = Surface(f,u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        PX = ValueTracker(0)
        PY = ValueTracker(0)
        DT = ValueTracker(1)
        Q_P = always_redraw(lambda:Dot3D(f(PX.get_value(),PY.get_value()),color=BLACK))
        Q_DFX = always_redraw(lambda:Arrow3D(Q_P.get_center(),Q_P.get_center()+DT.get_value()*df_x(PX.get_value()),color=DARK_BLUE))
        Q_DFY = always_redraw(lambda: Arrow3D(Q_P.get_center(), Q_P.get_center() + DT.get_value()*df_y(PY.get_value()), color=GREEN_E))
        T0 = MathTex(r"\mathbf{S}^n\left(\mathbf{t}\right)=\mathbf{f}\left(\mathbf{t}\right)+\mathbf{A}",color=BLACK).to_corner(UL)
        self.add_fixed_in_frame_mobjects(T0)
        self.play(Create(axes),Write(T0))##中子星NeutronStar233制作
        self.play(Create(shape),Create(Q_P),Create(Q_DFX),Create(Q_DFY))
        self.play(PX.animate.set_value(1),PY.animate.set_value(1))
        Q_AREA = always_redraw(lambda:Polygon(f(PX.get_value(),PY.get_value()),f(PX.get_value(),PY.get_value())+DT.get_value()*df_x(PX.get_value())
                                              ,f(PX.get_value(),PY.get_value())+DT.get_value()*df_x(PX.get_value())+DT.get_value()*df_y(PY.get_value())
                                              ,f(PX.get_value(),PY.get_value())+DT.get_value()*df_y(PY.get_value()),color=GRAY,fill_opacity=0.2))
        T1 = MathTex(r"\mathbf{AREA}_{\mathbf{p}}\left(\mathbf{t}\right)=\frac{d\mathbf{f}}{d\mathbf{t}}\left(\mathbf{p}\right)\mathbf{k} + \mathbf{S}^n\left(\mathbf{p}\right),k_i\in\left[0,\Delta  t\right)"
                     ,color=RED).next_to(T0,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(T1)
        self.play(Write(T1),Create(Q_AREA))
        self.play(DT.animate.set_value(0.5))
        self.play(PX.animate.set_value(-2),PY.animate.set_value(-2))
        shape__ = always_redraw(lambda:Surface(f,u_range=[-2,PX.get_value()+0.5],v_range=[-2,PY.get_value()+0.5],checkerboard_colors=[GRAY,BLACK],fill_opacity=0.5,resolution=8))
        self.add(shape__)
        self.play(PX.animate.set_value(1.5))
        self.play(PY.animate.set_value(1.5))
        T2 = MathTex(r"\mathbf{S}^n=\lim_{\Delta t\to0}\bigcup_{\mathbf{p}\in\mathbf{T}}\mathbf{AREA}_\mathbf{p}",color=BLACK).next_to(T1,DOWN,aligned_edge=LEFT)
        T3 = MathTex(r"\lambda^n\left(\mathbf{S}^n\right)=\lim_{\Delta t\to0}\sum_{\mathbf{p}\in\mathbf{T}}\lambda^n\left(\mathbf{AREA}_\mathbf{p}\right)",
                     color=BLACK).next_to(T2, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(T2,T3)
        self.play(Write(T2),Write(T3))
        self.wait(1)

class s16(Scene):
    def construct(self):
        self.wait(1)
        Q_A = Dot(LEFT,color=RED)
        T_A = MathTex(r"\mathbf{A}",color=RED).next_to(Q_A,LEFT)
        Q_B = Dot(RIGHT,color=BLUE)
        T_B = MathTex(r"\mathbf{B}", color=BLUE).next_to(Q_B, RIGHT)
        Q_SL_AB = Line(LEFT,RIGHT).set_color_by_gradient([BLUE,RED])
        T_SL_AB = MathTex(r"\mathbf{D}_{\mathbf{AB}}").set_color_by_gradient([BLUE,RED]).to_corner(UL)
        self.play(Write(Q_A),Write(Q_B),Write(T_A),Write(T_B))
        self.play(Write(Q_SL_AB),Write(T_SL_AB))
        self.wait(1)
        Q_L_AB = ParametricFunction(lambda t:np.array([cos(PI-t),sin(PI-t),0]),t_range=[0,PI],color=BLACK)
        T_L_AB = MathTex(r"\mathbf{L},\mathbf{L}\left(0\right)=\mathbf{A},\mathbf{L}\left(1\right)=\mathbf{B}",color=BLACK).next_to(T_SL_AB,DOWN,aligned_edge=LEFT)
        self.play(Write(Q_L_AB),Write(T_L_AB))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)

        nbp = NumberPlane(axis_config={"color":BLACK})
        Q = np.array([3*cos(30*DEGREES),3*sin(30*DEGREES),0])
        O = np.array([0,0,0])
        Q_Q = Dot(Q,color=RED_E)
        Q_D_Q = Line(O,Q,color=RED)
        T_D_Q = MathTex(r"\mathbf{D}\left(t\right)=\mathbf{q}t,t\in\left[0,1\right)",color=BLACK).to_corner(UL)
        T_D_Q[0][5].set_color(RED)
        self.play(Create(nbp))
        self.play(Write(Q_Q),Write(Q_D_Q),Write(T_D_Q))
        self.wait(1)
        HighLight(self,T_D_Q[0][len(T_D_Q[0])-4:])
        self.wait(1)
        T_D_Q_1 = MathTex(r"\mathbf{D}_1\left(t\right)=\mathbf{W}\mathbf{D}\left(t\right),t\in\left[0,1\right)=\begin{bmatrix}1\\\mathbf{0}\end{bmatrix}t,t\in\left[0,a\right)=\mathbf{q}_1t,t\in\left[0,1\right)"
                          ,color=BLACK).next_to(T_D_Q,DOWN,aligned_edge=LEFT)
        Q_D_Q_1 = Line(O,np.array([3,0,0]),color=BLUE_E)
        Q_Q_1 = Dot(np.array([3,0,0]),color=BLUE_E)
        nbpc = nbp.copy()
        self.play(ReplacementTransform(Q_D_Q.copy(),Q_D_Q_1),Write(T_D_Q_1),Write(Q_Q_1),nbpc.animate.rotate(-30*DEGREES))
        self.play(FadeOut(nbpc))
        self.wait(1)
        T_1 = MathTex(r"\lambda^1\left(\mathbf{D}_1\right)=a",color=BLACK).next_to(T_D_Q_1,DOWN,aligned_edge=LEFT)
        self.play(Write(T_1))
        self.wait(1)
        T_2 = MathTex(r"=\sqrt{\left(\mathbf{q}_1,\mathbf{q}_1\right)}=\sqrt{\left(\mathbf{W}\mathbf{q},\mathbf{W}\mathbf{q}\right)}=\sqrt{\left(\mathbf{q},\mathbf{q}\right)}",color=BLACK).next_to(T_1,DOWN,aligned_edge=LEFT)
        self.play(Write(T_2))
        self.wait(1)
        T_3 = MathTex(r"\mathbf{D}\cong\mathbf{D}_1",color=BLACK).next_to(T_2,DOWN,aligned_edge=LEFT)
        T_4 = MathTex(r"\lambda^1\left(\mathbf{D}\right)=\sqrt{\left(\mathbf{q},\mathbf{q}\right)}",color=BLACK).next_to(T_3,DOWN,aligned_edge=LEFT)
        self.play(Write(T_3))
        self.play(Write(T_4))
        HighLight(self,T_4,additional_animation=[T_4.animate.set_color(PURE_RED)])
        self.wait(1)
        T_5 = MathTex(r"\left| \mathbf{q} \right| =\sqrt{\left(\mathbf{q},\mathbf{q}\right)}=\lambda^1\left(\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{q}t,t\in\left[0,1\right)\right\}\right)"
                      ,color=BLACK).next_to(T_4,DOWN,aligned_edge=LEFT)
        self.play(Write(T_5))
        HighLight(self,T_5[0][0:5])
        self.wait(1)
        T_6 = MathTex(r"{\left|\mathbf{q}\right|}^2=\left(\mathbf{q},\mathbf{q}\right)",color=BLACK).next_to(T_5,DOWN,aligned_edge=LEFT)
        self.play(Write(T_6))
        self.wait(1)


class _pair:
    def __init__(self,_t="",_type=0):
        self.t = _t
        self.type = _type
## 0->ascll
## 1->gbk
def tex_with_gbk(t,clr = BLACK):
    res = VGroup()
    for i in t:
        res.add(MathTex(i.t,color=clr)if i.type == 0 else Text(i.t,color=clr))
    res.arrange(RIGHT)
    return res

class s16_1(Scene):
    def construct(self):
        self.wait(1)
        t0 = Text(r"接下来要证明：",color=BLACK).to_corner(UL)
        t1 = MathTex(r"\mathbf{a}+\mathbf{b}=\mathbf{c}",color=BLACK).next_to(t0,DOWN,aligned_edge=LEFT)
        t1[0][0].set_color(RED)
        t1[0][2].set_color(BLUE_E)
        t1[0][4].set_color(GREEN_E)
        Q_A = Vector([1,1,0],color=RED)
        Q_B = Vector([2,-1,0],color=BLUE_E).shift([1,1,0])
        Q_C = Vector([3,0,0],color=GREEN_E)
        self.play(Write(t0))
        self.play(Write(t1))
        self.play(GrowArrow(Q_A))
        self.play(GrowArrow(Q_B))
        self.play(GrowArrow(Q_C))
        self.wait(1)
        t2 = MathTex(r"\Rightarrow \left|\mathbf{a}\right|+\left|\mathbf{b}\right|\ge\left|\mathbf{c}\right|,\exists k, \mathbf{a}+k\mathbf{b}=0\Leftrightarrow\left|\mathbf{a}\right|+\left|\mathbf{b}\right|=\left|\mathbf{c}\right|",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = Text(r"只需证明：",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\left(\left|\mathbf{a}\right|+\left|\mathbf{b}\right|\right)^2\ge\left|\mathbf{a+b}\right|^2,\exists k, \mathbf{a}+k\mathbf{b}=0\Leftrightarrow\left(\left|\mathbf{a}\right|+\left|\mathbf{b}\right|\right)^2=\left|\mathbf{a+b}\right|^2"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\left(\left|\mathbf{a}\right|+\left|\mathbf{b}\right|\right)^2=\left(\mathbf{a},\mathbf{a}\right)+2\left|\mathbf{a}\right|\left|\mathbf{b}\right|+\left(\mathbf{b},\mathbf{b}\right)"
                     ,color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        t6 = MathTex(r"\left|\mathbf{a+b}\right|^2=\left(\mathbf{a}+\mathbf{b},\mathbf{a}+\mathbf{b}\right)=\left(\mathbf{a},\mathbf{a}\right)+2\left(\mathbf{a},\mathbf{b}\right)+\left(\mathbf{b},\mathbf{b}\right)"
                     ,color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.play(Write(t6))
        self.wait(1)
        t7 = Text(r"只需证明：",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        t8 = MathTex(r"\left|\mathbf{a}\right|\left|\mathbf{b}\right|\ge\left(\mathbf{a},\mathbf{b}\right),\exists k,\mathbf{a}+k\mathbf{b}=0\Leftrightarrow\left|\mathbf{a}\right|\left|\mathbf{b}\right|=\left(\mathbf{a},\mathbf{b}\right)",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.play(Write(t8))
        HighLight(self,t8[0][0:12])
        self.wait(1)
        self.play(FadeOut(*[i for i in self.mobjects if i !=t8 ]))
        self.play(t8.animate.to_corner(UL))
        self.wait(1)
        t9 = tex_with_gbk([_pair(r"当",1),_pair(r"\left(\mathbf{a},\mathbf{b}\right)\le 0",0),_pair("时显然成立",1)]).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        self.wait(1)
        t10 = tex_with_gbk([_pair(r"当",1),_pair(r"\left(\mathbf{a},\mathbf{b}\right)\ge 0", 0), _pair("时：", 1)]).next_to(t9,
                                                                                                                  DOWN,
                                                                                                                  aligned_edge=LEFT)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"\mathbf{y}=\mathbf{a}+x\mathbf{b}",color=BLACK).next_to(t10,DOWN,aligned_edge=LEFT)
        t12 = MathTex(r"\left(\mathbf{y},\mathbf{y}\right)=\left(\mathbf{a}+x\mathbf{b},\mathbf{a}+x\mathbf{b}\right)=\left(\mathbf{b},\mathbf{b}\right)x^2+2\left(\mathbf{a},\mathbf{b}\right)x+\left(\mathbf{a},\mathbf{a}\right)\ge 0"
                      ,color=BLACK).next_to(t11,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t11,t12]))
        self.wait(1)
        t13 = MathTex(r"\Delta=\left(2\left(\mathbf{a},\mathbf{b}\right)\right)^2-4\left(\mathbf{b},\mathbf{b}\right)\left(\mathbf{a},\mathbf{a}\right)=4\left(\mathbf{a},\mathbf{b}\right)^2-4\left|\mathbf{a}\right|^2\left|\mathbf{b}\right|^2 \le 0"
                      ,color=BLACK).next_to(t12,DOWN,aligned_edge=LEFT)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"4\left(\mathbf{a},\mathbf{b}\right)^2\le4\left|\mathbf{a}\right|^2\left|\mathbf{b}\right|^2",color=BLACK).next_to(t13,DOWN,aligned_edge=LEFT)
        t15 = MathTex(r"\left(\mathbf{a},\mathbf{b}\right)\le\left|\mathbf{a}\right|\left|\mathbf{b}\right|",color=BLACK).next_to(t14,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t14,t15]))
        self.wait(1)
        HighLight(self,t8[0][0:12],additional_animation=[t8[0][0:12].animate.set_color(RED)])
        self.wait(1)
        t16 = tex_with_gbk([_pair("当",1),_pair(r"\left(\mathbf{a},\mathbf{b}\right)=\left|\mathbf{a}\right|\left|\mathbf{b}\right|",0),_pair(r"时：",1)]).next_to(t15,DOWN,aligned_edge=LEFT)
        self.play(Write(t16))
        t17 = MathTex(r"\Delta = 0 \Rightarrow \exists x,\left(\mathbf{y},\mathbf{y}\right)=0 \Rightarrow \mathbf{a}+x\mathbf{b}=0",color=BLACK).next_to(t16,DOWN,aligned_edge=LEFT)
        self.play(Write(t17))
        self.wait(1)
        HighLight(self,t8[0][13:],additional_animation=[t8[0][13:].animate.set_color(RED)])
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        T_ALL = tex_with_gbk([_pair(r"\mathbf{a}+\mathbf{b}=\mathbf{c}\Rightarrow\left|\mathbf{a}\right|+\left|\mathbf{b}\right|\ge\left|\mathbf{c}\right|",0)
                              ,_pair("当且仅当",1),_pair(r"\mathbf{a},\mathbf{b}",0),_pair("线性相关时取等",1)])
        self.play(Write(T_ALL))
        self.wait(1)

def D_Vectors(func,leng,n):
    res = VGroup()
    for i in range(n):
        res.add(Arrow(func(i*leng/n),func((i+1)*leng/n),color=BLACK,buff=0))
    return res

class s16_2(Scene):
    def construct(self):
        self.wait(1)
        t1 = tex_with_gbk([_pair("设",1),_pair(r"\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_n")]).to_corner(UL)
        self.play(Write(t1))
        t2 = MathTex(r"\left|\mathbf{v}_1\right|+\left|\mathbf{v}_2\right|\ge\left|\mathbf{v}_1+\mathbf{v}_2\right|",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\left|\mathbf{v}_1\right|+\left|\mathbf{v}_2\right|+\left|\mathbf{v}_3\right|\ge\left|\mathbf{v}_1+\mathbf{v}_2\right|+\left|\mathbf{v}_3\right|\ge\left|\mathbf{v}_1+\mathbf{v}_2+\mathbf{v}_3\right|"
                     ,color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        t4 = MathTex(r"\vdots",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\sum \left|\mathbf{v}_i\right|\ge\left|\sum \mathbf{v}_i \right|",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        HighLight(self,t5,additional_animation=[t5.animate.set_color(RED)])
        self.wait(1)
        self.play(FadeOut(t1,t2,t3,t4),t5.animate.become(t5.copy().set_color(BLACK).to_corner(UL)))
        self.wait(1)
        t6 = MathTex(r"\mathbf{L}\left(t\right)=\mathbf{f}\left(t\right)+\mathbf{O},t\in\left[0,1\right],\mathbf{L}\left(0\right)=\mathbf{A},\mathbf{L}\left(1\right)=\mathbf{B}"
                     ,color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        line = ParametricFunction(lambda t:np.array([cos(PI-t),sin(PI-t),0]),t_range=[0,PI],color=BLACK).set_color_by_gradient([BLUE,RED])
        Q_A = Dot(LEFT,color=RED)
        Q_B = Dot(RIGHT, color=BLUE)
        T_A = MathTex(r"\mathbf{A}",color=RED).next_to(Q_A,LEFT)
        T_B = MathTex(r"\mathbf{B}", color=BLUE).next_to(Q_B, RIGHT)
        self.play(Create(Q_A),Create(Q_B),Write(T_A),Write(T_B))
        self.play(Write(t6),Write(line))
        self.wait(1)
        t7 = MathTex(r"\mathbf{L}=\lim_{\Delta t \to 0}\bigcup_i \left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=k\mathbf{f}'\left(i\Delta t\right)+\mathbf{A},k\in\left[0,\Delta t\right)\right\}\cup\left\{\mathbf{L}\left(1\right)\right\}"
                      ,color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        Q_VS = D_Vectors(lambda t:np.array([cos(PI-t),sin(PI-t),0]),PI,10)
        self.play(Write(t7),Succession(GrowArrow(i)for i in Q_VS.submobjects),run_time=1)##中子星NeutronStar233制作
        self.wait(1)
        t8 = MathTex(r"\lambda^1\left(\mathbf{L}\right)=\int_0^1 \left|d\mathbf{f}\right|\ge\left|\int_0^1 d\mathbf{f}\right|=\left|\mathbf{B}-\mathbf{A}\right|"
                     ,color=BLACK).next_to(T_A,DOWN).to_edge(LEFT)
        Q_AB = Arrow(LEFT,RIGHT,buff=0).set_color_by_gradient([BLUE,RED])
        self.play(Write(t8))
        self.play(Write(Q_AB),t8[0][29:32].animate.set_color_by_gradient([BLUE,RED]))
        self.wait(1)
        t9 = MathTex(r"=\lambda^1\left(\mathbf{D}_{\mathbf{A}\mathbf{B}}\right)",color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        HighLight(self,t9[0][4:7],additional_animation=[t9[0][4:7].animate.set_color(RED)])
        self.wait(1)
        t10 = mytitle("距离","Distance").to_edge(DOWN)
        self.play(Write(t10))
        self.wait(1)

class s17(ThreeDScene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{A}\left(\mathbf{t}\right)=\mathbf{W}\mathbf{f}\left(\mathbf{t}\right)+\mathbf(A),\mathbf{t}\in\mathbf{T}",color=BLACK).to_corner(UL)
        A = Circle(radius=2,color=RED,fill_opacity=0.1).shift(RIGHT)
        t_A = MathTex(r"\mathbf{A}",color=PURE_RED).move_to(A.get_center())
        self.play(Write(t1),Write(A),Write(t_A))
        self.wait(1)
        B = DashedVMobject(Square(side_length=1,color=GRAY,fill_opacity=0.4).shift(RIGHT).rotate(60*DEGREES))
        t2 = tex_with_gbk([_pair(r"\mathbf{B}"),_pair("是",1),_pair(r"\mathbf{A}"),_pair("中最大的开子集，则",1)
                              ,_pair(r"\mathbf{B}"),_pair("是",1),_pair(r"\mathbf{A}"),_pair("的内部",1)]).scale(0.5).next_to(t1,DOWN,aligned_edge=LEFT)
        t_B = MathTex(r"\mathbf{B}",color=GRAY).next_to(t_A,RIGHT)
        t_B2 = Text("内部",color=GRAY).next_to(t_A,LEFT)
        self.play(Write(B),Write(t2))
        self.play(Transform(B,DashedVMobject(Circle(radius=sqrt(2)/2,color=GRAY,fill_opacity=0.1).shift(RIGHT).rotate(60*DEGREES))))
        self.play(Transform(B,DashedVMobject(Circle(radius=2,color=GRAY,fill_opacity=0.1).shift(RIGHT))),Write(t_B),Write(t_B2))
        self.wait(1)
        t_OUT = tex_with_gbk([_pair(r"C=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}\not \in \mathbf{A}\right\}"),_pair("的内部",1)]).set_color(BLUE).scale(0.5).next_to(A,RIGHT)
        t_OUT2 = Text("外部",color=BLUE).next_to(t_OUT,DOWN)
        self.play(Write(t_OUT),Write(t_OUT2))
        s = Rectangle(height=9,width=16)
        C = Difference(s,A,color=BLUE,fill_opacity=0.4,stroke_opacity=0)
        self.play(Write(C))
        self.play(FadeOut(C))
        self.wait(1)
        PartialA = Circle(radius=2,color=BLACK,stroke_width=10).shift(RIGHT)
        t_PA = MathTex(r"\partial \mathbf{A}=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}\not\in\mathbf{B}\cup\mathbf{C}\right\}",color=BLACK).next_to(A,LEFT)
        t_PA2 = Text("边界",color=BLACK).next_to(t_PA,DOWN)
        self.play(Write(PartialA),Write(t_PA),Write(t_PA2))
        self.wait(1)
        t3 = tex_with_gbk([_pair("f是T到A的连续双射（且反函数也连续）",1),_pair(r"\Rightarrow \partial \mathbf{A}=\mathbf{f}\left(\partial\mathbf{T}\right)")]).scale(0.5).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        S = Surface(lambda r,theta:np.array([r*cos(theta),r*sin(theta),0.4*r+1]),u_range=[0,2],v_range=[0,2*PI],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4).shift(RIGHT)
        t = ValueTracker(0)
        p = always_redraw(lambda:Dot3D([2*cos(t.get_value()),2*sin(t.get_value()),1.8],color=BLACK).shift(RIGHT))
        q_t = always_redraw(lambda:Dot3D([2*cos(t.get_value()),2*sin(t.get_value()),0],color=BLACK).shift(RIGHT))
        vec = always_redraw(lambda:Arrow3D(q_t.get_center(),p.get_center(),color=BLACK))
        PS = always_redraw(lambda:ParametricFunction(lambda T:[2*cos(T),2*sin(T),1.8],t_range=[0,t.get_value()],color=BLACK).shift(RIGHT))
        self.move_camera(phi=60 * DEGREES, theta=-30 * DEGREES,added_anims=[Create(S),Transform(t_PA,MathTex(r"\partial \mathbf{T}",color=BLACK).next_to(A,LEFT))
            ,Transform(t_A,MathTex(r"\mathbf{T}",color=BLACK).move_to(A.get_center())),FadeOut(t_B,t_OUT)])
        self.add(p,PS,q_t,vec)
        self.play(t.animate.set_value(2*PI))
        self.wait(1)

class s18(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{f}\left(t\right),t\in \left[a,b\right]",color=BLACK).to_corner(UL)
        S = Line(2*LEFT,2*RIGHT,color=BLACK)
        self.play(Write(t1),Write(S))
        self.wait(1)
        t2 = MathTex(r"\mathbf{C}\left(a\right)=\mathbf{S}^1\left(b\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2),Transform(S,Circle(radius=2,color=BLACK)))
        self.wait(1)
        t3 = MathTex(r"\mathbf{p}\in\mathbf{C}\Rightarrow\left|\mathbf{p}-\mathbf{O}\right|=r",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        Q_O = Dot([0,0,0],color=BLACK)
        t = ValueTracker(0)
        Q_To_S = always_redraw(lambda:Dot(np.array([2*cos(t.get_value()),2*sin(t.get_value()),0]),color=BLACK))
        LQS = always_redraw(lambda:DashedLine(Q_O,Q_To_S,color=BLACK))
        self.play(Write(Q_O),Write(Q_To_S),Write(LQS),Write(t3))
        self.play(t.animate.set_value(2*PI),run_time = 4)
        self.wait(1)

        Q_Circle = Circle(radius=2,color=RED,fill_opacity=0.2)
        self.play(FadeIn(Q_Circle))
        tit = mytitle("圆","Circle").to_edge(DOWN)
        self.play(Write(tit))
        self.wait(1)
        self.play(FadeOut(tit))

        tit1 = mytitle(r"圆心","The Centre of A Circle").to_edge(DOWN)
        self.play(Write(tit1))
        HighLight(self,Q_O)
        tit2 = mytitle("半径","Radius").to_edge(DOWN)
        self.wait(1)
        self.play(FadeOut(tit1),Write(tit2))
        HighLight(self,LQS)
        self.wait(1)
        self.play(FadeOut(tit2))
        self.wait(1)
        T_t1 = TargetBox(t1)
        T_Circle = TargetBox(Q_Circle)
        self.play(Create(T_t1))
        self.wait(1)
        self.play(Create(T_Circle))
        self.wait(1)

class s19(Scene):
    def construct(self):
        self.wait(1)
        nbp = NumberPlane(axis_config={"color":BLACK})
        self.play(Create(nbp))
        self.wait(1)
        t1 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{W}\mathbf{f}\left(t\right),t\in\left[a,b\right]",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        Q_O = Dot([0,0,0],color=BLACK)
        T_O = MathTex(r"\mathbf{O}",color=BLACK).next_to(Q_O,DOWN)
        self.play(Write(Q_O),Write(T_O))
        self.wait(1)
        Q_P = Dot([2*cos(60*DEGREES),2*sin(60*DEGREES),0],color=BLACK)
        T_P = MathTex(r"\mathbf{P}",color=BLACK).next_to(Q_P,RIGHT)
        L_OP = DashedLine([0,0,0],Q_P.get_center(),color=BLACK)
        t2 = MathTex(r"\left|\mathbf{P}-\mathbf{O}\right|=\left|\mathbf{P}\right|=\left|\mathbf{W}\mathbf{f}\left(t\right)\right|",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(Q_P),Write(T_P),Write(t2),Write(L_OP))
        self.wait(1)
        t3 = MathTex(r"=\left|\mathbf{f}\left(t\right)\right|",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t4 = MathTex(r"\Rightarrow\left(\mathbf{f},\mathbf{f}\right)=r^2",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\Rightarrow \frac{d\left(\mathbf{f},\mathbf{f}\right)}{dt}=0",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        Q_PP = Dot([2*cos(70*DEGREES),2*sin(70*DEGREES),0],color=BLACK)
        T_PP = MathTex(r"\mathbf{P}'",color=BLACK).next_to(Q_PP,UP)
        L_OPP = DashedLine([0,0,0],Q_PP.get_center(),color=GRAY)
        self.play(Write(t5),ReplacementTransform(Q_P.copy(),Q_PP),Write(T_PP),Write(L_OPP))
        self.wait(1)
        t6 = MathTex(r"\Rightarrow \left(\mathbf{f}+d\mathbf{f},\mathbf{f}+d\mathbf{f}\right)=\left(\mathbf{f},\mathbf{f}\right)",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\Rightarrow \left(\mathbf{f},\mathbf{f}\right)+\left(\mathbf{f},d\mathbf{f}\right)+\left(d\mathbf{f},d\mathbf{f}\right)=\left(\mathbf{f},\mathbf{f}\right)"
                     ,color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\Rightarrow \left(\mathbf{f},d\mathbf{f}\right)=0",color=PURE_RED).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        self.wait(1)
        Q_DF = Line(Q_P.get_center(),Q_PP.get_center(),color=RED_E)
        t_df = MathTex(r"d\mathbf{f}",color=RED_E).next_to(Q_DF,UR)
        Q_F = Line([0,0,0],Q_P.get_center(),color=BLUE_E)
        angle = RightAngle(Q_DF,Q_F,color=PURE_RED,length=0.1,quadrant=(1,-1))
        self.play(Write(Q_DF),Write(Q_F),Write(angle),Write(t_df))
        self.wait(3)
        ## Whiteboard7 ##
        ## Whiteboard7 ##
        ## Whiteboard7 ##

        ## s19_continue ##
        ## s19_continue ##
        ## s19_continue ##

        g = Group(*[i for i in self.mobjects])
        g.remove(t8)
        self.play(FadeOut(g),t8.animate.to_corner(UL))
        self.wait(1)

        T1 = MathTex(r"f_1df_1+f_2df_2=0"
                     ,color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(T1))
        self.wait(1)
        T2 = MathTex(r"f_1f_1^{'}=f_2f_2^{'}",color=BLACK).next_to(T1,DOWN,aligned_edge=LEFT)
        self.play(Write(T2))
        self.wait(1)
        T3 = tex_with_gbk([_pair("设",1),_pair(r"f_1\left(t\right)=t")]).next_to(T2,DOWN,aligned_edge=LEFT)
        self.play(Write(T3))
        self.wait(1)
        T4 = MathTex(r"f_1^2+f_2^2=r^2",color=BLACK).next_to(T3,DOWN,aligned_edge=LEFT)
        T5 = MathTex(r"f_2=\pm\sqrt{r^2-f_1^2}=\pm\sqrt{r^2-t^2}",color=BLACK).next_to(T4,DOWN,aligned_edge=LEFT)
        self.play(Create(nbp))
        self.play(Write(T4))
        Q_C1 = ParametricFunction(lambda t:[t,sqrt(4-t**2),0],t_range=[-2,2],color=RED)
        Q_C2 = ParametricFunction(lambda t: [t, -sqrt(4 - t ** 2), 0], t_range=[-2, 2], color=BLUE)
        self.play(Write(T5),Write(Q_C1),Write(Q_C2))
        self.wait(1)
        self.play(FadeOut(T3,T4,T5))
        T6 = tex_with_gbk([_pair("注意到，当",1),_pair(r"f_1\left(t\right)=\left|t-2r\right|")
                          ,_pair("时",1)]).next_to(T2,DOWN,aligned_edge=LEFT)
        T7 = MathTex(r"f_2\left(t\right)=-\frac{t-2r}{\left|t-2r\right|}\sqrt{r^2-\left(\left|t-2r\right|-r\right)^2}",color=BLACK).next_to(T6,DOWN,aligned_edge=LEFT)
        self.play(Write(T6))
        self.play(Write(T7))
        self.wait(1)
        T8 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{W}\mathbf{\alpha}\left(t\right),t\in\left[0,4r\right]"
                     ,color=BLACK).next_to(T7,DOWN,aligned_edge=LEFT)
        TT1 = MathTex(r"\mathbf{\alpha}\left(t\right)=\begin{bmatrix}\left|t-2r\right| \\-\frac{t-2r}{\left|t-2r\right|}\sqrt{r^2-\left(\left|t-2r\right|-r\right)^2}\end{bmatrix}"
                      ,color=BLACK).to_corner(UR)
        self.play(Write(T8),Write(TT1))
        self.wait(1)
        T9 = tex_with_gbk([_pair("圆",1),_pair(r"\left(\mathbf{t}\right)=t_1\mathbf{W}\mathbf{\alpha}\left(t_2\right),t_1\in\left[0,r\right],t_2\in\left[0,4r\right]")]).next_to(T8,DOWN,aligned_edge=LEFT)
        self.play(Write(T9))
        self.wait(1)
        T10 = MathTex(r"\mathbf{\alpha}\left(p_1\right):\left\{\mathbf{p}\in\mathbf{V}\mid\left|\mathbf{p}\right|=r\right\}\leftrightarrow\mathbf{C}",color=BLACK).next_to(T9,DOWN,aligned_edge=LEFT)
        self.play(Write(T10))
        self.wait(1)

class s20(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"f_1'=-f_2,f_2'=f_1",color=BLACK).to_corner(UL)
        t2 = MathTex(r"f_1f_1'=-f_1f_2=-f_2'f_2",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t1))
        self.wait(1)
        self.play(Write(t2))
        self.wait(1)
        t2_ = MathTex(r"\sin't=\cos t,\cos' t= -\sin t",color=GRAY).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t2_))
        self.wait(1)
        self.play(FadeOut(t2_))
        self.wait(1)
        t3 = MathTex(r"f_1\left(0\right)=r,f_2\left(0\right)=0",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"f_1\left(t\right) = r\cos t,f_2\left(t\right) = r\sin t",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\sin 0 = 0,\cos 0 = 1",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\sin' t= \cos t,\cos' t= -\sin t",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\frac{d^{2n}\sin t}{dt^{2n}}=0,\frac{d^{\left(2n+1\right)}\sin t}{dt^{\left(2n+1\right)}}=\left(-1\right)^n",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        t8 = MathTex(
            r"\frac{d^{\left(2n+1\right)}\cos t}{dt^{\left(2n+1\right)}}=0,\frac{d^{2n}\cos t}{dt^{2n}}=\left(-1\right)^n",
            color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.play(Write(t8))
        self.wait(1)
        t9 = MathTex(r"\sin t = \sum_n^k \frac{d^n\sin t}{dt^n} \frac{t^n}{n! }+R\left(t\right) = \sum_n^k \frac{ \left(-1\right)^n}{ \left(2n+1\right)! }t^{2n+1} +R_1\left(t\right)"
                     ,color=BLACK).to_corner(UL)
        t10 = MathTex(r"\cos t = \sum_n^k \frac{d^n\cos t}{dt^n} \frac{t^n}{n!}+R\left(t\right) = \sum_n^k\frac{\left(-1\right)^n}{2n!}t^{2n}+R_2\left(t\right)"
                      ,color=BLACK).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(FadeOut(t1,t2,t3,t4,t5,t6,t7,t8),Write(t9))
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"R_1 = \frac{\sin^{\left(2k+1\right)}\xi}{\left(t\right)^{2k+1}}",color=BLACK).next_to(t10,DOWN,aligned_edge=LEFT)
        t11_1 = MathTex(r"\sin^{\left(2k+1\right)} t\in\left[-1,1\right]",color=BLACK).next_to(t11,DOWN,aligned_edge=LEFT)
        self.play(Write(t11))
        self.play(Write(t11_1))
        self.wait(1)
        t12 = MathTex(r"\lim_{k\to +\infty} R_1 = 0",color=BLACK).next_to(t11_1,DOWN,aligned_edge=LEFT)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"\lim_{k\to +\infty} R_2 = 0", color=BLACK).next_to(t12,DOWN,aligned_edge=LEFT)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"\sin t = \sum_n^{+\infty} \frac{ \left(-1\right)^n}{ \left(2n+1\right)! }t^{2n+1}",color=BLUE).next_to(t13,DOWN,aligned_edge=LEFT)
        t15 = MathTex(r"\cos t = \sum_n^{+\infty}\frac{\left(-1\right)^n}{\left(2n\right)!}t^{2n}",color=RED).next_to(t14,DOWN,aligned_edge=LEFT)
        VGroup(t14,t15).to_corner(DR)
        self.play(Write(t14))
        self.play(Write(t15))
        self.wait(1)
        tit1 = mytitle("正弦","Sine").set_color(BLUE).to_edge(DOWN)
        tit2 = mytitle("余弦","Cosine").set_color(RED).to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1),Write(tit2))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        t16 = MathTex(r"\mathbf{f}\left(t\right)=\begin{bmatrix}\cos t\\\sin t\end{bmatrix}",color=BLACK)
        t16[0][6:10].set_color(RED)
        t16[0][10:14].set_color(BLUE)
        self.play(Write(t16))
        self.wait(1)

def mathtexgroup(text):
    return VGroup(*[MathTex(i,color=BLACK)for i in text]).arrange(DOWN)

def greater(a,b):
    return a if a>b else b
def smaller(a,b):
    return a if a<b else b

class s20_1(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"Proof: \left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(t\right),t\in\mathbb{R}\right\}=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{\alpha}\left(t\right),t\in\left[0,4r\right)\right\}"
                     ,color=RED_E).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"1)Proof: \lambda^1\left(\mathbf{C}\right)\in\mathbb{R}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{\alpha}\left(t\right),t\in\left[0,4r\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        Q_C = Circle(radius=2,color=BLACK)
        self.play(Write(t3),Write(Q_C))
        self.wait(1)
        t4 = MathTex(r"\mathbf{C}_1\left(t\right)=\mathbf{\alpha}\left(t\right),t\in\left[0,2r\right)"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = MathTex(r"\mathbf{C}_2\left(t\right)=\mathbf{\alpha}\left(t\right),t\in\left[2r,4r\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT).next_to(t4,DOWN,aligned_edge=LEFT)
        Q_C1 = ParametricFunction(lambda t:[2*cos(t),2*sin(t),0],t_range=[0,PI],color=BLACK)
        Q_C2 = ParametricFunction(lambda t: [2 * cos(t), 2 * sin(t), 0], t_range=[PI, 2*PI], color=BLACK)
        self.add(Q_C1,Q_C2)
        self.remove(Q_C)##中子星NeutronStar233制作
        self.play(Write(t4),Q_C2.animate.become(Q_C2.copy().shift(2*DOWN).fade(1)))
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\mathbf{C}_1\cong\mathbf{C}_2",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        t7 = MathTex(r"\lambda^1\left(\mathbf{C}\right)=2\lambda^1\left(\mathbf{C}_1\right)",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\lambda^1\left(\mathbf{C}_1\right)=\int_0^{2r}\left|\mathbf{\alpha}\left(t\right)\right|dt",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        self.wait(1)
        t8_1 = mathtexgroup([r"\lambda\left(\boldsymbol{C}_{1}\right)= & \int_{0}^{2 r}\left|\boldsymbol{\alpha}^{\prime}(\boldsymbol{t})\right| d t=\int_{0}^{2 r} \sqrt{\alpha_{1}^{2}(t)+\alpha_{2}^{2}(t)} d t "
                             ,r"=\int_{0}^{2 r} \sqrt{\left(\alpha_{1}^{\prime}(t)\right)^{2}+\left(\alpha_{2}^{\prime}(t)\right)^{2}} d t"
                             ,r"=\int_{0}^{2 r} \sqrt{\left((r-t)^{\prime}\right)^{2}+\left(\left(\sqrt{r^{2}-(r-t)^{2}}\right)^{\prime}\right)^{2}} d t"
                             ,r"=-\int_{0}^{2 r} \sqrt{\left(\varphi(t)^{\prime}\right)^{2}+\left(\left(\sqrt{r^{2}-\varphi(t)^{2}}\right)^{\prime}\right)^{2}} \varphi^{\prime}(t) d t "
                             ,r"=-\int_{\varphi^{-1}(0)}^{\varphi^{-1}(2 r)} \sqrt{\left(x^{\prime}\right)^{2}+\left(\left(\sqrt{r^{2}-x^{2}}\right)^{\prime}\right)^{2}} d x "
                             ,r"=\int_{-r}^{r} \sqrt{1+\frac{x^{2}}{r^{2}-x^{2}}} d x=2 \int_{0}^{r} \sqrt{1+\frac{x^{2}}{r^{2}-x^{2}}} d x"]
                            ).scale(0.5).arrange(DOWN).set_color(GRAY).next_to(t1,DOWN).to_edge(RIGHT)
        self.play(Write(t8_1))
        t9 = MathTex(r"=2 \int_{0}^{r} \sqrt{1+\frac{x^{2}}{r^{2}-x^{2}}} d x",color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        self.wait(1)
        target_t9 = TargetBox(t9[0][5:len(t9[0])-2])
        t9_1 = MathTex(r"Continuous\,\,on \left(0,r\right)",color=BLACK).next_to(t9,RIGHT).to_edge(RIGHT)
        self.play(Create(target_t9))
        self.play(Write(t9_1))
        self.wait(1)
        t9_2 = MathTex(r"\in\mathbb{R}",color=RED).next_to(t9,RIGHT)
        self.play(Write(t9_2))
        self.wait(1)
        items = [*self.mobjects]
        items.remove(t1)
        self.play(FadeOut(*items))
        self.wait(1)
        tt1 = MathTex(r"if\,\exists a,b\in\mathbb{R} ,\mathbf{f}\left(a\right)=\mathbf{f}\left(b\right)",color=RED).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(tt1))
        self.wait(1)
        tt2 = MathTex(r"1)\mathbf{f}\left(a\right)=\mathbf{f}\left(b\right)\Rightarrow\mathbf{f}'\left(a\right)=\mathbf{f}'\left(b\right)",color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        self.play(Write(tt2))
        self.wait(1)
        tt3 = MathTex(r"2)\mathbf{f}\left(a\right)=\mathbf{f}\left(b\right)\Rightarrow\mathbf{f}\left(a+c\right)=\mathbf{f}\left(b+c\right)",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        self.play(Write(tt3))
        self.wait(1)
        tt4 = MathTex(r"\mathbf{f}\left(a+dt\right)=\mathbf{f}\left(a\right)+\mathbf{f}'\left(a\right)dt=\mathbf{f}\left(b\right)+\mathbf{f}'\left(b\right)dt=\mathbf{f}\left(b+dt\right)"
                      ,color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4))
        self.wait(1)
        tt5 = MathTex(r"\mathbf{f}\left(a+ndt\right)=\mathbf{f}\left(b+ndt\right)",color=BLACK).next_to(tt4,DOWN,aligned_edge=LEFT)
        tt6 = MathTex(r"\Rightarrow\mathbf{f}'\left(a+c\right)=\mathbf{f}'\left(b+c\right)",color=BLACK).next_to(tt5,DOWN,aligned_edge=LEFT)
        self.play(Write(tt5))
        self.wait(1)
        self.play(Write(tt6))
        self.wait(1)
        items = [*self.mobjects]
        items.remove(t1)
        self.play(FadeOut(*items))
        self.wait(1)
        ttt1 = Text("若f在实数域上单调",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        ttt2 = MathTex(r"\mathbf{X}=\left\{\mathbf{p}\in\mathbf{V}\mid\mathbf{p}=\mathbf{f}\left(t\right),t\in\mathbb{R}\right\}",color=BLACK).next_to(ttt1,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt1))
        self.play(Write(ttt2))
        self.wait(1)
        ttt3 = MathTex(r"\lambda^1\left(\mathbf{X}\right)=\int_\mathbb{R}\left|\mathbf{f}'\left(t\right)\right|dt=\int_\mathbb{R}rdt=+\infty",color=BLACK).next_to(ttt2,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt3))
        ttt4 = MathTex(r"\mathbf{C}\supseteq \mathbf{X}\Rightarrow\lambda^1\left(\mathbf{C}\right)>\lambda^1\left(\mathbf{X}\right)=+\infty",color=BLACK).next_to(ttt3,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt4))
        ttt5 = MathTex(r"\lambda^1\left(\mathbf{C}\right)\in\mathbb{R}",color=BLACK).next_to(ttt4,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt5))
        self.wait(1)
        self.play(ttt1.animate.set_color(RED),ttt2.animate.set_color(RED),ttt3.animate.set_color(RED),ttt4.animate.set_color(RED))
        self.play(FadeOut(ttt1,ttt2,ttt3,ttt4))
        self.wait(1)
        ttt6 = MathTex(r"\mathbf{f}\left(a\right)=\mathbf{f}\left(a+T\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        ttt6_1 = Text("设T是满足这个式子的最小的数",color=GRAY).scale(0.5).next_to(ttt6,DOWN).to_edge(RIGHT)
        self.play(Write(ttt6))
        self.play(Write(ttt6_1))
        self.wait(1)
        ttt7 = MathTex(r"\mathbf{f}\left(0\right) = \mathbf{f}\left(T\right)",color=BLACK).next_to(ttt6,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt7))
        self.wait(1)
        ttt8 = Text("f在[0,T)上单调",color=BLACK).next_to(ttt7,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt8))
        self.wait(1)
        self.play(t1.animate.set_color(RED))
        self.wait(1)
        self.play(Write(Q_C))
        t = ValueTracker(0)
        Q_P = always_redraw(lambda:Dot([2*cos(t.get_value()),2*sin(t.get_value()),0],color=BLACK))
        Q_DF = always_redraw(lambda:Arrow([2*cos(t.get_value()),2*sin(t.get_value()),0],[2*cos(t.get_value()),2*sin(t.get_value()),0]+np.array([cos(t.get_value()+PI/2),sin(t.get_value()+PI/2),0]),color=RED))
        self.play(Write(Q_P))
        self.play(Write(Q_DF))
        self.wait(1)
        self.play(t.animate.set_value(PI/4))
        self.play(t.animate.set_value(-PI / 4))
        self.wait(1)
        Q_AOP = always_redraw(lambda:ParametricFunction(lambda t:[2*cos(t),2*sin(t),0],color=RED,stroke_width=10,t_range=[smaller(0,t.get_value()),greater(0,t.get_value())]))
        self.play(t.animate.set_value(0))
        self.add(Q_AOP)
        self.play(t.animate.set_value(2*PI))
        self.wait(1)
        t.set_value(0)
        self.play(t.animate.set_value(-2*PI))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        T1 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{W}\mathbf{f}\left(t\right)+\mathbf{O}=\mathbf{W}\begin{bmatrix}2\cos t \\2\sin t\end{bmatrix}+\mathbf{O},t\in\left[0,T\right)",color=RED)
        self.play(Write(T1))
        self.wait(1)

class s20_2(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\tau = T",color=BLACK).to_corner(UL)
        t2 = MathTex(r"\pi = \frac{1}{2}\tau",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t1))
        self.play(Write(t2))
        target_t2 = TargetBox(t2[0][0])
        self.play(Write(target_t2))
        tit1 = mytitle("圆周率","Pi").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        t2_1 = MathTex(r"\mathbf{f}\left(t\right)=r\begin{bmatrix}\cos t\\\sin t \end{bmatrix}",color=GRAY).to_corner(UR)
        self.play(FadeOut(tit1,target_t2),Write(t2_1))
        self.wait(1)
        Q_C = Circle(radius = 2,color=BLACK)
        t3 = MathTex(r"\lambda^1\left(\mathbf{C}\right)=\int_0^{2\pi}\left|\mathbf{f}'\left(t\right)\right|dt",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t3_1 = MathTex(r"=\int_0^{2\pi}rdt=2\pi r",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(Q_C),Write(t3))
        self.play(Write(t3_1))
        self.wait(1)
        Q_F0 = Dot([2,0,0],color=BLACK)
        T_F0 = MathTex(r"\mathbf{f}\left(0\right)",color=BLACK).next_to(Q_F0,RIGHT)
        t = ValueTracker(0)
        Q_FT = always_redraw(lambda:Dot(np.array([2*cos(t.get_value()),2*sin(t.get_value()),0]),color=RED_E))
        T_FT = always_redraw(lambda:MathTex(r"\mathbf{f}\left(t\right)",color=RED_E).next_to(MathTex(r"\mathbf{f}\left(t\right)",color=RED_E).next_to(Q_FT,RIGHT),UP))
        self.play(Write(Q_F0),Write(T_F0),Write(Q_FT),Write(T_FT))
        Q_AF0FT = always_redraw(lambda:ParametricFunction(lambda t:[2*cos(t),2*sin(t),0],t_range=[0,t.get_value()],color=RED_E,stroke_width=10))
        self.add(Q_AF0FT)
        t4 = MathTex(r"\lambda^1\left(\mathbf{f}\left[0,t\right)\right)=\int_0^t rdt = rt",color=BLACK).next_to(t3_1,DOWN,aligned_edge=LEFT)
        t4[0][3:9].set_color(RED_E)
        self.play(t.animate.set_value(150*DEGREES),Write(t4))
        self.wait(1)
        t5 = MathTex(r"t = \frac{1}{r}\lambda^1\left(\mathbf{f}\left[0,t\right)\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        self.play(t.animate.set_value(PI))
        t5_1 = MathTex(r"=\frac{1}{r}\frac{1}{2}\lambda^1\left(\mathbf{C}\right)=\pi",color=BLACK).next_to(t5,RIGHT)
        self.play(Write(t5_1))
        t6 = MathTex(r"\mathbf{f}\left(0\right)=\begin{bmatrix}r\\0\end{bmatrix}=-\begin{bmatrix}-r\\0\end{bmatrix}=-\mathbf{f}\left(\pi\right)",color=BLACK).next_to(t2_1,DOWN,aligned_edge=RIGHT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\mathbf{f}\left(t\right)=-\mathbf{f}\left(t+\pi\right)",color=BLACK).next_to(t6,DOWN,aligned_edge=RIGHT)
        self.play(Write(t7))
        self.wait(1)
        t8 = mathtexgroup([r"\sin\left(t\right)=-\sin\left(t+\pi\right)",r"\cos\left(t\right)=-\cos\left(t+\pi\right)"]).next_to(t7,DOWN,aligned_edge=RIGHT)
        self.play(Write(t8))
        self.wait(1)
        t9 = MathTex(r"\cos t = \sin\left(t+\frac{1}{2}\pi\right)",color=BLUE).next_to(t8,DOWN,aligned_edge=RIGHT)
        self.play(Write(t9))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        tt1 = mathtexgroup([r"\cos\left(a-b\right)=\sin a\sin b+\cos a\cos b",r"\sin\left(a-b\right)=\sin a\cos b-\cos a\sin b"]).set_color(GRAY).to_corner(UL)
        self.play(Write(tt1))
        self.wait(1)
        tt1_1 = MathTex(r"\sin' t = \cos t,\cos' t = -\sin t",color=GRAY).to_corner(UR)
        self.play(Write(tt1_1))
        self.wait(1)
        self.play(tt1.animate.set_color(BLACK))
        self.wait(1)
        tt2 = mathtexgroup([r"\cos (a+\partial a & -b)=\cos (a-b)+\frac{\partial}{\partial a} \cos (a-b) \partial a "
                               ,r"=\cos a \cos b+\sin a \sin b"
                               ,r"+\frac{\partial}{\partial a}(\cos a \cos b+\sin a \sin b) \partial a "]).next_to(tt1,DOWN,aligned_edge=LEFT)
        for i in tt2:
            i.to_edge(LEFT)
        self.play(Write(tt2))
        self.wait(1)
        target_tt2 = TargetBox(tt2[2][0][1:])
        self.play(Write(target_tt2))
        tt2_1 = MathTex(r"\frac{\partial}{\partial a}\left(\cos a \cos b+\sin a \sin b\right)",color=GRAY).next_to(tt1_1,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt2_1))
        self.wait(1)
        tt3 = MathTex(r"=\cos \left(a\right) \cos b+\sin \left(a\right) \sin b",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        self.play(Write(tt3))
        self.wait(1)
        tt4 = MathTex(r"\forall \Delta a\in\mathbb{R}",color=BLACK).scale(0.5).next_to(tt3,DOWN,aligned_edge=LEFT)
        tt4_1 = MathTex(r"\cos\left(a+\Delta a-b\right)=\sin\left(a+\Delta a\right) \sin b+\cos \left(a+\Delta a\right)\cos b", color=BLACK).scale(0.5).next_to(tt4, DOWN, aligned_edge=LEFT)
        self.play(Write(tt4))
        self.play(Write(tt4_1))
        self.wait(1)
        tt5 = MathTex(r"\forall \Delta b\in\mathbb{R}", color=BLACK).scale(0.5).next_to(tt4_1, DOWN, aligned_edge=LEFT)
        tt5_1 = MathTex(
            r"\cos\left(a+\Delta a-b-\Delta b\right)=\sin\left(a+\Delta a\right) \sin \left(b+\Delta b\right)+\cos \left(a+\Delta a\right)\cos \left(b+\Delta b\right)",
            color=BLACK).scale(0.5).next_to(tt5, DOWN, aligned_edge=LEFT)
        self.play(Write(tt5))
        self.play(Write(tt5_1))
        self.wait(1)
        tt6 = mathtexgroup([r"\forall a,b\in\mathbb{R}",r"\cos\left(a-b\right)=\sin a\sin b+\cos a\cos b",r"\sin\left(a-b\right)=\sin a\cos b-\cos a\sin b"]).set_color(BLACK).to_edge(RIGHT)
        Q_tt1_tt6_arrow = Arrow(tt1.get_center(),tt6.get_center(),color=PURE_RED)
        self.play(Write(tt6),GrowArrow(Q_tt1_tt6_arrow))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        ttt1 = MathTex(r"\sin t = -\sin\left(-t\right)",color=BLACK).to_corner(UL)
        ttt2 = MathTex(r"\cos t = \cos \left(-t\right)",color=BLACK).next_to(ttt1,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt1))
        self.wait(1)
        self.play(Write(ttt2))
        self.wait(1)
        self.play(FadeOut(ttt1,ttt2))
        self.wait(1)
        ttt3 = MathTex(r"\cos \frac{1}{2}\pi = \frac{1}{r}\alpha_1\left(r\right) = 0",color=BLACK).to_corner(UL)
        ttt4 = MathTex(r"\sin \frac{1}{2}\pi = \frac{1}{r}\alpha_2\left(r\right) = 1", color=BLACK).next_to(ttt3,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt3))
        self.play(Write(ttt4))
        self.wait(1)
        ttt5 = MathTex(r"a=0,b=\frac{1}{2}\pi",color=BLACK).next_to(ttt4,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt5))
        ttt6 = MathTex(r"\cos\left(a-b\right)=\cos\left(-\frac{1}{2}\pi\right)=\cos\left(\frac{1}{2}\pi\right)=0",color=BLACK).next_to(ttt5,DOWN,aligned_edge=LEFT)
        ttt7 = MathTex(r"\cos a \cos b+\sin a \sin b = 0",color=BLACK).next_to(ttt6,DOWN,aligned_edge=LEFT)
        ttt8 = MathTex(r"\cos\left(a-b\right)=\cos a \cos b+\sin a \sin b ",color=BLACK).next_to(ttt7,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt6))
        self.wait(1)
        self.play(Write(ttt7))
        self.wait(1)
        self.play(Write(ttt8))
        self.wait(1)
        ttt9 = MathTex(r"\sin\left(a-b\right)=\sin a \cos b - \cos a \sin b",color=BLACK).next_to(ttt8,DOWN,aligned_edge=LEFT)
        self.play(Write(ttt9))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        tttt = mathtexgroup([r"\forall a,b \in \mathbb{R}",r"\cos\left(a\pm b\right)=\cos a \cos b\mp\sin a \sin b "
                                ,r"\sin\left(a\pm b\right)=\sin a \cos b \pm  \cos a \sin b"]).set_color(RED)
        self.play(Write(tttt))
        self.wait(1)

class s20_3(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\pi",color=PURE_RED).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"=\frac{1}{2r}\lambda^1\left(\mathbf{C}\right)=\frac{1}{r}\lambda^1\left(\mathbf{C}_1\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"=\frac{2}{r}\int_0^r \sqrt{1+\frac{x^2}{r^2+x^2}}dx",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"=2\int_0^1 \sqrt{1+\frac{x^2}{1+x^2}}dx",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\approx 3.1415926535897932384626433832795",color=PURE_RED).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)

class  s21(Scene):
    def construct(self):
        self.wait(1)
        t = ValueTracker(0)
        Q_P = always_redraw(lambda:Dot([t.get_value(),0,0],color=BLACK))
        Q_L = always_redraw(lambda:ParametricFunction(lambda t:[t,0,0],t_range=[0,t.get_value()],color=RED))
        self.play(Write(Q_P))
        self.add(Q_L)
        self.play(t.animate.set_value(1))
        self.wait(1)
        tr2 = ValueTracker(0)
        self.remove(Q_P)
        Q_P = always_redraw(lambda:Dot([cos(tr2.get_value()),sin(tr2.get_value()),0],color=BLACK))
        Q_L2 = always_redraw(lambda:ParametricFunction(lambda t:[cos(t),sin(t),0],t_range=[0,tr2.get_value()],color=BLUE))
        Q_L3 = always_redraw(lambda:ParametricFunction(lambda t:[t*cos(tr2.get_value()),t*sin(tr2.get_value()),0],t_range=[0,t.get_value()],color=RED))
        self.add(Q_L2,Q_P,Q_L3)
        self.play(tr2.animate.set_value(3*PI/4))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        t1 = MathTex(r"\mathbf{C}\left(t\right)=r\mathbf{W}\begin{bmatrix}\cos t\\\sin t \end{bmatrix}+\mathbf{O},t\in\left[0,2\pi\right)",color=BLACK).to_corner(UL)
        Q_O = Dot([0,0,0],color=BLACK)
        Q_C = Circle(radius=2,color=BLACK)
        self.play(Write(t1),Write(Q_C),Write(Q_O))
        self.wait(1)
        t2 = MathTex(r"p=\mathbf{C}\left(t\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t3 = MathTex(r"p'=\mathbf{C}'\left(t+\theta\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        my_t = ValueTracker(0)
        my_theta = ValueTracker(0)
        Q_P = always_redraw(lambda:Dot([2*cos(my_t.get_value()),2*sin(my_t.get_value()),0],color=BLUE_E))
        T_P = always_redraw(lambda:MathTex(r"\mathbf{C}\left(t\right)",color=BLUE_E).next_to(Q_P,UP))
        Q_PP = always_redraw(lambda:Dot([2*cos(my_t.get_value()+my_theta.get_value()),2*sin(my_t.get_value()+my_theta.get_value()),0],color=GREEN_E))
        T_PP = always_redraw(lambda: MathTex(r"\mathbf{C}\left(t\right)", color=GREEN_E).next_to(Q_PP, DOWN))
        Q_LP_PP = always_redraw(lambda:ParametricFunction(lambda t:np.array([2*cos(t),2*sin(t),0]),t_range=[my_t.get_value(),my_t.get_value()+my_theta.get_value()],color=RED_E,stroke_width=10))
        self.play(Write(Q_P),Write(T_P))
        self.play(Write(t2),my_t.animate.set_value(30*DEGREES))
        self.add(Q_PP,T_PP,Q_LP_PP)
        self.play(Write(t3),my_theta.animate.set_value(100*DEGREES))
        self.wait(1)
        t4 = MathTex(r"\mathbf{R}\left(x\right)=\mathbf{C}\left(t+x\right),x\in\left[0,\theta\right)",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t_ps = Text("注明：这里的R(x)意思是在x时刻旋转到的位置，R是Rotation",color=GRAY).scale(0.5).to_corner(DR)
        self.play(Write(t4),Write(t_ps))
        target_t4 = TargetBox(t4)
        self.play(Create(target_t4))
        HighLight(self,Q_O)
        tit1 = mytitle("旋转","Rotate").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(target_t4,tit1,t_ps))
        t5 = MathTex(r"\lambda^1\left(\mathbf{C}\left(\left[t,t+\theta\right)\right)\right)",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        target_t5 = TargetBox(t5)
        self.play(Write(t5))
        self.play(Create(target_t5))
        tit2 = mytitle(r"弧长","Arc(Length)").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(target_t5,tit2))
        t6 = MathTex(r"\theta = \frac{1}{r}\lambda^1\left(\mathbf{C}\left(\left[t,t+\theta\right)\right)\right)",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        target_t6 = TargetBox(t6)
        self.play(Create(target_t6))
        tit3 = mytitle("角度","Angle").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)
        self.play(FadeOut(target_t6,tit3))
        self.wait(1)
        self.play(my_theta.animate.set_value(2*PI))
        t7 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{C}\left(t+\theta\right)\Rightarrow \theta = k2\pi,k\in\mathbb{Z}",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        self.play(t7[0][len(t7[0]) - 6:len(t7[0]) - 4].animate.set_color(RED))
        HighLight(self,t7[0][len(t7[0]) - 6:len(t7[0]) - 4])
        tit4 = mytitle("周角","Round Angle").to_edge(DOWN)
        self.play(Write(tit4))
        self.play(FadeOut(tit4))
        self.wait(1)
        t8 = MathTex(r"\mathbf{L}\left(k\right)=\mathbf{O}+k\mathbf{q}",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        Q_L = Line(3*UL,3*DR,color=BLACK)
        self.play(Write(t8),Write(Q_L),FadeOut(Q_LP_PP,Q_P,T_P,T_PP,Q_PP))
        self.wait(1)
        Q_PC1 = Dot(np.array([2*cos(135*DEGREES),2*sin(135*DEGREES),0]),color=BLACK)
        Q_PC2 = Dot(np.array([2 * cos(-45*DEGREES), 2 * sin(-45*DEGREES), 0]), color=BLACK)
        t9 = MathTex(r"\mathbf{O}+\mathbf{a},\mathbf{O}-\mathbf{a}",color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9),Write(Q_PC1),Write(Q_PC2))
        self.wait(1)
        t10 = MathTex(r"\mathbf{O}+\mathbf{a}=\mathbf{C}\left(\eta\right),\mathbf{O}-\mathbf{a}=\mathbf{C}\left(\eta+\left(\right)\pi\right)",color=BLACK).to_corner(UR)
        self.play(Write(t10))
        self.wait(1)
        self.play(t10[0][len(t10[0]) -2].animate.set_color(RED))
        HighLight(self,t10[0][len(t10[0]) -2])
        tit5 = mytitle("平角","Straight Angle").to_edge(DOWN)
        self.play(Write(tit5))
        self.wait(1)

class s22_fixed(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{C}_{UNIT}\left(t\right)=\mathbf{W}\begin{bmatrix}\cos t \\\sin t\end{bmatrix},t\in\left[0,2\pi\right)",color=BLACK).to_corner(UL)
        Q_C = Circle(radius = 1,color=BLACK)
        Q_O = Dot([0,0,0],color=RED)
        T_O = MathTex(r"\mathbf{W}\begin{bmatrix}0\\0\end{bmatrix}",color=RED).next_to(Q_O,DL)
        Q_R = Line([0,0,0],[cos(30*DEGREES),sin(30*DEGREES),0],color=BLUE)
        T_R = MathTex(r"1",color=BLUE).next_to(Q_R,UR)
        self.play(Write(t1),Write(Q_C),Write(Q_O),Write(Q_R),Write(T_R),Write(T_O))
        tit1 = mytitle("单位圆","Unit Circle").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1,Q_O,T_O,Q_R,T_R))
        self.wait(1)
        t2 = MathTex(r"\mathbf{\alpha}\mid_{r=1}\left(t\right)=\begin{bmatrix}|t-2|-1\\-\frac{t-2}{|t-2|} \sqrt{1-(|t-2|-1)^{2}}\end{bmatrix},t\in\left[0,4\right)"
                     ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t = ValueTracker(0)
        Q_P = always_redraw(lambda:Dot([cos(t.get_value()),sin(t.get_value()),0],color=BLACK))
        Q_ARCP = always_redraw(lambda:ParametricFunction(lambda t:[cos(t),sin(t),0],t_range=[0,t.get_value()],color=GREEN_E,stroke_width=10))
        Q_XP = always_redraw(lambda:Line([1,0,0],([cos(t.get_value()),0,0]if t.get_value()<PI else [-1,0,0]),color=RED_E,stroke_width=10))
        Q_YP = always_redraw(lambda:DashedLine([cos(t.get_value()),sin(t.get_value()),0],[cos(t.get_value()),0,0],color=BLUE_E))
        t3 = MathTex(r"R\left(\mathbf{\alpha}_1\right)=R\left(\cos\right)=\left[-1,1\right]",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(Q_P))
        self.add(Q_ARCP,Q_XP,Q_YP)
        self.play(Write(t3),t.animate.set_value(2*PI),run_time=4)
        self.wait(1)
        t4 = MathTex(r"\begin{bmatrix}\cos x \\\sin x\end{bmatrix}=\alpha\left(y\right),d\begin{bmatrix}\cos x \\\sin x\end{bmatrix}=kd\begin{bmatrix}|y-2|-1\\-\frac{y-2}{|y-2|} \sqrt{1-(|y-2|-1)^{2}}\end{bmatrix},k>0"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\frac{d}{dt}\cos x = k\frac{d}{dt}\left(|y-2|-1\right),k>0",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\frac{d}{dt}\cos x\ge 0\Leftrightarrow \frac{d}{dt}\left(|y-2|-1\right)\ge 0",color=GRAY).next_to(t5,DOWN,aligned_edge=LEFT)
        t7 = MathTex(r"\cos a = 1 = \alpha_1\left(0\right),\cos b = -1 = \alpha_1\left(2\right),t\in\left[a,b\right]\Rightarrow\cos' t \le 0 ",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write_In_Group_Althernately([t6,t7]))
        self.play(t.animate.set_value(0))
        self.play(t.animate.set_value(PI),run_time = 4)
        self.wait(1)
        t8 = MathTex(r"y\in\left[-1,1\right],\exists\arccos y\in\left[0,\pi\right]",color=BLACK).to_corner(UR)
        self.play(Write(t8))
        self.wait(1)

class s22_1(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{C}\left(t\right)=\mathbf{W}\begin{bmatrix}\cos t\\\sin t\end{bmatrix},t\in\left[0,2\pi\right)",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        t2 = MathTex(r"\mathbf{p} = \mathbf{C}\left(\theta\right)",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"\mathbf{W}=\begin{bmatrix}\mathbf{g}&\mathbf{W}_2\end{bmatrix}",color=GRAY).to_corner(UR)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\left(\mathbf{p},\mathbf{g}\right)=\left(\begin{bmatrix}\cos \theta\\\sin \theta\end{bmatrix},\begin{bmatrix}1\\0\end{bmatrix}\right)=\cos \theta",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"\mathbf{a},\mathbf{b}\not = \mathbf{0}",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\frac{\mathbf{a}}{\left|\mathbf{a}\right|}=\mathbf{p}",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        t7 = MathTex(r"\frac{\mathbf{b}}{\left|\mathbf{b}\right|}=\mathbf{g}",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\left(\mathbf{a},\mathbf{b}\right)=\left(\left|\mathbf{a}\right|\mathbf{p},\left|\mathbf{b}\right|\mathbf{g}\right)",color=BLACK).next_to(t3,DOWN,aligned_edge=RIGHT)
        t9 = MathTex(r"=\left|\mathbf{a}\right|\left|\mathbf{b}\right|\cos \theta",color=BLACK).next_to(t8,DOWN,aligned_edge=RIGHT)
        self.play(Write(t8))
        self.play(Write(t9))
        self.wait(1)
        t10 = MathTex(r"\theta = \arccos\frac{\left(\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}",color=BLACK).next_to(t9,DOWN,aligned_edge=RIGHT)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"\in\left[0,\pi\right]",color=BLACK).next_to(t10,DOWN,aligned_edge=RIGHT)
        self.play(Write(t11))
        self.wait(1)
        t = ValueTracker(0)
        Q_B = always_redraw(lambda:Vector([2*cos(t.get_value()),2*sin(t.get_value()),0],color=RED))
        Q_A = Vector([1.5*cos(60*DEGREES),1.5*sin(60*DEGREES),0],color=BLUE)
        self.play(Write(Q_B),Write(Q_A))
        Q_BA = always_redraw(lambda: ParametricFunction(lambda t:[cos(t),sin(t),0],t_range=[0,t.get_value()],color=GREEN_E,stroke_width=10))
        self.add(Q_BA)
        self.play(t.animate.set_value(60*DEGREES))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)

        t.set_value(0)
        tt1 = MathTex(r"\mathbf{L}_1\left(k\right)=\mathbf{P}+k\mathbf{b},k\in\left[0,+\infty\right)",color=BLACK).to_corner(UL)
        self.play(Write(tt1))
        Q_P = Dot([0,0,0],color=BLACK)
        Q_B_ = Arrow([0,0,0],[2,0,0],buff=0,color=RED)
        Q_L1 = ParametricFunction(lambda k:np.array([0,0,0])+k*np.array([2,0,0]),t_range=[0,10],color=RED_E)
        self.play(Write(Q_P))
        self.play(Write(Q_B_))
        self.play(Write(Q_L1))
        self.wait(1)
        tt2 = MathTex(r"\mathbf{L}_2\left(k\right)=\mathbf{P}+k\mathbf{a},k\in\left[0,+\infty\right)",color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        Q_A_ = Arrow([0,0,0],[1.5*cos(60*DEGREES),1.5*sin(60*DEGREES),0],color=BLUE,buff=0)
        Q_L2 = ParametricFunction(lambda k:np.array([0,0,0])+k*np.array([1.5*cos(60*DEGREES),1.5*sin(60*DEGREES),0]),t_range=[0,10],color=BLUE_E)
        self.play(Write(tt2))
        self.play(Write(Q_A_))
        self.play(Write(Q_L2))
        self.wait(1)
        tt3 = MathTex(r"\mathbf{Rotate}\left(\theta,\mathbf{x}\right):\mathbf{L}_1\leftrightarrow\mathbf{L}_2",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        self.play(Write(tt3))
        Q_B__ = always_redraw(lambda:Arrow([0,0,0],[2*cos(t.get_value()),2*sin(t.get_value()),0],buff=0,color=GRAY))
        Q_L1__ = always_redraw(lambda:ParametricFunction(lambda k:np.array([0,0,0])+k*np.array([2*cos(t.get_value()),2*sin(t.get_value()),0]),t_range=[0,10],color=GRAY))
        Q_BA__ = always_redraw(lambda: ParametricFunction(lambda t:[cos(t),sin(t),0],t_range=[0,t.get_value()],color=GREEN_E,stroke_width=10))
        self.add(Q_B__,Q_L1__,Q_BA__)
        self.play(t.animate.set_value(60*DEGREES))
        self.wait(1)
        tt4 = MathTex(r"\left \langle \mathbf{b},\mathbf{a} \right \rangle \mid\mathbf{P}",color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4))
        HighLight(self,tt4)
        tit1 = mytitle("夹角","Included Angle").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        tt5 = MathTex(r"=\left\langle \mathbf{b},\mathbf{a}\right\rangle",color=BLACK).next_to(tt4,DOWN,aligned_edge=LEFT)
        self.play(Write(tt5))
        self.wait(1)
        tt6 = MathTex(r"=\theta = \arccos\frac{\left(\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}",color=BLACK).next_to(tt5,DOWN,aligned_edge=LEFT)
        self.play(Write(tt6))
        self.wait(1)

def ARC(theta_1,theta_2,radius=1,**kwargs):
    return ParametricFunction(lambda t:[radius*cos(t),radius*sin(t),0],t_range=[theta_1,theta_2],**kwargs)
def ARC_V(a,b,radius=1 ,**kwargs):
    theta_1 = acos(np.dot(a,[1,0,0])/np.linalg.norm(a)) if a[1]>0 else -acos(np.dot(a,[1,0,0])/np.linalg.norm(a))
    theta_2 = acos(np.dot(b,[1,0,0])/np.linalg.norm(b))if b[1]>0 else -acos(np.dot(b,[1,0,0])/np.linalg.norm(b))
    return ARC(smaller(theta_1,theta_2),greater(theta_1,theta_2),radius,**kwargs)

class s22_2(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{a},\mathbf{b}\not = \mathbf{0}",color=BLACK).to_corner(UL)
        Q_A = Arrow([0,0,0],[2,0,0],color=RED,buff = 0)
        Q_B = Arrow([0,0,0],[1.5*cos(60*DEGREES),1.5*sin(60*DEGREES),0],color=BLUE,buff = 0)
        t = ValueTracker(0)
        t_ = ValueTracker(0)
        Q_AB = always_redraw(lambda: ParametricFunction(lambda t:[cos(t),sin(t),0],t_range=[0,t.get_value()],color=GREEN_E,stroke_width=10))
        Q_BA = always_redraw(
            lambda: ParametricFunction(lambda t: [cos(60*DEGREES-t), sin(60*DEGREES-t), 0], t_range=[0, t_.get_value()], color=BLACK,
                                       stroke_width=10))
        Q_P = Dot([0,0,0],color=BLACK)
        T_P = MathTex(r"\mathbf{P}",color=BLACK).next_to(Q_P,DR)
        self.play(Write(t1),Write(Q_A),Write(Q_B),Write(Q_P),Write(T_P))
        self.wait(1)
        t2 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle=\left\langle\mathbf{b},\mathbf{a}\right\rangle",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.add(Q_AB)##中子星NeutronStar233制作
        self.play(t.animate.set_value(60*DEGREES))
        self.add(Q_BA)
        self.play(t_.animate.set_value(60*DEGREES))
        self.wait(1)
        self.remove(Q_BA,Q_AB)
        Q_ANGLE = ParametricFunction(lambda t: [cos(60 * DEGREES - t), sin(60 * DEGREES - t), 0],
                                       t_range=[0, 60 * DEGREES ], color=BLACK,
                                       stroke_width=10)
        self.add(Q_ANGLE)
        self.wait(1)
        t3 = MathTex(r"\left\langle\mathbf{W}\mathbf{a},\mathbf{W}\mathbf{b}\right\rangle\mid\left(\mathbf{P}+\mathbf{v}\right)=\left\langle\mathbf{a}\right\rangle\mid\mathbf{P}"
                     ,color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t3_1 = MathTex(r"\mathbf{W}\in\mathbf{O}\left(n\right)",color=GRAY).to_corner(UR)
        Q_A_ = Arrow([2,1,0],[2+2*cos(-30*DEGREES),1+2*sin(-30*DEGREES),0],color=RED,buff=0)
        Q_B_ = Arrow([2, 1, 0], [2 + 1.5 * cos(30 * DEGREES),1+ 1.5 * sin(30 * DEGREES),0], color=BLUE, buff=0)
        Q_P_ = Dot([2,1,0],color=BLACK)
        Q_ANGLE_ = Q_ANGLE.copy()
        self.play(Write(t3),Write(t3_1))
        self.play(ReplacementTransform(Q_A.copy(),Q_A_),ReplacementTransform(Q_B.copy(),Q_B_),ReplacementTransform(Q_P.copy(),Q_P_)
                  ,Q_ANGLE_.animate.become(Q_ANGLE_.copy().rotate_about_origin(-30*DEGREES).shift([2,1,0])))
        self.wait(1)
        t3_2 = MathTex(r"\left\langle \mathbf{b},\mathbf{a}\right\rangle= \arccos\frac{\left(\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}"
                       ,color=GRAY).next_to(t3_1,DOWN,aligned_edge=RIGHT)
        self.play(Write(t3_2))
        target_t3_2_1 = TargetBox(t3_2[0][12:17],color_=BLACK)
        target_t3_2_2 = TargetBox(t3_2[0][18:24], color_=BLACK)
        self.wait(1)
        self.play(Create(target_t3_2_1),Create(target_t3_2_2))
        self.wait(1)
        self.play(FadeOut(target_t3_2_1,target_t3_2_2,t3_2))
        tit1 = mytitle("夹角第零性质","The 0th Property of The Included Angle").to_edge(DOWN)
        target_t3 = TargetBox(t3)
        self.play(Write(tit1),Create(target_t3))
        self.wait(1)
        self.play(FadeOut(tit1,target_t3))
        self.wait(1)
        t4 = MathTex(r"\left\langle-\mathbf{a},-\mathbf{b}\right\rangle=\arccos\frac{\left(-\mathbf{a},-\mathbf{b}\right)}{\left|-\mathbf{a}\right|\left|-\mathbf{b}\right|}"
                     ,color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = MathTex(r"=\arccos\frac{\left(\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}=\left\langle\mathbf{a},\mathbf{b}\right\rangle"
                     ,color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        Q_A__ = Arrow([0,0,0],[-2,0,0],color=RED_E,buff=0)
        Q_B__ = Arrow([0, 0, 0], [-1.5*cos(60*DEGREES), -1.5*sin(60*DEGREES), 0], color=BLUE_E, buff=0)
        Q_ANGLE__ = ParametricFunction(lambda t: [-cos(60 * DEGREES - t), -sin(60 * DEGREES - t), 0],
                           t_range=[0, 60 * DEGREES], color=BLACK,
                           stroke_width=10)
        self.play(GrowArrow(Q_A__),GrowArrow(Q_B__))
        self.play(Write(Q_ANGLE__),Write(t4))
        self.play(Write(t5))
        self.wait(1)
        target_t4t5 = TargetBox(VGroup(t4,t5))
        tit2 = mytitle(r"夹角第二性质","The 2nd Property of The Included Angle").to_edge(DOWN)
        self.play(Create(target_t4t5),Write(tit2))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)

        QQ_A = Arrow([0,0,0],[2,0,0],color=RED,buff=0)
        QQ_B = Arrow([0,0,0],[1.5*cos(60*DEGREES),1.5*sin(60*DEGREES),0],color=BLUE,buff=0)
        QQ_C = Arrow([0,0,0],[1.75*cos(130*DEGREES),1.75*sin(130*DEGREES),0],color=GREEN,buff=0)
        tt1 = MathTex(r"\mathbf{a},\mathbf{b},\mathbf{c}\in\mathbf{S}^2",color=BLACK).to_corner(UL)
        tt1[0][0].set_color(RED)
        tt1[0][2].set_color(BLUE)
        tt1[0][4].set_color(GREEN)
        self.play(Write(tt1),Write_In_Group([QQ_A,QQ_B,QQ_C]))
        self.wait(1)
        tt2 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle,\left\langle\mathbf{b},\mathbf{c}\right\rangle \le \left\langle\mathbf{a},\mathbf{c}\right\rangle"
                      ,color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        self.play(Write(tt2))
        self.wait(1)
        self.play(Flash(QQ_A,color=YELLOW_E),Flash(QQ_C,color=YELLOW_E))
        self.wait(1)
        tt3 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{b},\mathbf{c}\right\rangle\le\pi",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        self.play(Write(tt3))
        self.wait(1)
        QQ_ARC = ARC(0,210*DEGREES,color=BLACK,stroke_width=10)
        self.play(Rotate(QQ_C,80*DEGREES,about_point=[0,0,0]),Write(QQ_ARC))
        self.wait(1)
        tt4 = MathTex(r"\Rightarrow \left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{b},\mathbf{c}\right\rangle=\left\langle\mathbf{a},\mathbf{c}\right\rangle"
                      ,color=RED).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4),Rotate(QQ_C,-80*DEGREES,about_point=[0,0,0]),FadeOut(QQ_ARC))
        self.wait(1)
        tt5 = mathtexgroup([r"Proof: \,\,\mathbf{a}=\left|\mathbf{a}\right|\mathbf{C}\left(0\right)"
                               ,r"\mathbf{b}=\left|\mathbf{b}\right|\mathbf{C}\left(\theta_1\right)"
                               ,r"\mathbf{c}=\left|\mathbf{c}\right|\mathbf{C}\left(\theta_2\right)"]).next_to(tt4,DOWN,aligned_edge=LEFT)
        QQ_Circle = Circle(radius = 1 ,color=BLACK)
        self.play(Write(tt5),Write(QQ_Circle))
        self.wait(1)
        tt6 = MathTex(r"0\le\theta_1\le\pi,0\le\theta_2\le 2\pi",color=BLACK).next_to(tt5,DOWN,aligned_edge=LEFT)
        self.play(Write(tt6))
        self.wait(1)
        QQ_AB = ARC(0,60*DEGREES,color=RED_E,stroke_width=10)
        tt7 = MathTex(r"\mathbf{\left\langle \mathbf{a},\mathbf{b}\right\rangle}=\theta_1",color=BLACK).next_to(tt6,DOWN,aligned_edge=LEFT)
        self.play(Write(QQ_AB),Write(tt7))
        self.wait(1)
        tt8 = tex_with_gbk([_pair("设",1),_pair(r"\theta_2 > \pi")]).next_to(tt7,DOWN,aligned_edge=LEFT)
        QQ_AC = ARC(0,210*DEGREES,radius = 0.75,color = GREEN_E,stroke_width =10)
        self.play(Write(tt8),Write(QQ_AC),Rotate(QQ_C,80*DEGREES,about_point=[0,0,0]))
        self.wait(1)
        QQ_AC_ = ARC(-150*DEGREES,0,radius=0.6,color = GREEN,stroke_width = 10)
        tt9 = MathTex(r"\left\langle\mathbf{a},\mathbf{c}\right\rangle=2\pi-\theta_2",color=BLACK).to_corner(UR)
        self.play(Write(QQ_AC_),Write(tt9))
        self.wait(1)
        tt10 = MathTex(r"\mathbf{c}=\mathbf{C}\left(\theta_2-2\pi\right)",color=BLACK).next_to(tt9,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt10))
        self.wait(1)
        g = VGroup(QQ_A,QQ_B,QQ_C,QQ_AB,QQ_AC,QQ_AC_)
        tt11 = MathTex(r"\mathbf{C}'\left(t\right)=\mathbf{C}\left(t+\theta_1\right)",color=BLACK).next_to(tt10,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt11),Rotate(g,-60*DEGREES,about_point=[0,0,0]))
        self.wait(1)
        tt12 = mathtexgroup([r"\mathbf{b}=\mathbf{C}'\left(0\right)"
                                ,r"\mathbf{a}=\mathbf{C}'\left(-\theta_1\right)"
                                ,r"\mathbf{c}=\mathbf{C}'\left(\theta_2-2\pi-\theta_1\right)"]).next_to(tt11,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt12))
        self.wait(1)
        tt13 = MathTex(r"\left|\theta_2-2\pi-\theta_1\right|",color=BLACK).next_to(tt12,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt13))
        self.wait(1)
        tt14 = MathTex(r"=2\pi-\theta_2+\theta_1=\left\langle\mathbf{a},\mathbf{c}\right\rangle+\left\langle\mathbf{a},\mathbf{b}\right\rangle",color=BLACK).next_to(tt13,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt14))
        self.wait(1)
        tt15= MathTex(r"If \left|\theta_2-2\pi-\theta_1\right|<\pi",color=BLACK).next_to(tt14,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt15),FadeOut(QQ_AC,QQ_AC_))
        self.play(Rotate(QQ_C,90*DEGREES,about_point=[0,0,0]))
        Q3_AC = ARC_V(QQ_C.get_vector(),QQ_A.get_vector(),radius = 0.75,color = GREEN,stroke_width = 10)
        self.play(Write(Q3_AC))
        self.wait(1)
        tt16 = MathTex(r"\left\langle\mathbf{b},\mathbf{c}\right\rangle = \left\langle\mathbf{a},\mathbf{c}\right\rangle+\left\langle\mathbf{a},\mathbf{b}\right\rangle"
                       ,color=BLACK).next_to(tt15,DOWN,aligned_edge=RIGHT)
        tt16_1 = MathTex(r"\left\langle\mathbf{b},\mathbf{c}\right\rangle>\left\langle\mathbf{a},\mathbf{c}\right\rangle",color=RED).next_to(tt16,DOWN,aligned_edge=RIGHT)
        Q3_BC = ARC_V(QQ_B.get_vector(),QQ_C.get_vector(),radius = 0.9,color = BLUE,stroke_width = 10)
        self.play(Write(tt16),Write(Q3_BC))
        self.wait(1)
        self.play(Write(tt16_1))
        self.wait(1)
        self.play(VGroup(tt15,tt16).animate.set_color(RED))
        self.wait(1)
        tt17 = MathTex(r"\left|\theta_2-2\pi-\theta_1\right|>pi",color=BLACK).next_to(tt14,DOWN,aligned_edge=RIGHT)
        self.play(FadeOut(tt15,tt16,tt16_1,Q3_AC,Q3_BC),Rotate(QQ_C,-90*DEGREES,about_point=[0,0,0]),Write(QQ_AC_),Write(tt17))
        Q4_BC = ARC_V(QQ_B.get_vector(),QQ_C.get_vector(),radius=0.8,color=BLUE_E,stroke_width = 10)
        tt18 = MathTex(r"\left\langle\mathbf{b},\mathbf{c}\right\rangle=2\pi-\left(2\pi-\theta_2+\theta_1\right)=\theta_2-\theta_1",color=BLACK).next_to(tt17,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt18))
        self.wait(1)
        tt19 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{b},\mathbf{c}\right\rangle=\theta_1+\theta_2-\theta_1=\theta_2>\pi"
                       ,color=RED).next_to(tt18,DOWN,aligned_edge=RIGHT)
        self.play(Write(tt19),Write(Q4_BC))
        self.wait(1)
        self.play(tt8.animate.set_color(RED))
        self.wait(1)
        self.play(FadeOut(tt8,tt9,tt10,tt11,tt12,tt13,tt14,tt17,tt18,tt19,QQ_AC_,Q4_BC),Rotate(QQ_C,-60*DEGREES,about_point=[0,0,0]))
        self.wait(1)
        tt20 = MathTex(r"\theta_2 < \pi",color=BLACK).next_to(tt7,DOWN,aligned_edge=LEFT)
        self.play(Write(tt20))
        self.wait(1)
        Q5_BC = ARC(0,90*DEGREES,radius=1,color=BLUE,stroke_width=10)
        Q5_AC = ARC(-60*DEGREES, 90 * DEGREES, radius=0.75, color=BLACK, stroke_width=10)
        tt21 = mathtexgroup([r"\left\langle\mathbf{a},\mathbf{b}\right\rangle=\theta_1",r"\left\langle\mathbf{b},\mathbf{c}\right\rangle=\theta_2-\theta_1"
                             ,r"\left\langle\mathbf{a},\mathbf{c}\right\rangle=\theta_2 = \left\langle\mathbf{a},\mathbf{c}\right\rangle+\left\langle\mathbf{b},\mathbf{c}\right\rangle"]
                            ).to_corner(UR)
        self.play(Write_In_Group([Q5_BC,Q5_AC]))
        for i in tt21:
            i.to_edge(RIGHT)
            self.play(Write(i))
            self.wait(1)

        tit3 = mytitle(r"夹角第一性质","The 1st Property of The Included Angle").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)

        self.play(FadeOut(*self.mobjects))
        self.wait(1)

        Q_P_1 = Dot([0,0,0],color=BLACK)
        Q_A_1 = Arrow([0,0,0],[1,0,0],color=RED,buff=0)
        Q_B_1 = Arrow([0,0,0],[cos(60*DEGREES),sin(60*DEGREES),0],buff=0,color=BLUE)
        Q_MA_1 = Arrow([0,0,0],[-1,0,0],buff=0,color=RED_E)
        self.play(Write_In_Group([Q_P_1,Q_A_1,Q_B_1]))
        t3t_1 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{-a},\mathbf{b}\right\rangle=\pi",color=BLACK).to_corner(UL)
        Q_AB_1 = ARC(0,60*DEGREES,radius=1,color=RED,stroke_width=10)
        Q_MAB_1 = ARC(60*DEGREES,180*DEGREES,radius=1,color=RED_E,stroke_width=10)
        Q_AMA_1 = ARC(0*DEGREES,180*DEGREES,radius=0.75,color=BLACK,stroke_width=10)
        tit4 = mytitle("夹角第三性质","The 3rd Property of The Included Angle").to_edge(DOWN)
        self.play(Write_In_Group([Q_AB_1,Q_MAB_1,Q_AMA_1,t3t_1,Q_MA_1,tit4]))
        self.wait(1)
        t3t_1_1 = MathTex(r"\forall k>0,\left\langle k\mathbf{a},\mathbf{b}\right\rangle=\left\langle \mathbf{a},\mathbf{b}\right\rangle",color=BLACK).next_to(t3t_1,DOWN,aligned_edge=LEFT)
        t3t_1_2 = mathtexgroup([r"\left\langle k\mathbf{a},\mathbf{b}\right\rangle"
                                   ,r"=\frac{\left(k\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}=\frac{k\left(\mathbf{a},\mathbf{b}\right)}{k\left|\mathbf{a}\right|\left|\mathbf{b}\right|}=\frac{\left(\mathbf{a},\mathbf{b}\right)}{\left|\mathbf{a}\right|\left|\mathbf{b}\right|}"
                                ,r"=\left\langle k\mathbf{a},\mathbf{b}\right\rangle"]).to_corner(UR).set_color(GRAY)
        for i in t3t_1_2:
            i.to_edge(RIGHT)
        self.play(Write(t3t_1_1),FadeOut(tit4))
        self.wait(1)
        self.play(Write(t3t_1_2))
        self.wait(1)
        tit5 = mytitle("夹角第四性质", "The 4th Property of The Included Angle").to_edge(DOWN)
        self.play(Write(tit5))
        self.wait(1)
        t3t_2 = MathTex(r"\left\langle\mathbf{a},-\mathbf{a}\right\rangle=\pi",color=BLACK).next_to(t3t_1_1,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_2),FadeOut(tit5,t3t_1_2))
        self.wait(1)

        Q_L1 = Line(2 * LEFT, 2 * RIGHT, color=BLACK)
        Q_L2 = Line(np.array([2*cos(60*DEGREES),2*sin(60*DEGREES),0]), -np.array([2*cos(60*DEGREES),2*sin(60*DEGREES),0]), color=BLACK)
        Q_MB_1 = Arrow([0,0,0],[-cos(60*DEGREES),-sin(60*DEGREES),0],buff=0,color=BLUE_E)
        self.play(Write(VGroup(Q_L1,Q_L2,Q_MB_1)),FadeOut(Q_AB_1,Q_MAB_1,Q_AMA_1))
        t3t_3 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle,\left\langle\mathbf{-a},\mathbf{b}\right\rangle,\left\langle\mathbf{-a},\mathbf{-b}\right\rangle,\left\langle\mathbf{a},\mathbf{-b}\right\rangle"
                        ,color=BLACK).next_to(t3t_2,DOWN,aligned_edge=LEFT)
        t3t_3[0][0:5].set_color(RED)
        t3t_3[0][6:12].set_color(BLUE)
        t3t_3[0][13:20].set_color(RED_E)
        t3t_3[0][21:].set_color(BLUE_E)
        Q_1 = ARC(0,60*DEGREES,radius=1,color = RED,stroke_width=10)
        Q_2 = ARC(60*DEGREES,180*DEGREES,radius=1,color = BLUE,stroke_width=10)
        Q_3 = ARC(180*DEGREES,240*DEGREES,radius=1,color = RED_E,stroke_width=10)
        Q_4 = ARC(240*DEGREES,360*DEGREES,radius=1,color = BLUE_E,stroke_width=10)
        self.play(Write(t3t_3),Write_In_Group([Q_1,Q_2,Q_3,Q_4]))
        self.wait(1)

        t3t_4 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{-a},\mathbf{b}\right\rangle+\left\langle\mathbf{-a},\mathbf{-b}\right\rangle+\left\langle\mathbf{a},\mathbf{-b}\right\rangle=2\pi"
                        ,color=BLACK).next_to(t3t_3,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_4))
        self.wait(1)

class s23(Scene):
    def construct(self):
        self.wait(1)
        Q_L1 = Line(2*LEFT,2*RIGHT,color=BLACK)
        Q_L2 = Line(2*UP,2*DOWN,color=BLACK)
        Q_A = Arrow([0,0,0],[1,0,0],color=RED,buff=0)
        Q_B = Arrow([0, 0, 0], [0, 1, 0], color=BLUE, buff=0)
        Q_MA = Arrow([0, 0, 0], [-1, 0, 0], color=RED_E, buff=0)
        Q_MB = Arrow([0, 0, 0], [0, -1, 0], color=BLUE_E, buff=0)
        Q_1 = ARC(0, 90 * DEGREES, radius=1, color=RED, stroke_width=10)
        Q_2 = ARC(90 * DEGREES, 180 * DEGREES, radius=1, color=BLUE, stroke_width=10)
        Q_3 = ARC(180 * DEGREES, 270 * DEGREES, radius=1, color=RED_E, stroke_width=10)
        Q_4 = ARC(270 * DEGREES, 360 * DEGREES, radius=1, color=BLUE_E, stroke_width=10)
        t0 = MathTex(r"\mathbf{L}_1\left(t\right)=t\mathbf{a}+\mathbf{P}_1",color=BLACK).to_corner(UL)
        t0_1 = MathTex(r"\mathbf{L}_2\left(t\right)=t\mathbf{b}+\mathbf{P}_2",color=BLACK).next_to(t0,DOWN,aligned_edge=LEFT)
        t1 = MathTex(r"\left\langle\mathbf{a},\mathbf{b}\right\rangle=\left\langle\mathbf{-a},\mathbf{b}\right\rangle=\left\langle\mathbf{-a},\mathbf{-b}\right\rangle=\left\langle\mathbf{a},\mathbf{-b}\right\rangle"
                     ,color=BLACK).next_to(t0_1,DOWN,aligned_edge=LEFT)
        t1[0][0:5].set_color(RED)
        t1[0][6:12].set_color(BLUE)
        t1[0][13:20].set_color(RED_E)
        t1[0][21:].set_color(BLUE_E)
        self.play(Write(t0))
        self.play(Write(t0_1))
        self.play(Write(Q_L1),Write(Q_L2),Write(VGroup(Q_A,Q_B,Q_MA,Q_MB,Q_1,Q_2,Q_3,Q_4)),Write(t1))
        self.wait(1)
        t2 = MathTex(r"=\frac{1}{4}\left(\left\langle\mathbf{a},\mathbf{b}\right\rangle+\left\langle\mathbf{-a},\mathbf{b}\right\rangle+\left\langle\mathbf{-a},\mathbf{-b}\right\rangle+\left\langle\mathbf{a},\mathbf{-b}\right\rangle\right)"
                     ,color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        t3 = MathTex(r"=\frac{1}{4}2\pi=\frac{1}{2}\pi",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        HighLight(self,t3[7:])
        tit1 = mytitle("直角","Rightangle").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        t4 = MathTex(r"\mathbf{L}_1 \perp \mathbf{L}_2",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        tit2 = mytitle("垂直","Perpendicular").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(tit2))
        t5 = MathTex(r"\mathbf{a}\perp\mathbf{b}",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\mathbf{a}\perp\mathbf{b}\Leftrightarrow\left(\mathbf{a},\mathbf{b}\right)=0",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)

class ValueTrackerVector():
    def __init__(self, items=None):
        if items is None:
            items = [0]
        self.trackers = list()
        for i in items:
            self.trackers.append(ValueTracker(i))
    def get_value(self):
        return [i.get_value() for i in self.trackers]
    def get_value_array(self):
        return np.array([i.get_value() for i in self.trackers])
    def set_value(self,item):
        n = 0
        for i in self.trackers:
            i.set_value(item[n])
            n=n+1
        return self
    def animate_set_value(self,item):
        animates = []
        n = 0
        for i in self.trackers:
            animates.append(i.animate.set_value(item[n]))
            n=n+1
        return AnimationGroup(*animates)

class s24(Scene):
    def construct(self):
        self.wait(1)
        t0 = MathTex(r"\mathbf{J}\left(\mathbf{t}\right)=\mathbf{Wt}+\mathbf{O}",color=BLACK).to_corner(UL)
        t1 = MathTex(r"\mathbf{A}\left(t\right)=\mathbf{J}\left(t\mathbf{a}+\mathbf{M}\right)",color=RED).next_to(t0,DOWN,aligned_edge=LEFT)
        t2 = MathTex(r"\mathbf{B}\left(t\right)=\mathbf{J}\left(t\mathbf{b}+\mathbf{N}\right)", color=BLUE).next_to(t1,
                                                                                                                     DOWN,
                                                                                                                     aligned_edge=LEFT)

        Q_LA = Line(0.5*UP+2*LEFT,0.5*UP+2*RIGHT,color=RED)
        Q_LB = Line(0.5 * DOWN + 2 * LEFT, 0.5 * DOWN + 2 * RIGHT, color=BLUE)
        self.play(Write_In_Group_Althernately([t0,t1,t2]))
        self.play(Write(Q_LA),Write(Q_LB))
        self.wait(1)
        self.play(Q_LA.animate.put_start_and_end_on(0.5*UP+10*LEFT,0.5*UP+10*RIGHT),
                  Q_LB.animate.put_start_and_end_on(0.5*DOWN+10*LEFT,0.5*DOWN+10*RIGHT))
        self.wait(1)
        self.play(Q_LA.animate.put_start_and_end_on(0.5*UP+2*LEFT,0.5*UP+2*RIGHT),
                  Q_LB.animate.put_start_and_end_on(0.5*DOWN+2*LEFT,0.5*DOWN+2*RIGHT))

        t3 = MathTex(r"\mathbf{A}\parallel \mathbf{B}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        tit1 = mytitle("平行","Parallel").to_corner(DOWN)
        self.play(Write(t3))
        HighLight(self,t3)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        t4 = MathTex(r"\mathbf{a}\parallel\mathbf{b}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        t5 = VGroup(MathTex(r"\mathbf{A}\left(t\right)=t\mathbf{a}+\mathbf{M},\mathbf{B}\left(t\right)=t\mathbf{b}+\mathbf{N}\in\mathbf{L}^2,\mathbf{A}\cap\mathbf{B}=\emptyset",color=BLACK)
                    ,MathTex(r"\Rightarrow\mathbf{A}\parallel\mathbf{B},\mathbf{a}\parallel\mathbf{b}",color=BLACK)).arrange(DOWN)
        self.play(Write(t5))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        tt1 = MathTex(r"\mathbf{J}\left(\mathbf{t}\right)=\mathbf{Wt}",color=BLACK).to_corner(UL)
        self.play(Write(tt1))
        self.wait(1)
        tt2 = MathTex(r"\mathbf{A}\left(t\right)=\mathbf{J}\left(\mathbf{a}t+\mathbf{M}\right)",color=RED).next_to(tt1,DOWN,aligned_edge=LEFT)
        tt3 = MathTex(r"\mathbf{B}\left(t\right)=\mathbf{J}\left(\mathbf{b}t+\mathbf{N}\right)", color=BLUE).next_to(
            tt2, DOWN, aligned_edge=LEFT)
        Tr_M = ValueTrackerVector(UP)
        Tr_N = ValueTrackerVector(DOWN)

        Q_M = always_redraw(lambda:Dot(np.array(Tr_M.get_value()),color=BLACK))
        T_M = always_redraw(lambda:MathTex(r"\mathbf{M}",color=BLACK).next_to(Q_M,DOWN))
        Q_N = always_redraw(lambda:Dot(np.array(Tr_N.get_value()),color=BLACK))
        T_N = always_redraw(lambda :MathTex(r"\mathbf{N}",color=BLACK).next_to(Q_N,UP))

        T_angle_A = ValueTracker(-15*DEGREES)
        T_angle_B = ValueTracker(15*DEGREES)

        Q_A = always_redraw(lambda:Arrow(Q_M.get_center(),Q_M.get_center()+np.array([cos(T_angle_A.get_value()),sin(T_angle_A.get_value()),0]),buff=0,color=RED_E))
        T_A = always_redraw(lambda:MathTex(r"\mathbf{a}",color=RED_E).next_to(Q_A,UP))
        Q_B = always_redraw(
            lambda: Arrow(Q_N.get_center(), Q_N.get_center()+np.array([cos(T_angle_B.get_value()), sin(T_angle_B.get_value()), 0]),
                          buff=0, color=BLUE_E))
        T_B = always_redraw(lambda: MathTex(r"\mathbf{b}", color=BLUE_E).next_to(Q_B, DOWN))
        Q_LA = always_redraw(lambda:Line(Q_M.get_center()-10*Q_A.get_vector(),Q_M.get_center()+10*Q_A.get_vector(),color=RED))
        Q_LB = always_redraw(
            lambda: Line(Q_N.get_center() - 10 * Q_B.get_vector(), Q_N.get_center() + 10 * Q_B.get_vector(), color=BLUE))
        Q_CROSS = always_redraw(lambda:Dot(
            (np.linalg.inv(np.array(
                [[cos(T_angle_A.get_value()),-cos(T_angle_B.get_value())],
                [sin(T_angle_A.get_value()),-sin(T_angle_B.get_value())]]))@(np.array([Tr_N.get_value()[0]-Tr_M.get_value()[0]
                                                                                       ,Tr_N.get_value()[1]-Tr_M.get_value()[1]])))[0]*np.array([cos(T_angle_A.get_value()),sin(T_angle_A.get_value()),0])
            +np.array(Tr_M.get_value())
            ,color=GREEN_E)
        if sin(T_angle_A.get_value()-T_angle_B.get_value())!=0 else VMobject())
        self.play(Write(VGroup(tt2,Q_M,T_M,T_A,Q_A,Q_LA)))
        self.play(Write(VGroup(tt3, Q_N, T_N,T_B,Q_B,Q_LB,Q_CROSS)))
        self.wait(1)
        tt4 = MathTex(r"\not\exists k_1,k_2,\mathbf{A}\left(k_1\right)=\mathbf{B}\left(k_2\right)\Leftrightarrow\mathbf{A}\parallel\mathbf{B}",color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4))
        self.play(T_angle_A.animate.set_value(15*DEGREES))
        self.wait(1)
        tt5 = MathTex(r"\mathbf{a}k_1-\mathbf{b}k_2=\mathbf{N}-\mathbf{M}",color=BLACK).next_to(tt4,DOWN,aligned_edge=LEFT)
        self.play(Write(tt5))
        self.wait(1)
        target_tt5_1 = TargetBox(tt5[0][0:7],color_=GRAY)
        target_tt5_2 = TargetBox(tt5[0][8:],color_=BLACK)
        self.play(Create(target_tt5_1),Create(target_tt5_2))
        Q_NMM = always_redraw(lambda:Arrow(Tr_M.get_value(),Tr_N.get_value(),color=YELLOW_E,buff=0))
        self.play(Write(Q_NMM))
        self.play(Tr_N.animate_set_value([1,-0.75,0]))
        self.play(Tr_M.animate_set_value([0.5,0.5,0]))
        self.wait(1)
        tt6 = MathTex(r"\not\exists x ,\mathbf{a}=x\mathbf{b}",color=GRAY).next_to(tt5,DOWN,aligned_edge=LEFT)
        self.play(Write(tt6))
        self.play(T_angle_A.animate.set_value(30*DEGREES))
        self.play(T_angle_B.animate.set_value(45*DEGREES))
        self.wait(1)
        self.play(Transform(tt6,MathTex(r"\exists x ,\mathbf{a}=x\mathbf{b}",color=GRAY).next_to(tt5,DOWN,aligned_edge=LEFT)))
        self.play(T_angle_B.animate.set_value(30*DEGREES))
        self.wait(1)
        tt7 = MathTex(r"\exists y,\mathbf{N}-\mathbf{M}=y\mathbf{a}",color=GRAY).next_to(tt6,DOWN,aligned_edge=LEFT)
        self.play(Write(tt7))
        self.play(Tr_M.animate_set_value([-3*cos(30*DEGREES),-3*sin(30*DEGREES),0]))
        self.play(Tr_N.animate_set_value([3*cos(30*DEGREES),3*sin(30*DEGREES),0]))
        self.wait(1)
        tt8 = MathTex(r"\mathbf{A}=\mathbf{B}",color=PURE_RED).next_to(tt7,DOWN,aligned_edge=LEFT)
        self.play(Write(tt8))
        self.wait(1)
        self.play(FadeOut(tt7,tt8))
        self.play(Tr_M.animate_set_value([0.5,0.5,0]))
        self.play(Tr_N.animate_set_value([1,-0.75,0]))
        self.wait(1)
        self.play(Transform(tt6,MathTex(r"\not\exists x ,\mathbf{a}=x\mathbf{b}",color=PURE_RED).next_to(tt5,DOWN,aligned_edge=LEFT)))
        self.play(T_angle_A.animate.set_value(30*DEGREES))
        self.play(T_angle_B.animate.set_value(-60*DEGREES))
        self.wait(1)
        nbp = NumberPlane(axis_config={"color": GRAY}
                          ,background_line_style={"stroke_color":YELLOW_E}
                          ,x_axis_config={"unit_size":1,"rotation":30*DEGREES}
                          ,y_axis_config={"unit_size":1,"rotation":-60*DEGREES}).shift(Tr_M.get_value())
        self.play(Create(nbp))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        T1 = MathTex(r"\exists x,\mathbf{a}=x\mathbf{b}\Leftrightarrow\mathbf{a}\parallel\mathbf{b}",color=BLACK)
        self.play(Write(T1))
        self.wait(1)

class s25(Scene):
    def construct(self):
        self.wait(1)
        t0 = MathTex(r"\exists \mathbf{S}^2\leftrightarrow\mathbf{V}^2",color=BLACK)
        self.play(Write(t0))
        self.wait(1)
        self.play(FadeOut(t0))
        t1 = MathTex(r"\mathbf{J}=\mathbf{V}^2",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        t2 = MathTex(r"\mathbf{L}\left(t\right)=\mathbf{v}t+\mathbf{C}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t2[0][5].set_color(RED_E)
        Q_L = Line(np.array([10*cos(85*DEGREES),10*sin(85*DEGREES),0])
                   ,-np.array([10*cos(85*DEGREES),10*sin(85*DEGREES),0]),color=BLACK,stroke_color=10)
        Q_C = Dot([0,0,0],color=BLACK)
        T_C = MathTex(r"\mathbf{C}",color=BLACK).next_to(Q_C,DL,buff=0)
        Q_V = Arrow([0,0,0],[cos(85*DEGREES),sin(85*DEGREES),0],color=RED_E,stroke_width=10,buff=0)
        T_V = MathTex(r"\mathbf{v}",color=RED_E).next_to(Q_V,UR,buff=0)
        self.play(Write(t2),Write(Q_L),Write(Q_C),Write(Q_V),Write(T_C),Write(T_V))
        self.wait(1)
        t3 = MathTex(r"\mathbf{w}\not\parallel\mathbf{v}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        t3[0][0].set_color(BLUE_E)
        Tr_W = ValueTrackerVector(RIGHT)
        Q_W = always_redraw(lambda:Arrow([0,0,0],Tr_W.get_value(),color=BLUE_E,stroke_width=10,buff=0))
        T_W = always_redraw(lambda:MathTex(r"\mathbf{w}",color=BLUE_E).next_to(Q_W,UR,buff=0))
        self.play(Write(t3))
        self.play(Write(Q_W),Write(T_W))
        self.wait(1)
        t4 = MathTex(r"\mathbf{S}_+\left(\mathbf{t}\right)=\mathbf{L}\left(t_1\right)+\mathbf{w}t_2,t_1\in\mathbb{R},t_2>0",color=BLUE_E).scale(0.8).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = MathTex(
            r"\mathbf{S}_-\left(\mathbf{t}\right)=\mathbf{L}\left(t_1\right)+\mathbf{w}t_2,t_1\in\mathbb{R},t_2<0",
            color=RED_E).scale(0.8).next_to(t4, DOWN, aligned_edge=LEFT)
        Q_SP = Surface(lambda x,y:x*np.array([cos(85*DEGREES),sin(85*DEGREES),0])+y*np.array([1,0,0]),u_range=[-10,10],v_range=[0,10],checkerboard_colors=[BLUE,BLUE_E],fill_opacity=0.2
                       ,resolution=1)
        Q_SM = Surface(
            lambda x, y: x * np.array([cos(85 * DEGREES), sin(85 * DEGREES), 0]) + y * np.array([1,0,0]),
            u_range=[-10, 10], v_range=[-10, 0], checkerboard_colors=[RED,RED_E], fill_opacity=0.2,resolution=1)
        self.play(Write(t4),Write(Q_SP))
        self.play(Write(t5),Write(Q_SM))
        self.wait(1)
        t6 = MathTex(r"\partial\mathbf{S}_+ =\partial\mathbf{S}_-=\mathbf{L} ",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\mathbf{S}_\pm\left(\mathbf{t}\right)=\mathbf{L}\left(t_1\right)+\mathbf{w}t_2,t_1,t_2\in\mathbb{R}",color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        target_1 = TargetBox(t4[0][len(t4)-5:],color_=GRAY)
        target_2 = TargetBox(t5[0][len(t5) - 5:], color_=GRAY)
        target_3 = TargetBox(t7[0][len(t7) - 5:], color_=GRAY)
        self.play(Create(target_1),Create(target_2),Create(target_3))
        self.wait(1)
        t8 = MathTex(r"\mathbf{J}=\mathbf{S}_\pm=\mathbf{S}_+\cup\mathbf{S}_-\cup\mathbf{L}",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        Q_P = Dot([3*cos(85*DEGREES),3*sin(85*DEGREES),0],color=BLACK)
        T_P = always_redraw(lambda:MathTex(r"\mathbf{p}",color=BLACK).next_to(Q_P,DR,buff=0))
        self.play(Write(Q_P))
        self.play(Write(T_P))
        self.wait(1)
        self.play(Q_P.animate.move_to([3,2,0]))
        tit1 = mytitle("侧","Side").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1))
        self.play(Q_P.animate.move_to([-3,1,0]))
        self.wait(1)
        t9 = MathTex(r"\exists \mathbf{S}^{-1}_\pm",color=BLACK).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9),FadeOut(target_1,target_2,target_3))
        self.wait(1)
        t10 = MathTex(r"\mathbf{p}=\mathbf{S}_\pm\left(t\right)=\mathbf{L}\left(t_1\right)+\mathbf{w}t_2=\mathbf{v}t_1+\mathbf{w}t_2+\mathbf{C}=\begin{bmatrix}\mathbf{v}  &\mathbf{w}\end{bmatrix}\mathbf{t}+\mathbf{C}"
                      ,color=BLACK).scale(0.8).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"\mathbf{t}=\begin{bmatrix}\mathbf{v}  &\mathbf{w}\end{bmatrix}^{-1}\left(\mathbf{p-C}\right)",color=BLACK).scale(0.8).next_to(t10,DOWN,aligned_edge=LEFT)
        self.play(Write(t11))
        self.wait(1)
        t12 = MathTex(r"\mathbf{S}^{-1}_\pm\left(\theta\right)=\begin{bmatrix}\mathbf{v}  &\mathbf{w}\end{bmatrix}^{-1}\left(\mathbf{\theta-C}\right)",color=PURE_RED).to_corner(UR)
        self.play(Write(t12))
        self.wait(1)
        self.play(FadeOut(T_P,Q_P))
        Tr_Theta = ValueTrackerVector([1,1])
        Q_Theta = always_redraw(lambda:Dot(np.array([[cos(85*DEGREES),Tr_W.get_value()[0]],[sin(85*DEGREES),Tr_W.get_value()[1]],[0,Tr_W.get_value()[2]]])@np.array(Tr_Theta.get_value()),color=BLACK))
        T_Theta = always_redraw(lambda:MathTex(r"\mathbf{\theta}",color=BLACK).next_to(Q_Theta,UR,buff=0))
        Q_Theta_on_W = always_redraw(lambda:Arrow(Tr_Theta.get_value()[0]*np.array([cos(85*DEGREES),sin(85*DEGREES),0]),
                                                       Tr_Theta.get_value()[0]*np.array([cos(85*DEGREES),sin(85*DEGREES),0])+Tr_Theta.get_value()[1]*np.array(Tr_W.get_value())
                                                  ,color=RED if Tr_Theta.get_value()[1]>0 else BLUE,buff=0,stroke_width=10))
        self.play(Write(Q_Theta))
        self.play(Write(T_Theta))
        self.play(Write(Q_Theta_on_W))
        self.wait(1)
        t13 = MathTex(r"t_2 = \begin{bmatrix}0  &1\end{bmatrix}\mathbf{S}^{-1}_\pm\left(\theta\right)",color=BLACK).next_to(t12,DOWN,aligned_edge=RIGHT)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}=\begin{bmatrix}0  &1\end{bmatrix}\mathbf{S}^{-1}_\pm\left(\theta\right)",color=BLACK).next_to(t13,DOWN,aligned_edge=RIGHT)
        t14_1 = MathTex(r"=\begin{bmatrix}0  &1\end{bmatrix}\begin{bmatrix}\mathbf{v}  &\mathbf{w}\end{bmatrix}^{-1}\left(\mathbf{\theta-C}\right)",color=BLACK).next_to(t14,DOWN,aligned_edge=RIGHT)
        self.play(Write(t14))
        self.play(Write(t14_1))
        self.wait(1)
        t15 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}>0\Leftrightarrow\mathbf{\theta}\in\mathbf{S}_+",color=BLACK).next_to(t14_1,DOWN,aligned_edge=RIGHT)
        self.play(Write(t15))
        self.play(Tr_Theta.animate_set_value([3,2]))
        self.wait(1)
        t16 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}<0\Leftrightarrow\mathbf{\theta}\in\mathbf{S}_-",
                      color=BLACK).next_to(t15, DOWN, aligned_edge=RIGHT)
        self.play(Write(t16))
        self.play(Tr_Theta.animate_set_value([2,-2.5]))
        self.wait(1)
        Tr_Phi = ValueTrackerVector([1,1])
        Q_Phi = always_redraw(lambda: Dot(np.array(
            [[cos(85 * DEGREES), Tr_W.get_value()[0]], [sin(85 * DEGREES), Tr_W.get_value()[1]],
             [0, Tr_W.get_value()[2]]]) @ np.array(Tr_Phi.get_value()), color=BLACK))
        T_Phi = always_redraw(lambda: MathTex(r"\mathbf{\phi}", color=BLACK).next_to(Q_Phi, UR, buff=0))
        Q_Phi_on_W = always_redraw(
            lambda: Arrow(Tr_Phi.get_value()[0] * np.array([cos(85 * DEGREES), sin(85 * DEGREES), 0]),
                          Tr_Phi.get_value()[0] * np.array([cos(85 * DEGREES), sin(85 * DEGREES), 0]) +
                          Tr_Phi.get_value()[1] * np.array(Tr_W.get_value())
                          , color=RED if Tr_Phi.get_value()[1] > 0 else BLUE, buff=0, stroke_width=10))
        self.play(Write(Q_Phi))
        self.play(Write(T_Phi))
        self.play(Write(Q_Phi_on_W))
        self.wait(1)
        t17 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\phi}}",color=BLACK).next_to(t16,DOWN,aligned_edge=RIGHT)
        self.play(Write(t17))
        self.wait(1)
        self.play(Tr_Theta.animate_set_value([1.5,1.5]))
        tit2 = mytitle("同侧","Same Sides").to_edge(DOWN)
        t18 = MathTex(r"1)\,\,\frac{\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}}{\Delta_{\mathbf{L},\mathbf{w},\mathbf{\phi}}}>0",color=BLACK).scale(0.8).next_to(t17,DOWN,aligned_edge=RIGHT)
        self.play(Write(tit2))
        self.wait(1)
        self.play(Write(t18),FadeOut(tit2))
        self.wait(1)
        self.play(Tr_Phi.animate_set_value([2,-1]))
        tit3 = mytitle("异侧", "Different Sides").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)
        t19 = MathTex(
            r"2)\,\,\frac{\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}}{\Delta_{\mathbf{L},\mathbf{w},\mathbf{\phi}}}<0",
            color=BLACK).scale(0.8).next_to(t18, DOWN, aligned_edge=RIGHT)
        self.play(Write(t19),FadeOut(tit3))
        self.wait(1)
        _Q_Theta = Dot(Q_Theta.get_center(),color=BLACK)
        _Q_Phi = Dot(Q_Phi.get_center(), color=BLACK)
        _T_Theta = MathTex(r"\mathbf{\theta}",color=BLACK).next_to(_Q_Theta,UR,buff=0)
        _T_Phi = MathTex(r"\mathbf{\phi}", color=BLACK).next_to(_Q_Phi, UR, buff=0)
        _Q_Theta_on_W = always_redraw(
            lambda: Arrow((np.linalg.inv(np.array([[cos(85*DEGREES),Tr_W.get_value()[0],0],[sin(85*DEGREES),Tr_W.get_value()[1],0],[0,Tr_W.get_value()[2],1]]))@_Q_Theta.get_center())[0]*np.array([cos(85 * DEGREES), sin(85 * DEGREES), 0]),
                            _Q_Theta.get_center()
                          , color=RED if (np.linalg.inv(np.array([[cos(85*DEGREES),Tr_W.get_value()[0],0],[sin(85*DEGREES),Tr_W.get_value()[1],0],[0,Tr_W.get_value()[2],1]]))@_Q_Theta.get_center())[1] > 0 else BLUE, buff=0, stroke_width=10))
        _Q_Phi_on_W = always_redraw(
            lambda: Arrow((np.linalg.inv(np.array(
                [[cos(85*DEGREES),Tr_W.get_value()[0],0],[sin(85*DEGREES),Tr_W.get_value()[1],0],[0,Tr_W.get_value()[2],1]])) @ _Q_Phi.get_center())[0] * np.array(
                [cos(85 * DEGREES), sin(85 * DEGREES), 0]),
                          _Q_Phi.get_center()
                          , color=RED if (np.linalg.inv(np.array([[cos(85*DEGREES),Tr_W.get_value()[0],0],[sin(85*DEGREES),Tr_W.get_value()[1],0],[0,Tr_W.get_value()[2],1]]))@_Q_Phi.get_center())[1] > 0 else BLUE,
                          buff=0, stroke_width=10))
        self.remove(Q_Phi,Q_Phi_on_W,T_Phi,Q_Theta,Q_Theta_on_W,T_Theta)
        self.add(_Q_Phi,_Q_Phi_on_W,_T_Phi,_Q_Theta,_Q_Theta_on_W,_T_Theta)
        self.play(Tr_W.animate_set_value(RIGHT+DOWN))
        self.wait(1)
        self.play(Tr_W.animate_set_value(LEFT + DOWN))
        self.wait(1)
        HighLight(self,t14[0][:6])
        tit4 = mytitle("侧向判别","Discriminant of Straightline Sides").to_edge(DOWN)
        self.play(Write(tit4))
        self.wait(1)

def _Cross(a,M,b,N):
    matrix = np.linalg.inv(np.array([[a[0],b[0],0],[a[1],b[1],0],[a[2],b[2],1]]))
    k = matrix@(N-M)
    return a*k[0]+M

class s25_1(Scene):
    def construct(self):
        self.wait(1)
        Q_L = Line(np.array([10 * cos(85 * DEGREES), 10 * sin(85 * DEGREES), 0])
                   , -np.array([10 * cos(85 * DEGREES), 10 * sin(85 * DEGREES), 0]), color=BLACK)
        Q_C = Dot([0, 0, 0], color=BLACK)
        T_C = MathTex(r"\mathbf{C}", color=BLACK).next_to(Q_C, DL, buff=0)
        Q_V = Arrow([0, 0, 0], [cos(85 * DEGREES), sin(85 * DEGREES), 0], color=RED_E, stroke_width=10, buff=0)
        T_V = MathTex(r"\mathbf{v}", color=RED_E).next_to(Q_V, UR, buff=0)
        t0 = MathTex(r"\mathbf{J}=\mathbf{V}^2",color=BLACK).to_corner(UL)
        t1 = MathTex(r"\mathbf{L}\left(t\right)=\mathbf{v}t+\mathbf{C}",color=BLACK).next_to(t0,DOWN,aligned_edge=LEFT)
        self.play(Write(t0))
        self.play(Write(t1))
        self.play(Write(VGroup(Q_L,Q_C,T_C,Q_V,T_V)))
        t2 = MathTex(r"\mathbf{w}\not\parallel\mathbf{v}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        Q_W = Arrow([0,0,0],[1,0,0],color=BLUE_E,buff=0)
        T_W = MathTex(r"\mathbf{w}",color=BLUE_E).next_to(Q_W,DR,buff=0)
        self.play(Write(Q_W),Write(T_W))
        self.wait(1)
        Q_Theta = Arrow([0,0,0],[2*cos(85 * DEGREES)+2,2*sin(85 * DEGREES),0],color=GREEN_E,buff=0)
        t3 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}+k\mathbf{v}}=\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(Q_Theta))
        Q_Theta_P_KV = Arrow([0,0,0],[2+4*cos(85 * DEGREES),4*sin(85 * DEGREES),0],color=GREEN,buff=0)
        Q_KV = Arrow([2*cos(85 * DEGREES)+2,2*sin(85 * DEGREES),0],[4*cos(85 * DEGREES)+2,4*sin(85 * DEGREES),0],color = RED,buff=0)

        self.play(GrowArrow(Q_KV))
        self.play(FadeIn(Q_Theta_P_KV))
        self.play(Write(t3))
        self.wait(1)
        t3_1 = mathtexgroup([r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}+k\mathbf{v}}=\left[\begin{matrix}0&1\\\end{matrix}\right]\left[\begin{matrix}\mathbf{v}&\mathbf{w}\\\end{matrix}\right]^{-1}\left(\mathbf{\theta}+k\mathbf{v}-\mathbf{C}\right)"
                             ,r"=\left[\begin{matrix}0&1\\\end{matrix}\right]\left[\begin{matrix}\mathbf{v}&\mathbf{w}\\\end{matrix}\right]^{-1}\left(\mathbf{\theta}-\mathbf{C}\right)+\left[\begin{matrix}0&1\\\end{matrix}\right]\left[\begin{matrix}\mathbf{v}&\mathbf{w}\\\end{matrix}\right]^{-1}k\mathbf{v}"
                             ,r"=\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}+\left[\begin{matrix}0&1\\\end{matrix}\right]\left[\begin{matrix}\mathbf{v}&\mathbf{w}\\\end{matrix}\right]^{-1}k\mathbf{v}"
                             ]).scale(0.5).set_color(GRAY).to_corner(UR)
        for i in t3_1:
            i.to_edge(RIGHT)
        self.play(Write(t3_1))
        self.wait(1)
        self.play(FadeOut(t3_1))
        nbp = NumberPlane(axis_config={"color": GRAY}
                          ,background_line_style={"stroke_color":YELLOW_E}
                          ,x_axis_config={"unit_size":1,"rotation":0*DEGREES}
                          ,y_axis_config={"unit_size":1,"rotation":85*DEGREES})
        self.play(Create(nbp))
        self.wait(1)
        t4 = MathTex(r"\mathbf{X},\mathbf{Y}\in\mathbf{L}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        t5 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}+\mathbf{X}}=\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}+\mathbf{Y}}",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\mathbf{X}=\mathbf{Y}+k\mathbf{v}",color=GRAY).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        tit1 = mytitle("侧向判别第一引理","The 1st Lemma of Discriminant of Straightline Sides").scale(0.5).to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)

        self.play(FadeOut(tit1))
        t7 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}>0\Leftrightarrow\frac{\Delta_{\mathbf{L},\mathbf{w},\mathbf{\theta}}}{\Delta_{\mathbf{L},\mathbf{w},\mathbf{w+C}}}"
                     ,color=BLACK).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        t7_1 = MathTex(r"\Delta_{\mathbf{L},\mathbf{w},\mathbf{w+C}}=\begin{bmatrix} 0 &1\end{bmatrix}\begin{bmatrix} \mathbf{v} &\mathbf{w}\end{bmatrix}^{-1}\mathbf{w}=1>0"
                       ,color=GRAY).scale(0.5).to_corner(UR)
        self.play(Write(t7_1))
        self.wait(1)
        tit2 = mytitle("侧向判别第二引理","The 2nt Lemma of Discriminant of Straightline Sides").scale(0.5).to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)

        self.play(FadeOut(t7_1,tit2))
        t8 = MathTex(r"1)\,\,\Delta_{\mathbf{L},\mathbf{w},k\mathbf{\theta}+\mathbf{C}}=k\Delta_{\mathbf{L},\mathbf{w},k\mathbf{\theta}+\mathbf{C}}",color=BLACK).next_to(t7,DOWN,aligned_edge=LEFT)
        t9 = MathTex(
            r"2)\Delta_{\mathbf{L},\mathbf{w},k\mathbf{\phi}}>0,\Delta_{\mathbf{L},\mathbf{w},k\mathbf{\theta}+\mathbf{C}}>0,\Delta_{\mathbf{L},\mathbf{w},\phi+k\mathbf{\theta}}>0",
            color=BLACK).next_to(t8, DOWN, aligned_edge=LEFT)
        self.play(Write(t8))
        self.play(Q_Theta.animate.put_start_and_end_on([0,0,0],[4*cos(85*DEGREES)+4,4*sin(85*DEGREES),0]))
        self.wait(1)
        self.play(Write(t9))
        Q_PHI = Dot([cos(85*DEGREES)+3,sin(85*DEGREES),0],color=BLACK)
        T_PHI = MathTex(r"\mathbf{\phi}",color=BLACK).next_to(Q_PHI,DR)
        Q_KTHETA = Arrow([cos(85*DEGREES)+3,sin(85*DEGREES),0],[3*cos(85*DEGREES)+5,3*sin(85*DEGREES),0],color=GREEN,buff=0)
        self.play(Write(Q_PHI),Write(T_PHI))
        self.play(GrowArrow(Q_KTHETA))
        self.wait(1)
        tit3 = mytitle("侧向判别第三引理","The 3rd Lemma of Discriminant of Straightline Sides").scale(0.5).next_to(t8,RIGHT)
        self.play(Write(tit3))
        self.wait(1)

        self.add(Q_L,Q_C,T_C,Q_V,T_V)

        allthethings = [*self.mobjects]
        allthethings.remove(Q_L)
        allthethings.remove(T_V)##中子星NeutronStar233制作
        allthethings.remove(Q_V)
        allthethings.remove(Q_W)
        allthethings.remove(T_W)
        allthethings.remove(Q_C)
        allthethings.remove(T_C)
        allthethings.remove(t0)
        allthethings.remove(t1)
        self.play(FadeOut(*allthethings))
        self.wait(1)

        h = np.array([cos(15*DEGREES),sin(15*DEGREES),0])
        v = np.array([cos(85*DEGREES),sin(85*DEGREES),0])
        Q_H = Line(10*h+np.array(2*DOWN),-10*h+np.array(2*DOWN),color=YELLOW_E)
        tt1 = MathTex(r"\mathbf{H}\left(t\right)=\mathbf{h}t+\mathbf{Q}",color=YELLOW_E).next_to(t1,DOWN,aligned_edge=LEFT)
        tt2 = MathTex(r"\mathbf{h}\not\parallel \mathbf{v}",color=BLACK).next_to(tt1,DOWN,aligned_edge=LEFT)
        self.play(Write(tt1))
        self.play(Write(tt2))
        self.play(Write(Q_H))
        self.wait(1)
        tt3 = MathTex(r"\mathbf{H}\left(u_1\right)=\mathbf{L}\left(u_2\right)",color=BLACK).next_to(tt2,DOWN,aligned_edge=LEFT)
        Q_Cross = Dot(_Cross(h,2*DOWN,v,np.array([0,0,0])),color=PURE_RED)
        self.play(Write(tt3),Write(Q_Cross))
        self.wait(1)

        Q_H_UPX = Dot(2*h+Q_Cross.get_center(),color=BLACK)
        T_H_UPX = MathTex(r"\mathbf{H}\left(u_1+x\right)",color=BLACK).scale(0.5).next_to(Q_H_UPX,DOWN)
        Q_H_UMX = Dot(-2 * h + Q_Cross.get_center(), color=BLACK)
        T_H_UMX = MathTex(r"\mathbf{H}\left(u_1-x\right)", color=BLACK).scale(0.5).next_to(Q_H_UMX, UP)

        tt4 = MathTex(r"\Rightarrow \forall x\not=0,\frac{\Delta_{\mathbf{L},\mathbf{w},\mathbf{H}\left(u_1+x\right)}}{\Delta_{\mathbf{L},\mathbf{w},\mathbf{H}\left(u_1-x\right)}}<0"
                      ,color=BLACK).next_to(tt3,DOWN,aligned_edge=LEFT)
        self.play(Write(tt4))
        self.play(Write_In_Group([Q_H_UPX,T_H_UPX,Q_H_UMX,T_H_UMX]))
        self.wait(1)
        tt5 = MathTex(r"Proof:\,\,\Delta_{\mathbf{L},\mathbf{H}\left(u_1+x\right)-\mathbf{H}\left(u_1\right),\mathbf{H}\left(u_1-x\right)}<0",color=BLACK).next_to(tt4,DOWN,aligned_edge=LEFT)
        self.play(Write(tt5))
        self.wait(1)
        tt5_1 = mathtexgroup([r"\Delta_{\mathbf{L},\mathbf{H}\left(u_1+x\right)-\mathbf{H}\left(u_1\right),\mathbf{H}\left(u_1-x\right)}"
                              ,r"=\begin{bmatrix}0 &1\end{bmatrix}\begin{bmatrix}\mathbf{v}&\mathbf{H}\left(u_1-x\right)-\mathbf{H}\left(u_1\right)\end{bmatrix}\left(\mathbf{H}\left(u_1+x\right)-\mathbf{H}\left(u_1\right)\right)"
                              ,r"=\begin{bmatrix}0 &1\end{bmatrix}\begin{bmatrix}\mathbf{v}&x\mathbf{h}\end{bmatrix}\left(-x\mathbf{h}\right)"
                              ,r"=-1<0"]).set_color(GRAY).scale(0.5).to_corner(UL)
        for i in tt5_1:
            i.to_edge(RIGHT)
        self.play(Write(tt5_1))
        self.wait(1)
        tit4 = mytitle("侧向判别第四引理","The 4th Lemma of Discriminant of Straightline Sides").scale(0.5).to_edge(DOWN)
        self.play(Write(tit4))
        self.wait(1)

        self.play(FadeOut(*self.mobjects))
        self.wait(1)

        t3t_1 = MathTex(r"\text{sgn} \,x",color=BLACK).to_corner(UL)
        self.play(Write(t3t_1))
        t_ps = Text("是sign，不是sin！！！",color=GRAY).scale(0.5).to_corner(DR)
        self.play(Write(t_ps))
        self.wait(1)
        self.play(FadeOut(t_ps))
        t3t_2 = MathTex(r"\begin{cases}\text{sgn}\,x=1,x>0 \\ \text{sgn}\,x=0,x=0\\ \text{sgn}\,x=-1,x<0\end{cases}",color=BLACK).next_to(t3t_1,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_2))
        self.wait(1)

        t3t_3 = MathTex(r"1)\,\,\text{sgn}\,\Delta_{\mathbf{L},\mathbf{m},\mathbf{n}+\mathbf{C}}=\text{sgn}\,\Delta_{\mathbf{L},\mathbf{n},\mathbf{m}+\mathbf{C}}"
                        ,color=BLACK).next_to(t3t_2,DOWN,aligned_edge=LEFT)
        t3t_4 = MathTex(
            r"2)\,\,\text{sgn}\,\Delta_{\mathbf{L},\mathbf{m},\mathbf{n}+\mathbf{C}}=\text{sgn}\,\Delta_{\mathbf{L},\mathbf{m},\mathbf{u}+\mathbf{C}}\not=0"
            , color=BLACK).next_to(t3t_3, DOWN, aligned_edge=LEFT)
        t3t_4_1 = MathTex(r"\Rightarrow\text{sgn}\,\Delta_{\mathbf{L},\mathbf{n},\mathbf{u}+\mathbf{C}}=1",color=BLACK).next_to(t3t_4,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_3))
        self.play(Write(t3t_4))
        self.play(Write(t3t_4_1))
        self.wait(1)
        t3t_3_ps = Text("m+C和n+C的同侧性与n+C和m+C的同侧性一致",color=GRAY).scale(0.5).next_to(t3t_3,RIGHT)
        proof1 = MathTex(r"Proof\,1)\,\,\text{sgn}\,\Delta_{\mathbf{L},\mathbf{m},\mathbf{n}+\mathbf{C}}=\text{sgn}\,\frac{\Delta_{\mathbf{L},\mathbf{m},\mathbf{n}+\mathbf{C}}}{\Delta_{\mathbf{L},\mathbf{m},\mathbf{m}+\mathbf{C}}}=\text{sgn}\,\frac{\Delta_{\mathbf{L},\mathbf{n},\mathbf{n}+\mathbf{C}}}{\Delta_{\mathbf{L},\mathbf{n},\mathbf{m}+\mathbf{C}}}=\text{sgn}\,\frac{\Delta_{\mathbf{L},\mathbf{n},\mathbf{m}+\mathbf{C}}}{\Delta_{\mathbf{L},\mathbf{n},\mathbf{n}+\mathbf{C}}}=\text{sgn}\,\Delta_{\mathbf{L},\mathbf{n},\mathbf{m}+\mathbf{C}}"
                         ,color=GRAY).scale(0.5).next_to(t3t_4_1,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_3_ps))
        self.play(Write(proof1))
        self.wait(1)
        t3t_4_1_ps = Text("若n、u与m的同侧向都分别相等，那么n、u同侧", color=GRAY).scale(0.5).next_to(t3t_4_1, RIGHT)
        proof2 = MathTex(r"Proof\,2)\,\,\text{sgn}\,\Delta_{\mathbf{L},\mathbf{n},\mathbf{u}+\mathbf{C}}=\frac{\Delta_{\mathbf{L},\mathbf{n},\mathbf{u}+\mathbf{C}}}{\Delta_{\mathbf{L},\mathbf{n},\mathbf{n}+\mathbf{C}}}=\frac{\Delta_{\mathbf{L},\mathbf{m},\mathbf{u}+\mathbf{C}}}{\Delta_{\mathbf{L},\mathbf{m},\mathbf{n}+\mathbf{C}}}=1"
                         ,color=GRAY).scale(0.5).next_to(proof1,DOWN,aligned_edge=LEFT)
        self.play(Write(t3t_4_1_ps))
        self.play(Write(proof2))
        self.wait(1)


class s25_2(Scene):
    def construct(self):
        self.wait(1)
        _t1 = MathTex(r"\mathbf{a}_{UNIT}=\frac{\mathbf{a}}{\left|\mathbf{a}\right|}",color=BLACK).to_corner(UL)
        self.play(Write(_t1))
        self.wait(1)
        _t2 = MathTex(r"\Delta_{\mathbf{L},\mathbf{a}_{UNIT},\mathbf{b}_{UNIT}+\mathbf{C}}=\Delta_{\mathbf{L},\mathbf{a},\mathbf{b}+\mathbf{C}}",color=BLACK).next_to(_t1,DOWN,aligned_edge=LEFT)
        self.play(Write(_t2))
        self.wait(1)
        self.play(FadeOut(_t1,_t2))
        self.wait(1)

        scaler = 0.75

        t1 = MathTex(r"\mathbf{L}\left(t\right)=\mathbf{v}t+\mathbf{C}",color=BLACK).scale(scaler).to_corner(UL)
        t2 = MathTex(r"\Delta_{\mathbf{L},\mathbf{\beta},\mathbf{\gamma}+\mathbf{C}}>0",color=BLACK).scale(scaler).next_to(t1,DOWN,aligned_edge=LEFT)
        t3 = MathTex(r"\Delta_{\overline{\mathbf{\beta+C},\mathbf{C}} ,\mathbf{v},\mathbf{\gamma}+\mathbf{C}}<0",color=BLACK).scale(scaler).next_to(t2,DOWN,aligned_edge=LEFT)

        v = np.array([cos(85*DEGREES),sin(85*DEGREES),0])##RED
        beta = np.array([cos(10*DEGREES),sin(10*DEGREES),0])##BLUE
        gamma = np.array([cos(-45*DEGREES),sin(-45*DEGREES),0])##GREEN

        Q_C = Dot([0,0,0],color=BLACK)
        T_C = MathTex(r"\mathbf{C}",color=BLACK).next_to(Q_C,DL,buff=0)
        Q_V = Arrow([0,0,0],v,color=RED,buff=0)
        T_V = MathTex(r"\mathbf{v}",color=RED).next_to(Q_V,UL,buff=0)
        Q_Beta = Arrow([0, 0, 0], beta, color=BLUE, buff=0)
        T_Beta = MathTex(r"\mathbf{\beta}", color=BLUE).next_to(Q_Beta, UR, buff=0)
        Q_Gamma = Arrow([0, 0, 0], gamma, color=GREEN, buff=0)
        T_Gamma = MathTex(r"\mathbf{\gamma}", color=GREEN).next_to(Q_Gamma, DR, buff=0)

        Q_L = DashedLine(-10*v,10*v,color=RED_E)
        Q_K = DashedLine(-10 * beta, 10 * beta, color=BLUE_E)

        self.play(Write(t1))
        self.play(Write(Q_C),Write(T_C))
        self.play(Write(Q_V),Write(T_V))
        self.play(Write(Q_L))
        self.wait(1)
        self.play(Write(t2))
        self.play(Write(Q_Beta),Write(Q_Gamma),Write(T_Beta),Write(T_Gamma))
        self.play(Flash(Q_Beta),Flash(Q_Gamma))
        self.wait(1)
        self.play(Write(t3))
        self.play(Write(Q_K))
        self.play(Flash(Q_V),Flash(Q_Gamma))
        self.wait(1)

        t4 = MathTex(r"\Rightarrow\left\langle\mathbf{v},\mathbf{\beta}\right\rangle+\left\langle\mathbf{\beta},\mathbf{\gamma}\right\rangle=\left\langle\mathbf{v},\mathbf{\gamma}\right\rangle"
                     ,color=BLACK).scale(scaler).next_to(t3,DOWN,aligned_edge=LEFT)

        Q_VB = ARC_V(v,beta,radius=1,color = RED,stroke_width=10)
        Q_BG = ARC_V(beta, gamma,radius=1, color=BLUE,stroke_width=10)
        Q_VG = ARC_V(v,gamma,radius=0.8,color=GREEN,stroke_width=10)

        self.play(Write(t4))
        self.play(Write(Q_VB),Write(Q_BG))
        self.play(Write(Q_VG))
        self.wait(1)

        t2_ps = tex_with_gbk([_pair("夹角不能大于",1),_pair(r"\pi")]).set_color(GRAY).scale(0.5).next_to(t2,RIGHT)
        t3_ps = Text("......两侧").set_color(GRAY).scale(0.5).next_to(t3, RIGHT)
        self.play(Write(t2_ps))
        self.wait(1)
        self.play(Write(t3_ps))
        self.wait(1)

        t5 = MathTex(r"Proof:\,\,\mathbf{K}=\overline{\mathbf{\beta+C},\mathbf{C}}",color=BLACK).scale(scaler).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\mathbf{K}\left(t\right)=\mathbf{\beta}t+\mathbf{C}",color=BLACK).scale(scaler).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)

        t7 = MathTex(r"\mathbf{\xi}\perp\mathbf{v},\left|\mathbf{\xi}\right|=1,\Delta_{\mathbf{L},\mathbf{\beta},\mathbf{\xi+C}}>0",color=BLACK).scale(scaler).next_to(t6,DOWN,aligned_edge=LEFT)

        xi = np.array([cos(-5*DEGREES),sin(-5*DEGREES),0])
        Q_Xi = Arrow([0,0,0],xi,color=RED_E,buff=0)
        T_Xi = MathTex(r"\mathbf{\xi}",color=RED_E).next_to(Q_Xi,RIGHT,buff=0)
        Q_RA_Xi = RightAngle(Line([0,0,0],v),Line([0,0,0],xi),color=PURE_RED,length=0.2)
        self.play(Write(t7))
        self.play(Write(Q_Xi),Write(T_Xi),Write(Q_RA_Xi))
        self.wait(1)

        t8 = MathTex(r"\mathbf{G}\left(t\right)=\begin{bmatrix} \mathbf{v} &\mathbf{\xi}\end{bmatrix}\begin{bmatrix}  \cos t \\  \sin t\end{bmatrix}+\mathbf{C}"
                     ,color=BLACK).scale(scaler).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        self.wait(1)
        t9 = MathTex(r"\mathbf{v}_{UNIT}+\mathbf{C},\mathbf{\beta}_{UNIT}+\mathbf{C},\mathbf{\gamma}_{UNIT}+\mathbf{C}\in\mathbf{G}",color=BLACK).scale(scaler).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        self.play(Transform(T_V,MathTex(r"\mathbf{v}_{UNIT}",color=RED).next_to(Q_V,UL,buff=0)),
        Transform(T_Beta, MathTex(r"\mathbf{\beta}_{UNIT}", color=BLUE).next_to(Q_Beta, UR, buff=0)),
        Transform(T_Gamma, MathTex(r"\mathbf{\gamma}_{UNIT}", color=GREEN).next_to(Q_Gamma, DR, buff=0)))
        self.wait(1)

        t10 = MathTex(r"\mathbf{v}_{UNIT}+\mathbf{C}=\mathbf{G}\left(t_v\right),\mathbf{\beta}_{UNIT}+\mathbf{C}=\mathbf{G}\left(t_\beta\right),\mathbf{\gamma}_{UNIT}+\mathbf{C}=\mathbf{G}\left(t_\gamma\right)"
                      ,color=BLACK).scale(scaler).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(Write(t10))
        self.wait(1)

        t11 = MathTex(r"t_v,t_\beta,t_\gamma \in\left[0,2\pi\right)",color=BLACK).scale(scaler).next_to(t10,DOWN,aligned_edge=LEFT)
        self.play(Write(t11))
        self.wait(1)

        t12 = MathTex(r"\Delta_{\mathbf{L},\mathbf{\xi},\mathbf{\beta+C}}>0,\Delta_{\mathbf{L},\mathbf{\gamma},\mathbf{\beta+C}}>0",color=BLACK).scale(scaler).to_corner(UR)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"\Rightarrow\Delta_{\mathbf{L},\mathbf{\xi},\mathbf{\gamma}}>0,\Delta_{\mathbf{L},\mathbf{\xi},\mathbf{\gamma_{UNIT}}}>0",color=BLACK).scale(scaler).next_to(t12,DOWN,aligned_edge=RIGHT)
        self.play(Write(t13))
        self.wait(1)

        t14 = MathTex(r"\mathbf{\gamma}_{UNIT}=\mathbf{G}\left(t_\gamma\right)-\mathbf{C}=\begin{bmatrix}  \mathbf{v}&\mathbf{\xi}\end{bmatrix}\begin{bmatrix}\cos t \\\sin t\end{bmatrix}=\cos t_\gamma \mathbf{v}+\sin t_\gamma \mathbf{\xi}"
                      ,color=BLACK).scale(scaler).next_to(t13,DOWN,aligned_edge=RIGHT)
        self.play(Write(t14))
        self.wait(1)
        t15 = MathTex(r"\sin t_\gamma >0",color=BLACK).scale(scaler).next_to(t14,DOWN,aligned_edge=RIGHT)
        self.play(Write(t15))
        self.wait(1)
        HighLight(self,t11)
        t16 = MathTex(r"t_\gamma \in \left(0,\pi\right)",color=BLACK).scale(scaler).next_to(t15,DOWN,aligned_edge=RIGHT)
        self.play(Write(t16))
        self.wait(1)
        t17 = MathTex(r"\sin t_\beta >0,t_\beta\in\left(0,2\pi\right),t_\beta\in\left(0,\pi\right)",color=BLACK).scale(scaler).next_to(t16,DOWN,aligned_edge=RIGHT)
        self.play(Write(t17))
        self.wait(1)

        t18 = MathTex(r"\mathbf{\xi+C}=\mathbf{G}\left(t_\xi\right),t_\xi=\frac{1}{2}\pi,t_v=0",color=BLACK).scale(scaler).next_to(t17,DOWN,aligned_edge=RIGHT)
        self.play(Write(t18))
        self.wait(1)

        t19 = MathTex(r"\mathbf{\delta+C}=\mathbf{G}\left(t_\beta+\frac{1}{2}\pi\right),t_\delta=t_\beta+\frac{1}{2}\pi",color=BLACK).scale(scaler).next_to(t18,DOWN,aligned_edge=RIGHT)
        delta = np.array([cos(-80*DEGREES),sin(-80*DEGREES),0])
        Q_Delta = Arrow([0,0,0],delta,color=BLUE_E,buff=0)
        T_Delta = MathTex(r"\mathbf{\delta}",color=BLUE_E).next_to(Q_Delta,DOWN,buff=0)
        Q_RA_Delta = RightAngle(Line([0,0,0],beta),Line([0,0,0],delta),color=PURE_BLUE,length=0.2)
        self.play(Write(t19))
        self.play(Write(Q_Delta),Write(T_Delta),Write(Q_RA_Delta))
        self.wait(1)

        self.play(FadeOut(t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t2_ps,t3_ps))
        self.wait(1)
        t20 = MathTex(r"\begin{bmatrix}\mathbf{\beta}_{UNIT}  &\mathbf{\delta}\end{bmatrix}=\begin{bmatrix}\cos t_\beta  & \cos \left(t_\beta+\frac{1}{2}\pi\right) \\ \sin t_\beta&\sin\left(t_\beta+\frac{1}{2}\pi\right)\end{bmatrix}"
                      ,color=BLACK).scale(scaler).to_corner(UL)
        t21 = MathTex(r"=\begin{bmatrix}\cos t_\beta  & -\sin\left(t_\beta\right) \\ \sin t_\beta&\cos\left(t_\beta+\frac{1}{2}\pi\right)\end{bmatrix}",color=BLACK).scale(scaler).next_to(t20,DOWN,aligned_edge=LEFT)
        graphs = VGroup(Q_C,T_C,Q_V,T_V,Q_Beta,T_Beta,Q_Gamma,T_Gamma,Q_L,Q_K,Q_Delta,T_Delta,Q_Xi,T_Xi,Q_RA_Delta,Q_RA_Xi,Q_VB,Q_VG,Q_BG).copy()
        self.play(VGroup(Q_C,T_C,Q_V,T_V,Q_Beta,T_Beta,Q_Gamma,T_Gamma,Q_L,Q_K,Q_Delta,T_Delta,Q_Xi,T_Xi,Q_RA_Delta,Q_RA_Xi,Q_VB,Q_VG,Q_BG).animate.become(
            VGroup(Q_C, T_C, Q_V, T_V, Q_Beta, T_Beta, Q_Gamma, T_Gamma, Q_L, Q_K, Q_Delta, T_Delta, Q_Xi, T_Xi,
                   Q_RA_Delta, Q_RA_Xi, Q_VB, Q_VG, Q_BG).copy().shift(4*RIGHT+UP).fade(0.8)
        ))
        self.play(Write(t20))
        self.play(Write(t21))
        self.wait(1)
        t22 = MathTex(r"\Delta_{\mathbf{K},\mathbf{\delta},\mathbf{v}_{UNIT}+\mathbf{C}}=\begin{bmatrix}0  &1\end{bmatrix}\begin{bmatrix}\mathbf{\beta}_{UNIT}  &\mathbf{\delta}\end{bmatrix}^{-1}\begin{bmatrix} \mathbf{v}_{UNIT}  &\mathbf{\xi}\end{bmatrix}\begin{bmatrix}1 \\0\end{bmatrix}"
                      ,color=BLACK).scale(scaler).next_to(t21,DOWN,aligned_edge=LEFT)
        t23 = MathTex(r"=\begin{bmatrix} 0 &1\end{bmatrix}\begin{bmatrix}\cos t_\beta  & -\sin t_\beta\\ \sin t_\beta &\cos t_\beta\end{bmatrix}^{-1}\begin{bmatrix}\mathbf{v}_{UNIT}  &\mathbf{\xi}\end{bmatrix}^{-1}\begin{bmatrix}\mathbf{v}_{UNIT}  &\mathbf{\xi}\end{bmatrix}\begin{bmatrix}1\\0\end{bmatrix}"
                      ,color=BLACK).scale(scaler).next_to(t22,DOWN,aligned_edge=LEFT)
        self.play(Write(t22))
        self.play(Write(t23))
        self.wait(1)
        t24 = MathTex(r"=\begin{bmatrix} 0 &1\end{bmatrix}\begin{bmatrix}\cos t_\beta  & \sin t_\beta\\ -\sin t_\beta &\cos t_\beta\end{bmatrix}\begin{bmatrix} 1\\0\end{bmatrix}"
                      ,color=BLACK).scale(scaler).next_to(t23,DOWN,aligned_edge=LEFT)
        t25 = MathTex(r"=\begin{bmatrix}0  &1\end{bmatrix}\begin{bmatrix}\cos -t_\beta  & -\sin -t_\beta\\\sin-t_\beta  &\cos -t_\beta\end{bmatrix}\begin{bmatrix} 1\\0\end{bmatrix}=\sin -t_\beta"
                      ,color=BLACK).scale(scaler).next_to(t24,DOWN,aligned_edge=LEFT)
        self.play(Write(t24))
        self.play(Write(t25))
        HighLight(self,t25[0][len(t25[0])-6:])
        self.wait(1)
        HighLight(self,t17[0][0:7])
        self.wait(1)
        t26 = MathTex(r"\Delta_{\mathbf{K},\mathbf{\delta},\mathbf{v}_{UNIT}+\mathbf{C}}<0",color=BLACK).scale(scaler).next_to(t25,DOWN,aligned_edge=LEFT)
        self.play(Write(t26))
        self.wait(1)
        self.play(FadeOut(t20,t21,t22,t23,t24,t25),t26.animate.to_corner(UL),VGroup(Q_C,T_C,Q_V,T_V,Q_Beta,T_Beta,Q_Gamma,T_Gamma,Q_L,Q_K,Q_Delta,T_Delta,Q_Xi,T_Xi,Q_RA_Delta,Q_RA_Xi,Q_VB,Q_VG,Q_BG).animate.become(
            graphs
        ))
        self.play(Flash(Q_Delta),Flash(Q_V))
        self.wait(1)
        t27 = MathTex(r"\Delta_{\mathbf{K},\mathbf{\gamma},\mathbf{v}_{UNIT}+\mathbf{C}}<0",color=BLACK).scale(scaler).next_to(t26,DOWN,aligned_edge=LEFT)
        self.play(Write(t27))
        self.wait(1)
        t28 = MathTex(r"\Delta_{\mathbf{K},\mathbf{\delta},\mathbf{\gamma}_{UNIT}+\mathbf{C}}>0",color=BLACK).scale(scaler).next_to(t27,DOWN,aligned_edge=LEFT)
        self.play(Write(t28))
        self.wait(1)
        t29 = MathTex(r"\Delta_{\mathbf{K},\mathbf{\delta},\mathbf{\gamma}_{UNIT}+\mathbf{C}}=\begin{bmatrix}0  &1\end{bmatrix}\begin{bmatrix} \cos -t_\beta & -\sin -t_\beta \\  \sin -t_\beta &\cos -t_\beta\end{bmatrix}\begin{bmatrix}\cos t_\gamma \\\sin t_\gamma\end{bmatrix}"
                      ,color=BLACK).scale(scaler).next_to(t28,DOWN,aligned_edge=LEFT)
        t30 = MathTex(r"=\cos t_\gamma\sin -t_\beta+\sin t_\gamma\cos -t_\beta",color=BLACK).scale(scaler).next_to(t29,DOWN,aligned_edge=LEFT)
        self.play(Write(t29),VGroup(Q_C,T_C,Q_V,T_V,Q_Beta,T_Beta,Q_Gamma,T_Gamma,Q_L,Q_K,Q_Delta,T_Delta,Q_Xi,T_Xi,Q_RA_Delta,Q_RA_Xi,Q_VB,Q_VG,Q_BG).animate.shift(DOWN))
        self.play(Write(t30))
        self.wait(1)
        HighLight(self,t30)
        t31 = MathTex(r"=\sin\left(t_\gamma-t_\beta\right)",color=BLACK).scale(scaler).next_to(t30,DOWN,aligned_edge=LEFT)
        self.play(Write(t31))
        self.wait(1)
        t31_1 = MathTex(r">0",color=BLACK).scale(scaler).next_to(t31,RIGHT)
        self.play(Write(t31_1))
        self.wait(1)
        t32 = MathTex(r"t_\gamma,t_\beta\in\left(0,\pi\right)",color=BLACK).scale(scaler).next_to(t31,DOWN,aligned_edge=LEFT)
        self.play(Write(t32))
        self.wait(1)
        t33 = MathTex(r"t_\gamma-t_\beta\in\left(-\pi,\pi\right)", color=BLACK).scale(scaler).next_to(t32, DOWN,
                                                                                                   aligned_edge=LEFT)
        self.play(Write(t33))
        self.wait(1)
        HighLight(self,VGroup(t31,t31_1))
        t34 = MathTex(r"\Rightarrow t_\gamma-t_\beta\in\left(0,\pi\right)",color=BLACK).scale(scaler).next_to(t33, DOWN,
                                                                                                   aligned_edge=LEFT)
        self.play(Write(t34))
        self.wait(1)
        t35 = MathTex(r"t_\gamma>t_\beta",color=BLACK).scale(scaler).next_to(t34, DOWN,
                                                                                                   aligned_edge=LEFT)
        self.play(Write(t35))
        self.wait(1)
        self.play(FadeOut(t12,t13,t14,t15,t16,t17,t18,t19))
        t36 = MathTex(r"\left\langle\mathbf{v},\mathbf{\beta}\right\rangle+\left\langle\mathbf{\beta},\mathbf{\gamma}\right\rangle=\left\langle\mathbf{v}_{UNIT},\mathbf{\beta}_{UNIT}\right\rangle+\left\langle\mathbf{\beta}_{UNIT},\mathbf{\gamma}_{UNIT}\right\rangle"
                      ,color=BLACK).scale(scaler).to_corner(UR)
        self.play(Write(t36))
        self.wait(1)
        t37 = MathTex(r"=\left|t_\beta-t_v\right|+\left|t_\gamma-t_\beta\right|",color=BLACK).scale(scaler).next_to(t36,DOWN,aligned_edge=RIGHT)
        self.play(Write(t37))
        self.wait(1)
        HighLight(self,t37[0][1:8])
        self.wait(1)
        HighLight(self,t37[0][9:])
        self.wait(1)
        t38 = MathTex(r"=t_\beta+t_\gamma-t_\beta=t_\gamma",color=BLACK).scale(scaler).next_to(t37,DOWN,aligned_edge=RIGHT)
        self.play(Write(t38))
        self.wait(1)
        t39 = MathTex(r"=\left\langle\mathbf{v},\mathbf{\gamma}\right\rangle",color=BLACK).scale(scaler).next_to(t38,DOWN,aligned_edge=RIGHT)
        self.play(Write(t39))
        HighLight(self,VGroup(t36,t37,t38,t39))
        tit1 = mytitle("侧向判别第五引理","The 5th Lemma of Discriminant of Straightline Sides").scale(0.5).to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)

class s26(Scene):
    def construct(self):
        self.wait(1)
        a = ValueTrackerVector([cos(15*DEGREES),sin(15*DEGREES),0])
        b = RIGHT
        X = UP
        Y = DOWN+LEFT
        Q_a = always_redraw(lambda:Arrow(X,X+a.get_value_array(),color=RED,buff=0))
        T_a = always_redraw(lambda:MathTex(r"\mathbf{a}",color=RED).next_to(Q_a,UP,buff=0))
        Q_b = Arrow(Y,Y+b,color=BLUE,buff=0)
        T_b = always_redraw(lambda: MathTex(r"\mathbf{b}", color=BLUE).next_to(Q_b, DOWN, buff=0))
        Q_A = always_redraw(lambda:Line(X-3*a.get_value_array(),X+3*a.get_value_array(),color=RED_E))
        Q_B = Line(Y-3*b,Y+3*b,color=BLUE_E)

        scaler = 0.5

        t1 = tex_with_gbk([_pair(r"\mathbf{A},\mathbf{B}",0),_pair(r"是在二维空间",1),_pair(r"\mathbf{V}^2",0),_pair(r"中的两条直线",1)]).scale(scaler).to_corner(UL)
        t1[0][0][0].set_color(RED)
        t1[0][0][2].set_color(BLUE)
        self.play(Write(t1))
        self.play(Write(Q_A))
        self.play(Write(Q_B))
        self.wait(1)
        self.play(Write(Q_a),Write(T_a))
        self.play(Write(Q_b),Write(T_b))
        self.wait(1)
        Q_X = Dot(X,color=BLACK)
        T_X = MathTex(r"\mathbf{X}",color=BLACK).next_to(Q_X,UL)
        Q_Y = Dot(Y,color=BLACK)
        T_Y = MathTex(r"\mathbf{Y}", color=BLACK).next_to(Q_Y, DL)
        t2 = MathTex(r"\mathbf{X}\in\mathbf{A},\mathbf{Y}\in\mathbf{B}",color=BLACK).scale(scaler).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.play(Write(Q_X),Write(T_X))
        self.play(Write(Q_Y),Write(T_Y))
        self.wait(1)

        t3 = MathTex(r"\mathbf{A}\left(t\right)=t\mathbf{a}+\mathbf{X}",color=BLACK).scale(scaler).next_to(t2,DOWN,aligned_edge=LEFT)
        t4 = MathTex(r"\mathbf{B}\left(t\right)=t\mathbf{b}+\mathbf{Y}", color=BLACK).scale(scaler).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.play(Write(t4))
        self.wait(1)

        t5 = MathTex(r"\overline{\mathbf{XY}}\ni \mathbf{X},\mathbf{Y}",color=BLACK).scale(scaler).next_to(t4,DOWN,aligned_edge=LEFT)
        Q_XY = Line(X+2*(X-Y),Y-2*(X-Y),color=BLACK)
        self.play(Write(t5))
        self.play(Write(Q_XY))
        self.wait(1)

        t6 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{b}+\mathbf{Y}}>0",color=BLACK).scale(scaler).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)

        t7 = MathTex(r"\overrightarrow{\mathbf{X}\mathbf{Y}}=\mathbf{Y}-\mathbf{X}",color=BLACK).scale(scaler).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)

        t8 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X},\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
                     ,color=BLACK).scale(scaler).next_to(t7,DOWN,aligned_edge=LEFT)
        t8[0][:11].set_color(PURE_RED)
        t8[0][12:].set_color(RED_E)
        Q_ANGLE_A_YX_X = always_redraw(lambda:ARC_V(a.get_value_array(),X-Y,radius=0.3,color=PURE_RED,stroke_width=10).shift(X))
        Q_ANGLE_B_YX_Y = ARC_V(b,X-Y,radius=0.3,color=RED_E,stroke_width=10).shift(Y)
        self.play(Write(t8))
        self.play(Write(Q_ANGLE_A_YX_X))
        self.play(Write(Q_ANGLE_B_YX_Y))
        tit1 = mytitle("同位角","Corresponding Angles").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        self.play(FadeOut(tit1[1]),tit1[0].animate.become(tit1[0].copy().scale(0.5).next_to(t8,RIGHT).set_color(GRAY)))

        t9 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X},\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
                     ,color=BLACK).scale(scaler).next_to(t8,DOWN,aligned_edge=LEFT)
        t9[0][:11].set_color(PURE_BLUE)
        t9[0][12:].set_color(RED_E)
        Q_ANGLE_A_XY_X = always_redraw(
            lambda: ARC_V(a.get_value_array(), Y - X, radius=0.3, color=PURE_BLUE, stroke_width=10).shift(X))
        self.play(Write(t9))
        self.play(Write(Q_ANGLE_A_XY_X))
        tit2 = mytitle("同旁内角","Consecutive Interior Angles").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(tit2[1]), tit2[0].animate.become(tit2[0].copy().scale(0.5).next_to(t9, RIGHT).set_color(GRAY)))

        t10 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X},\left\langle-\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
                      ,color=BLACK).scale(scaler).next_to(t9,DOWN,aligned_edge=LEFT)
        t10[0][:11].set_color(PURE_BLUE)
        t10[0][12:].set_color(GREEN_E)
        Q_ANGLE_MB_YX_Y = ARC(atan(2),180*DEGREES,radius=0.3,color=GREEN_E,stroke_width=10).shift(Y)
        self.play(Write(t10))
        self.play(Write(Q_ANGLE_MB_YX_Y))
        tit3 = mytitle("内错角","Alternate Interior Angles").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)
        self.play(FadeOut(tit3[1]), tit3[0].animate.become(tit3[0].copy().scale(0.5).next_to(t10, RIGHT).set_color(GRAY)))
        self.wait(1)

        t11 = MathTex(r"\mathbf{A}\parallel\mathbf{B}",color=BLACK).scale(scaler).to_corner(UR)
        self.play(Write(t11))
        self.play(a.animate_set_value(RIGHT))
        self.wait(1)
        t12 = MathTex(r"\Rightarrow\mathbf{a}=k\mathbf{b}",color=BLACK).scale(scaler).next_to(t11,DOWN,aligned_edge=RIGHT)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"k>0",color=BLACK).scale(scaler).next_to(t12,DOWN,aligned_edge=RIGHT)
        self.play(Write(t13))
        self.wait(1)

        t14 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X}=\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
                      ,color=BLACK).scale(scaler).next_to(t13,DOWN,aligned_edge=RIGHT)
        self.play(Write(t14))
        self.wait(1)

        t15 = MathTex(
            r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X}=\left\langle-k\mathbf{a},-\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{Y}=\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
            , color=BLACK).scale(scaler).next_to(t14, DOWN, aligned_edge=RIGHT)
        self.play(Write(t15))
        self.wait(1)

        t16 = MathTex(r"\alpha+\beta=\frac{1}{2}\pi",color=BLACK).scale(scaler).next_to(t15,DOWN,aligned_edge=RIGHT)
        self.play(Write(t16))
        tit4 = mytitle("互余","Complementary Angles").to_edge(DOWN)
        self.play(Write(tit4))
        self.wait(1)
        self.play(FadeOut(tit4[1]),tit4[0].animate.become(tit4[0].copy().set_color(GRAY).scale(0.5).next_to(t16,LEFT)))
        t17 = MathTex(r"\beta+\gamma=\pi",color=BLACK).scale(scaler).next_to(t16,DOWN,aligned_edge=RIGHT)
        self.play(Write(t17))
        tit5 = mytitle("互补","Supplementary Angles").to_edge(DOWN)
        self.play(Write(tit5))
        self.wait(1)
        self.play(FadeOut(tit5[1]),
                  tit5[0].animate.become(tit5[0].copy().set_color(GRAY).scale(0.5).next_to(t17, LEFT)))

        t18 = MathTex(
            r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X}+\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}=\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X}+\pi-\left\langle-\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}=\pi"
            , color=BLACK).scale(scaler).next_to(t17, DOWN, aligned_edge=RIGHT)
        self.play(Write(t18))
        self.wait(1)

        self.play(FadeOut(t11,t12,t13,t14,t15,t16,t17,t18,tit4[0],tit5[0]))
        t19 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X}=\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}"
                      ,color=BLACK).scale(scaler).to_corner(UR)
        self.play(Write(t19))
        self.wait(1)
        t20 = MathTex(r"\mathbf{C}_{UNIT}",color=BLACK).scale(scaler).next_to(t19,DOWN,aligned_edge=RIGHT)
        self.play(Write(t20))
        self.wait(1)
        t21 = MathTex(r"\overrightarrow{\mathbf{XY}}_{UNIT}=\mathbf{C}\left(0\right)",color=BLACK).scale(scaler).next_to(t20,DOWN,aligned_edge=RIGHT)
        t22 = MathTex(r"\mathbf{a}_{UNIT}=\mathbf{C}\left(\theta\right)",color=BLACK).scale(scaler).next_to(t21,DOWN,aligned_edge=RIGHT)
        t23 = MathTex(r"\mathbf{b}_{UNIT}=\mathbf{C}\left(\phi\right)", color=BLACK).scale(scaler).next_to(t22, DOWN,
                                                                                                          aligned_edge=RIGHT)
        self.play(Write(t21))
        self.play(Write(t22))
        self.play(Write(t23))
        self.wait(1)
        HighLight(self,t6)
        self.wait(1)
        t24 = MathTex(r"\mathbf{\theta},\mathbf{\phi}\in\left(0,\pi\right)",color=BLACK).scale(scaler).next_to(t23,DOWN,aligned_edge=RIGHT)
        self.play(Write(t24))
        self.wait(1)
        t25 = MathTex(r"\mathbf{\theta}=\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X}=\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}=\mathbf{\phi}"
                      ,color=BLACK).scale(scaler).next_to(t24,DOWN,aligned_edge=RIGHT)
        self.play(Write(t25))
        self.wait(1)
        t26 = MathTex(r"\mathbf{a}_{UNIT}=\mathbf{b}_{UNIT}",color=BLACK).scale(scaler).next_to(t25,DOWN,aligned_edge=RIGHT)
        self.play(Write(t26))
        self.wait(1)
        t27 = MathTex(r"\mathbf{a}=k\mathbf{b},k>0",color=BLACK).scale(scaler).next_to(t26,DOWN,aligned_edge=RIGHT)
        self.play(Write(t27))
        self.wait(1)
        t28 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X}=\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}\Leftrightarrow\mathbf{a}\parallel\mathbf{b}"
                      ,color=BLACK).scale(scaler).next_to(t27,DOWN,aligned_edge=RIGHT)
        self.play(Write(t28))
        self.wait(1)
        t29 = MathTex(
            r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X}=\left\langle-\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}\Leftrightarrow\mathbf{a}\parallel\mathbf{b}"
            , color=BLACK).scale(scaler).next_to(t28, DOWN, aligned_edge=RIGHT)
        t30 = MathTex(
            r"\left\langle\mathbf{a},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{X}+\left\langle\mathbf{b},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{Y}=\pi\Leftrightarrow\mathbf{a}\parallel\mathbf{b}"
            , color=BLACK).scale(scaler).next_to(t29, DOWN, aligned_edge=RIGHT)
        self.play(Write(t29))
        self.play(Write(t30))
        self.wait(1)
        t_DOWNARROW = MathTex(r"\Downarrow",color=PURE_RED).scale(5).next_to(VGroup(t28,t29,t30),LEFT,buff=0)
        self.play(Write(t_DOWNARROW))
        self.wait(1)

class s27(Scene):
    def construct(self):
        self.wait(1)

        a = ValueTrackerVector(RIGHT)
        b = RIGHT
        X = UP
        Y = DOWN + RIGHT
        Q_a = always_redraw(lambda: Arrow(X, X + a.get_value_array(), color=RED, buff=0))
        T_a = always_redraw(lambda: MathTex(r"\mathbf{a}", color=RED).next_to(Q_a, UP, buff=0))
        Q_b = Arrow(Y, Y + b, color=BLUE, buff=0)
        T_b = always_redraw(lambda: MathTex(r"\mathbf{b}", color=BLUE).next_to(Q_b, DOWN, buff=0))
        Q_A = always_redraw(lambda: Line(X - 4 * a.get_value_array(), X + 4 * a.get_value_array(), color=RED_E))
        Q_B = Line(Y - 4 * b, Y + 4 * b, color=BLUE_E)
        Q_ANGLE_B_YX_Y = ARC_V(b, X - Y, radius=0.3, color=RED_E, stroke_width=10).shift(Y)
        Q_ANGLE_A_XY_X = always_redraw(
            lambda: ARC_V(a.get_value_array(), Y - X, radius=0.3, color=PURE_BLUE, stroke_width=10).shift(X))
        Q_XY = Line(X + 4 * (X - Y), Y - 4 * (X - Y), color=BLACK)
        Q_X = Dot(X, color=BLACK)
        T_X = MathTex(r"\mathbf{X}", color=BLACK).next_to(Q_X, UL)
        Q_Y = Dot(Y, color=BLACK)
        T_Y = MathTex(r"\mathbf{Y}", color=BLACK).next_to(Q_Y, DL)

        scaler = 0.5

        self.play(FadeIn(Q_a,T_a,Q_b,T_b,Q_A,Q_B,Q_ANGLE_B_YX_Y,Q_ANGLE_A_XY_X,Q_XY,T_X,T_Y,Q_X,Q_Y))
        self.wait(1)

        t1 = MathTex(r"\left\langle\mathbf{a},\overrightarrow{\mathbf{XY}} \right\rangle\mid\mathbf{X}+\left\langle\mathbf{b},\overrightarrow{\mathbf{YX}} \right\rangle\mid\mathbf{Y}<\pi"
                     ,color=BLACK).scale(scaler).to_corner(UL)
        self.play(Write(t1))
        self.play(a.animate_set_value([cos(-45*DEGREES),sin(-45*DEGREES),0]))
        self.wait(1)
        t2 = MathTex(r"\mathbf{A}\not\parallel\mathbf{B}",color=BLACK).scale(scaler).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)

        Q_Cross = Dot(_Cross(a.get_value_array(),X,b,Y),color=BLACK)
        self.play(Write(Q_Cross))
        self.wait(1)

        t3 = MathTex(r"\mathbf{Z}=\mathbf{A}\cap\mathbf{B}",color=BLACK).scale(scaler).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)

        t4 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}>0?",color=PURE_RED).scale(scaler).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        t5 = MathTex(r"If \Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}<0",color=BLACK).scale(scaler).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.play(FadeOut(Q_Cross))
        self.play(a.animate_set_value([cos(60*DEGREES),sin(60*DEGREES),0]))
        Z = _Cross(a.get_value_array(),X,b,Y)
        Q_Z = Dot(_Cross(a.get_value_array(),X,b,Y),color=BLACK)
        T_Z = MathTex(r"\mathbf{Z}",color=BLACK).next_to(Q_Z,DL)
        self.play(Write(Q_Z),Write(T_Z))
        self.wait(1)
        t6 = MathTex(r"\overline{\mathbf{YK}}\parallel\mathbf{A}",color=GREEN).scale(scaler).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        Q_L_YK = DashedLine(Y+10*a.get_value_array(),Y-10*a.get_value_array(),color=GREEN)
        self.play(Write(Q_L_YK))
        self.wait(1)
        t7 = MathTex(r"\overline{\mathbf{YK}}\left(t\right)=t\mathbf{a}+\mathbf{Y}",color=GREEN).scale(scaler).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}<0",color=BLACK).scale(scaler).next_to(t7,DOWN,aligned_edge=LEFT)
        self.play(Write(t8))
        self.wait(1)
        t9 = MathTex(r"\mathbf{Z}=\mathbf{A}\left(\beta\right)=\beta\mathbf{a}+\mathbf{X}",color=BLACK).scale(scaler).next_to(t8,DOWN,aligned_edge=LEFT)
        self.play(Write(t9))
        self.wait(1)
        t10 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}=\Delta_{\overline{\mathbf{XY}},\mathbf{a},\beta\mathbf{a}+\mathbf{X}}=\beta\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{a}+\mathbf{X}}=\beta", color=BLACK).scale(
            scaler).next_to(t9, DOWN, aligned_edge=LEFT)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"\beta=\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}<0",color=BLACK).scale(scaler).next_to(t10,DOWN,aligned_edge=LEFT)
        self.play(Write(t11))
        self.wait(1)

        t12 = MathTex(r"\mathbf{K}=\overline{\mathbf{YK}}\left(1\right)=\mathbf{a}+\mathbf{Y}",color=BLACK).scale(scaler).next_to(t11,DOWN,aligned_edge=LEFT)
        K = a.get_value_array() + Y
        Q_K = Dot(K,color=BLACK)
        T_K = MathTex(r"\mathbf{K}",color=BLACK).next_to(Q_K,UR,buff=0)
        self.play(Write(t12))
        self.play(Write(Q_K),Write(T_K))
        self.wait(1)

        t13 = MathTex(r"\mathbf{X}=-\beta\mathbf{a}+\mathbf{Z}",color=BLACK).scale(scaler).next_to(t12,DOWN,aligned_edge=LEFT)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"\beta<0\Rightarrow -\beta>0",color=BLACK).scale(scaler).next_to(t13,DOWN,aligned_edge=LEFT)
        self.play(Write(t14))
        self.wait(1)

        t15 = MathTex(r"\Delta_{\overline{\mathbf{YZ}},\mathbf{a},\mathbf{X}}>0",color=BLACK).scale(scaler).to_corner(UR)
        self.play(Write(t15))
        self.wait(1)

        Q_ANGLE_ZY_YK_Y = ARC_V(Y - Z, K-Y, radius=0.4, color=GREEN_E,stroke_width=10).shift(Y)

        t18 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{K}}>0",color=BLACK).scale(scaler).next_to(t15,DOWN,aligned_edge=RIGHT)
        self.play(Write(t18))
        self.wait(1)
        t19 = tex_with_gbk([_pair(
            r"\left\langle\overrightarrow{\mathbf{XY}},\mathbf{a} \right\rangle\mid\mathbf{X},\left\langle\overrightarrow{\mathbf{YX}},\overrightarrow{\mathbf{YK}} \right\rangle\mid\mathbf{Y}")
            , _pair(r"是一对同旁内角", 1)]).scale(scaler).next_to(t18,DOWN,aligned_edge=RIGHT)
        t19[0][0][:11].set_color(BLUE_E)
        t19[0][0][12:].set_color(PURPLE)
        Q_ANGLE_YX_YK_Y = ARC_V(X-Y, K-Y, radius=0.4, color=PURPLE,stroke_width=10).shift(Y)
        self.play(Write(t19))
        self.play(Write(Q_ANGLE_YX_YK_Y))
        self.wait(1)
        t20 = MathTex(r"\left\langle\overrightarrow{\mathbf{XY}},\mathbf{a} \right\rangle+\left\langle\overrightarrow{\mathbf{YX}},\overrightarrow{\mathbf{YK}} \right\rangle=\pi"
                      ,color=BLACK).scale(scaler).next_to(t19,DOWN,aligned_edge=RIGHT)
        self.play(Write(t20))##中子星NeutronStar233制作
        self.wait(1)

        t21 = MathTex(r"\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}},\mathbf{Z}}=\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}},\mathbf{X}+\beta\mathbf{a}}=\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}},\mathbf{X}}>0"
                      ,color=BLACK).scale(scaler).next_to(t20,DOWN,aligned_edge=RIGHT)
        self.play(Write(t21))
        self.wait(1)

        t22 = MathTex(r"\mathbf{Z}\in\mathbf{B},\Delta_{\overline{\mathbf{XY}},\mathbf{b},\mathbf{Z}}<0",color=BLACK).scale(scaler).next_to(t21,DOWN,aligned_edge=RIGHT)
        self.play(Write(t22))
        self.wait(1)
        t23 = MathTex(r"\mathbf{Z}=\gamma\mathbf{b}+\mathbf{Y},\gamma<0",color=BLACK).scale(scaler).next_to(t22,DOWN,aligned_edge=RIGHT)
        self.play(Write(t23))
        self.wait(1)

        t24 = MathTex(r"\text{sgn}\,\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}} ,\mathbf{b}+\mathbf{Y}}=-\text{sgn}\,\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}} ,\mathbf{Z}}"
                      ,color=BLACK).scale(scaler).next_to(t23,DOWN,aligned_edge=RIGHT)
        self.play(Write(t24))
        self.wait(1)
        HighLight(self,t21)
        self.wait(1)
        t25 = MathTex(r"\Delta_{\overline{\mathbf{YK}},\overrightarrow{\mathbf{YX}} ,\mathbf{b}+\mathbf{Y}}<0",color=BLACK).scale(scaler).next_to(t24,DOWN,aligned_edge=RIGHT)
        self.play(Write(t25))
        self.wait(1)
        t26 = MathTex(r"\overrightarrow{\mathbf{YK}}=\mathbf{K}-\mathbf{Y}=\mathbf{Y}+\mathbf{a}-\mathbf{Y}=\mathbf{a}",color=BLACK).scale(scaler).next_to(t25,DOWN,aligned_edge=RIGHT)
        Q_V_YK = Arrow(Y,K,color=GREEN_E,buff=0)
        self.play(Write(t26))
        self.play(Write(Q_V_YK))
        self.wait(1)
        t27 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\overrightarrow{\mathbf{YK}} ,\mathbf{b}+\mathbf{Y}}>0",color=BLACK).scale(scaler).next_to(t26,DOWN,aligned_edge=RIGHT)
        self.play(Write(t27))
        self.wait(1)
        self.play(Flash(Q_V_YK),Flash(Dot(Y+b)))
        self.wait(1)
        self.play(Flash(Q_X), Flash(Dot(Y+b)))
        self.wait(1)
        t28 = MathTex(r"\left\langle\overrightarrow{\mathbf{YX}},\mathbf{YK}\right\rangle+\left\langle\overrightarrow{\mathbf{YK}},\mathbf{b}\right\rangle=\left\langle\overrightarrow{\mathbf{YX}},\mathbf{b}\right\rangle"
                      ,color=BLACK).scale(scaler).next_to(t27,DOWN,aligned_edge=RIGHT)
        self.play(Write(t28))
        self.wait(1)
        t29 = MathTex(r"\left\langle\overrightarrow{\mathbf{XY}},\mathbf{a}\right\rangle+\left\langle\overrightarrow{\mathbf{YX}},\mathbf{b}\right\rangle=\left\langle\overrightarrow{\mathbf{XY}},\mathbf{a}\right\rangle+\left\langle\overrightarrow{\mathbf{YX}},\overrightarrow{\mathbf{YK}}\right\rangle+\left\langle\overrightarrow{\mathbf{YK}},\mathbf{b}\right\rangle"
                      ,color=BLACK).scale(scaler).next_to(t28,DOWN,aligned_edge=RIGHT)
        t30 = MathTex(r"=\pi+\left\langle\mathbf{a},\mathbf{b}\right\rangle\ge\pi",color=BLACK).scale(scaler).next_to(t29,DOWN,aligned_edge=RIGHT)
        self.play(Write(Q_ANGLE_ZY_YK_Y))
        self.play(Write(t29))
        self.play(Write(t30))
        self.wait(1)
        self.play(VGroup(t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30).animate.set_color(RED))
        self.wait(1)
        self.play(FadeOut(t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30
                          ,Q_V_YK,Q_K,Q_ANGLE_ZY_YK_Y,Q_Z,Q_ANGLE_YX_YK_Y,Q_L_YK,T_K,T_Z))
        t31 = MathTex(r"\Delta_{\overline{\mathbf{XY}},\mathbf{a},\mathbf{Z}}>0",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t31))
        self.play(a.animate_set_value([cos(-45*DEGREES),sin(-45*DEGREES),0]))
        Q_Z = Dot(_Cross(a.get_value_array(),X,b,Y),color=BLACK)
        T_Z = MathTex(r"\mathbf{Z}",color=BLACK).next_to(Q_Z,DR,buff=0)
        self.play(Write(Q_Z),Write(T_Z))
        self.wait(1)

class s28(Scene):
    def construct(self):
        self.wait(1)
        t1 = MathTex(r"\mathbf{J}=\mathbb{R}^2",color=BLACK).to_corner(UL)
        self.play(Write(t1))
        self.wait(1)
        A = 2*UP
        B = 2*LEFT
        C = RIGHT
        Q_A = Dot(A,color=RED)
        T_A = MathTex(r"\mathbf{A}",color=RED).next_to(Q_A,UP,buff=0)
        Q_B = Dot(B, color=BLUE)
        T_B = MathTex(r"\mathbf{B}", color=BLUE).next_to(Q_B, LEFT, buff=0)
        Q_C = Dot(C, color=GREEN)
        T_C = MathTex(r"\mathbf{C}", color=GREEN).next_to(Q_C, RIGHT, buff=0)
        t2 = MathTex(r"\mathbf{A},\mathbf{B},\mathbf{C}",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        t2[0][0].set_color(RED)
        t2[0][2].set_color(BLUE)
        t2[0][4].set_color(GREEN)
        self.play(Write(t2))
        self.play(Write_In_Group([Q_A,T_A,Q_B,T_B,Q_C,T_C]))
        self.wait(1)
        Q_AB = Line(A,B,color=GREEN)
        Q_BC = Line(B, C, color=RED)
        Q_CA = Line(C, A, color=BLUE)
        t3 = MathTex(r"\overline{\mathbf{AB}},\overline{\mathbf{BC}},\overline{\mathbf{CA}}",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.play(Write_In_Group_Althernately([Q_AB,Q_BC,Q_CA]))
        self.wait(1)
        Q_S = Polygon(A,B,C,color=RED,fill_opacity=0.2,stroke_opacity=0)
        t4 = MathTex(r"\partial\mathbf{S}=\overline{\mathbf{AB}}\cup\overline{\mathbf{BC}}\cup\overline{\mathbf{CA}}",color=BLACK).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        t5 = MathTex(r"\lambda^1\left(\mathbf{S}\right)\in\mathbf{R}",color=BLACK).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.play(Write(Q_S))
        self.wait(1)
        t6 = MathTex(r"\mathbf{S}=\triangle \mathbf{ABC}",color=BLACK).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        tit1 = mytitle("三角形","Triangle").to_edge(DOWN)
        self.play(Write(tit1))
        self.wait(1)
        t6_1 = mathtexgroup([r"\Delta \boldsymbol{A B C}(u, v) & =\boldsymbol{A}+u(\boldsymbol{B}-\boldsymbol{A})+v(\boldsymbol{C}-(\boldsymbol{A}+u(\boldsymbol{B}-\boldsymbol{A}))) ",
                             r"= & \boldsymbol{A}+u(\boldsymbol{B}-\boldsymbol{A})+v(\boldsymbol{C}-\boldsymbol{A}-u(\boldsymbol{B}-\boldsymbol{A}))",
                             r"= & \boldsymbol{A}+u(\boldsymbol{B}-\boldsymbol{A})+v \boldsymbol{C}-v \boldsymbol{A}-u v(\boldsymbol{B}-\boldsymbol{A})",
                             r"= & (1-v) \boldsymbol{A}+(u-u v)(\boldsymbol{B}-\boldsymbol{A})+v \boldsymbol{C}"]).scale(0.5).to_corner(UR)
        self.play(Write(t6_1))
        self.wait(1)
        self.play(FadeOut(tit1,t6_1))
        self.wait(1)
        t7 = mathtexgroup([r"\left\langle\overrightarrow{\mathbf{AB}},\overrightarrow{\mathbf{AC}}\right\rangle\mid\mathbf{A}"
                           ,r"\left\langle\overrightarrow{\mathbf{BA}},\overrightarrow{\mathbf{BC}}\right\rangle\mid\mathbf{B}"
                           ,r"\left\langle\overrightarrow{\mathbf{CA}},\overrightarrow{\mathbf{CB}}\right\rangle\mid\mathbf{C}"]).next_to(t6,DOWN,aligned_edge=LEFT)
        t7[0].set_color(RED_E)
        t7[1].set_color(BLUE_E)
        t7[2].set_color(GREEN_E)
        self.play(Write(t7))
        Q_ANGLE_A = ARC_V(B-A,C-A,radius=0.3,color=RED_E,stroke_width=10).shift(A)
        Q_ANGLE_B = ARC_V(A - B, C - B, radius=0.3, color=BLUE_E, stroke_width=10).shift(B)
        Q_ANGLE_C = ARC_V(C - A, C - B, radius=0.3, color=GREEN_E, stroke_width=10).rotate_about_origin(PI).shift(C)
        self.play(Write_In_Group_Althernately([Q_ANGLE_A,Q_ANGLE_B,Q_ANGLE_C]))
        tit2 = mytitle("内角","Interior Angle").to_edge(DOWN)
        self.play(Write(tit2))
        self.wait(1)
        self.play(FadeOut(tit2))
        HighLight(self,t3)
        tit3 = mytitle("边","Side").to_edge(DOWN)
        self.play(Write(tit3))
        self.wait(1)
        self.play(FadeOut(tit3))
        self.wait(1)
        Q_L_BD = DashedLine(B+10*(C-A),B-10*(C-A),color=BLACK)
        D = B-(C-A)
        Q_D = Dot(D,color=BLACK)
        T_D = MathTex(r"\mathbf{D}",color=BLACK).next_to(Q_D,UL,buff=0)
        t8 = MathTex(r"\overline{\mathbf{BD}}\parallel\overline{\mathbf{AC}}",color=BLACK).to_corner(UR)
        self.play(Write(t8))
        self.play(Write(Q_L_BD))
        self.wait(1)
        t9 = MathTex(r"\mathbf{D}=\mathbf{B}-\overrightarrow{\mathbf{AC}}",color=BLACK).next_to(t8,DOWN,aligned_edge=RIGHT)
        self.play(Write(t9))
        self.play(Write(Q_D),Write(T_D))
        self.wait(1)
        t10 = MathTex(r"\angle1=\left\langle\overrightarrow{\mathbf{CA}},\overrightarrow{\mathbf{BA}} \right\rangle=\left\langle\overrightarrow{\mathbf{AB}},\overrightarrow{\mathbf{AC}} \right\rangle=\angle\mathbf{A}"
                      ,color=BLACK).next_to(t9,DOWN,aligned_edge=RIGHT)
        Q_ANGLE_1 = ARC_V(A-C,A-B,radius=0.3,color=YELLOW_E,stroke_width=10).shift(B)
        T_ANGLE_1 = MathTex(r"1",color=YELLOW_E).next_to(Q_ANGLE_1,UP,buff=0)
        self.play(Write(t10))
        self.play(Write(Q_ANGLE_1),Write(T_ANGLE_1))
        self.wait(1)
        t11 = MathTex(r"\angle2=\left\langle\overrightarrow{\mathbf{BC}},\overrightarrow{\mathbf{AC}} \right\rangle=\left\langle\overrightarrow{\mathbf{CA}},\overrightarrow{\mathbf{CB}} \right\rangle=\angle\mathbf{C}"
                      ,color=BLACK).next_to(t10,DOWN,aligned_edge=RIGHT)
        Q_ANGLE_2 = ARC_V(C-A, C - B, radius=0.3, color=PURPLE, stroke_width=10).shift(B)
        T_ANGLE_2 = MathTex(r"2", color=PURPLE).next_to(Q_ANGLE_2, RIGHT, buff=0)
        self.play(Write(t11))
        self.play(Write(Q_ANGLE_2),Write(T_ANGLE_2))
        self.wait(1)

        t12 = MathTex(r"\Delta_{\overline{\mathbf{AB}},\mathbf{D},\mathbf{C}}<0",color=BLACK).next_to(t11,DOWN,aligned_edge=RIGHT)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"\Delta_{\overline{\mathbf{BC}},\mathbf{D},\mathbf{A}}>0", color=BLACK).next_to(t12, DOWN,
                                                                                                     aligned_edge=RIGHT)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"\angle\mathbf{DBC}=\left\langle\overrightarrow{\mathbf{CA}},\overrightarrow{\mathbf{BC}} \right\rangle=\angle1+\left\langle\overrightarrow{\mathbf{BA}},\overrightarrow{\mathbf{BC}}\right\rangle=\angle1+\angle3"
                      ,color=BLACK).scale(0.5).next_to(t13,DOWN,aligned_edge=RIGHT)
        self.play(Write(t14))
        self.wait(1)
        t15 = MathTex(r"\angle\mathbf{DBC}+\angle2=\left\langle\overrightarrow{\mathbf{CA}},\overrightarrow{\mathbf{BC}} \right\rangle+\left\langle\overrightarrow{\mathbf{BC}},\overrightarrow{\mathbf{AC}} \right\rangle=\pi"
                      ,color=BLACK).scale(0.5).next_to(t14,DOWN,aligned_edge=RIGHT)
        self.play(Write(t15))
        self.wait(1)
        t16 = MathTex(r"\angle1+\angle2+\angle3=\pi",color=BLACK).next_to(t15,DOWN,aligned_edge=RIGHT)
        self.play(Write(t16))
        self.wait(1)

class s29(Scene):
    def construct(self):
        self.wait(1)
        C = np.array([0,0,0])
        B = RIGHT
        A = 0.25*RIGHT+UP
        F = C+2*RIGHT
        E = B + 2 * RIGHT
        D = A + 2 * RIGHT
        Q_A = Dot(A,color=RED)
        T_A = MathTex(r"\mathbf{A}",color=RED).next_to(Q_A,UP,buff=0)
        Q_B = Dot(B, color=BLUE)
        T_B = MathTex(r"\mathbf{B}", color=BLUE).next_to(Q_B, RIGHT, buff=0)
        Q_C = Dot(C, color=GREEN)
        T_C = MathTex(r"\mathbf{C}", color=GREEN).next_to(Q_C, DL, buff=0)

        Q_D = Dot(D, color=RED_E)
        T_D = MathTex(r"\mathbf{D}", color=RED_E).next_to(Q_D, UP, buff=0)
        Q_E = Dot(E, color=BLUE_E)
        T_E = MathTex(r"\mathbf{E}", color=BLUE_E).next_to(Q_E, RIGHT, buff=0)
        Q_F = Dot(F, color=GREEN_E)
        T_F = MathTex(r"\mathbf{F}", color=GREEN_E).next_to(Q_F, DL, buff=0)

        Q_AB = Line(A,B,color=GREEN)
        Q_BC = Line(B, C, color=RED)
        Q_AC = Line(A, C, color=BLUE)
        Q_DE = Line(D, E, color=GREEN_E)
        Q_EF = Line(E, F, color=RED_E)
        Q_DF = Line(D, F, color=BLUE_E)

        Q_T_ABC = Polygon(A,B,C,color=RED,fill_opacity=0.2,stroke_opacity=0)
        Q_T_DEF = Polygon(D, E, F, color=BLUE,fill_opacity=0.2,stroke_opacity=0)

        t1 = MathTex(r"\triangle\mathbf{ABC},\triangle\mathbf{DEF}",color=BLACK).scale(0.5).to_corner(UL)
        self.play(Write(t1))
        self.play(Write_In_Group([Q_A,T_A,Q_B,T_B,Q_C,T_C,Q_D,T_D,Q_E,T_E,Q_F,T_F,Q_AB,Q_BC,Q_AC,Q_DE,Q_EF,Q_DF,Q_T_ABC,Q_T_DEF]))
        self.wait(1)
        t2 = MathTex(r"\overline{\mathbf{AB}}=\overline{\mathbf{DE}},\overline{\mathbf{AC}}=\overline{\mathbf{DF}},\angle\mathbf{A}=\left\langle\overrightarrow{\mathbf{AB}},\overrightarrow{\mathbf{AC}}\right\rangle=\left\langle\overrightarrow{\mathbf{DE}},\overrightarrow{\mathbf{DF}}\right\rangle=\angle\mathbf{D}=\theta"
                     ,color=BLACK).scale(0.5).next_to(t1,DOWN,aligned_edge=LEFT)
        self.play(Write(t2))
        self.wait(1)
        HighLight(self,t2[0][:len(MathTex(r"\overline{\mathbf{AB}}=\overline{\mathbf{DE}}")[0])])
        self.wait(1)
        t3 = MathTex(r"\overline{\mathbf{AB}}\cong\overline{\mathbf{DE}}",color=BLACK).scale(0.5).next_to(t2,DOWN,aligned_edge=LEFT)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"\exists\mathcal{E},\mathcal{E}\overline{\mathbf{DE}}=\overline{\mathbf{AB}}",color=BLACK).scale(0.5).next_to(t3,DOWN,aligned_edge=LEFT)
        self.play(Write(t4))
        self.wait(1)
        HighLight(self,t2[0][len(MathTex(r"\overline{\mathbf{AB}}=\overline{\mathbf{DE}},\overline{\mathbf{AC}}=\overline{\mathbf{DF}}, ")[0]):])
        self.wait(1)
        t5 = MathTex(r"\overrightarrow{\mathbf{AC}} =\frac{\left|\mathbf{AC}\right|}{\left|\mathbf{AB}\right|}\begin{bmatrix}\cos \theta  &-\sin \theta \\\sin\theta  &\cos\theta \end{bmatrix}\overrightarrow{\mathbf{AB}} "
                     ,color=BLACK).scale(0.5).next_to(t4,DOWN,aligned_edge=LEFT)
        self.play(Write(t5))
        self.wait(1)
        t5_1 = MathTex(r"\left ( \begin{bmatrix} 1\\0\end{bmatrix},\begin{bmatrix}\cos \theta  & -\sin \theta\\\sin \theta  &\cos \theta\end{bmatrix}\begin{bmatrix} 1\\0\end{bmatrix} \right )= \left ( \begin{bmatrix} 1\\0\end{bmatrix},\begin{bmatrix}\cos \theta  \\\sin \theta \end{bmatrix} \right )=\cos\theta"
                       ,color=GRAY).scale(0.5).next_to(t5,DOWN,aligned_edge=LEFT)
        self.play(Write(t5_1))
        self.wait(1)
        t6 = MathTex(r"\overrightarrow{\mathbf{DF}} =\frac{\left|\mathbf{DF}\right|}{\left|\mathbf{DE}\right|}\begin{bmatrix}\cos \theta  &-\sin \theta \\\sin\theta  &\cos\theta \end{bmatrix}\overrightarrow{\mathbf{DE}}=\frac{\left|\mathbf{AC}\right|}{\left|\mathbf{AB}\right|}\begin{bmatrix}\cos \theta  &-\sin \theta \\\sin\theta  &\cos\theta \end{bmatrix}\overrightarrow{\mathbf{DE}} "
                     ,color=BLACK).scale(0.5).next_to(t5_1,DOWN,aligned_edge=LEFT)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\mathbf{X}=\frac{\left|\mathbf{AC}\right|}{\left|\mathbf{AB}\right|}\begin{bmatrix}\cos \theta  &-\sin \theta \\\sin\theta  &\cos\theta \end{bmatrix}"
                     ,color=BLACK).scale(0.5).next_to(t6,DOWN,aligned_edge=LEFT)
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"X\overrightarrow{\mathbf{AB}}=\mathbf{X}\overrightarrow{\mathbf{AC}}",color=BLACK).scale(0.5).next_to(t7,DOWN,aligned_edge=LEFT)
        t9 = MathTex(r"X\overrightarrow{\mathbf{DE}}=\mathbf{X}\overrightarrow{\mathbf{DF}}", color=BLACK).scale(
            0.5).next_to(t8, DOWN, aligned_edge=LEFT)
        self.play(Write(t8))
        self.play(Write(t9))
        self.wait(1)
        t10 = MathTex(r"\overrightarrow{\mathbf{AC}}=\mathbf{X}\overrightarrow{\mathbf{AB}}=\mathbf{X}\mathcal{E}\overrightarrow{\mathbf{DE}}",color=BLACK).scale(0.5).next_to(t9,DOWN,aligned_edge=LEFT)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"=\mathcal{E}\mathbf{X}\overrightarrow{\mathbf{DE}}=\mathcal{E}\overrightarrow{\mathbf{DF}}",color=BLACK).scale(0.5).next_to(t10,DOWN,aligned_edge=LEFT)
        self.play(Write(t11))
        self.wait(1)
        t12 = MathTex(r"\mathcal{E}\left(\mathbf{D},\mathbf{E},\mathbf{F}\right)=\left(\mathbf{A},\mathbf{B},\mathbf{C}\right)",color=BLACK).scale(0.5).next_to(t11,DOWN,aligned_edge=LEFT)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"\triangle \mathbf{ABC}\cong\triangle\mathbf{DEF}", color=BLACK).to_corner(UR)
        self.play(Write(t13))
        self.wait(1)


class s30(ThreeDScene):
    def construct(self):
        self.wait(1)
        t0 = MathTex(r"\text{Dim}\left(\text{Root}\left(f\left(t_1,t_2,\cdots,t_n\right)\right)\right)=n-1",color=BLACK)
        self.play(Write(t0))
        self.wait(1)
        self.play(FadeOut(t0))
        t1 = MathTex(r"\mathbf{T}=\bigcup_i^n \mathbf{T}_i",color=BLACK).to_corner(UL)
        self.add_fixed_in_frame_mobjects(t1)
        self.play(Write(t1))
        Q_T_range = Square(side_length=2,color=GRAY,fill_opacity=0.2)
        Q_Pieces = shape_range(DL,DR,UR,UL,4,4)
        self.play(Write(Q_T_range))
        self.play(*[Write (i) for i in Q_Pieces])
        ##self.move_camera(phi=60 * DEGREES, theta=-30 * DEGREES, added_anims=[Create(shape), Write(t_ps)])
        self.wait(1)
        Q_S = Surface(lambda u,v:np.array([u,v,0.2*u**2+0.2*v**2]), u_range=[-1, 1], v_range=[-1, 1],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        t2 = MathTex(r"\mathbf{S}=\bigcup_i^n \mathbf{S}_i",color=BLACK).next_to(t1,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t2)
        self.move_camera(phi=60 * DEGREES, theta=-30 * DEGREES,added_anims=[Write(Q_S),Write(t2)])
        self.wait(1)
        t3 = MathTex(r"\text{Dim}\left(\mathbf{S}\right)=\text{Dim}\left(\mathbf{S}_i\right)",color=BLACK).next_to(t2,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t3)
        self.play(Write(t3))
        self.wait(1)
        t4 = MathTex(r"true\,when\,\,n\to+\infty",color=GRAY).next_to(t3,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t4)
        self.play(Write(t4))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        self.wait(1)
        t5 = MathTex(r"\mathbb{R}^{n+1}",color=BLACK).to_corner(UL)
        self.add_fixed_in_frame_mobjects(t5)
        self.play(Write(t5))
        self.wait(1)
        t6 = MathTex(r"\mathbf{\pi}_1\left(\mathbf{t}\right)=\mathbf{At}+\mathbf{v},\mathbf{\pi}_2\left(\mathbf{t}\right)=\mathbf{Bt}+\mathbf{u}",color=BLACK).scale(0.5).next_to(t5,DOWN,aligned_edge=LEFT)

        self.add_fixed_in_frame_mobjects(t6)
        self.play(Write(t6))
        self.wait(1)
        t7 = MathTex(r"\mathbf{\pi}_1\cap\mathbf{\pi}_2=\left\{\mathbf{p}\mid\exists \mathbf{x},\mathbf{y},\,\,\mathbf{p}=\mathbf{\pi}_1\left(\mathbf{x}\right)=\mathbf{\pi}_1\left(\mathbf{y}\right)\right\}"
                     ,color=BLACK).scale(0.5).next_to(t6,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t7)
        self.play(Write(t7))
        self.wait(1)
        t8 = MathTex(r"\mathbf{p}=\mathbf{\pi}_1\left(\mathbf{x}\right)=\mathbf{\pi}_2\left(\mathbf{y}\right)",color=BLACK).scale(0.5).next_to(t7,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t8)
        self.play(Write(t8))
        self.wait(1)
        t9 = mathtexgroup([r"\mathbf{At}+\mathbf{v}=\mathbf{Bt}+\mathbf{u}",r"\begin{bmatrix}\mathbf{A}  &-\mathbf{B}\end{bmatrix}\begin{bmatrix}\mathbf{x} \\\mathbf{y} \end{bmatrix}=\mathbf{u-v}=\mathbf{c}"]).scale(0.5).next_to(t8,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t9)
        self.play(Write(t9))
        self.wait(1)
        t10 = MathTex(r"\begin{bmatrix}\mathbf{A}  &-\mathbf{B}\end{bmatrix}_{\left(n+1\right)\times2n},\begin{bmatrix}\mathbf{x}  \\\mathbf{y}\end{bmatrix}_{2n}",color=BLACK).scale(0.5).next_to(t9,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t10)
        self.play(Write(t10))
        self.wait(1)
        t11 = MathTex(r"\text{Rank}\left(\begin{bmatrix}\mathbf{A}  &-\mathbf{B}\end{bmatrix}\right)=\text{Rank}\left(\begin{bmatrix}\mathbf{A}  &-\mathbf{B}&\mathbf{c}\end{bmatrix}\right)",color=BLACK).scale(0.5).next_to(t10,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t11)
        self.play(Write(t11))
        self.wait(1)
        t12 = MathTex(r"\text{Dim}\left(\mathbf{\pi}_1\cap\mathbf{\pi}_2\right)=\text{Rank}\left(2n-\text{Rank}\left(\begin{bmatrix}\mathbf{A}  &-\mathbf{B}\end{bmatrix}\right)\right)",color=BLACK).scale(0.5).next_to(t11,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t12)
        self.play(Write(t12))
        self.wait(1)
        t13 = MathTex(r"\text{Dim}\left(\mathbf{\pi}_1\cap\mathbf{\pi}_2\right)_{MAX}=n+1-\left(2n\right)=n-1",color=BLACK).scale(0.5).next_to(t12,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t13)
        self.play(Write(t13))
        self.wait(1)
        t14 = MathTex(r"\Leftrightarrow\begin{bmatrix}\mathbf{A}  &-\mathbf{B}\end{bmatrix}\,full\,rank ",color=BLACK).scale(0.5).next_to(t13,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t14)
        self.play(Write(t14))
        self.wait(1)
        self.play(FadeOut(*self.mobjects))
        t15 = MathTex(r"f\left(\mathbf{t}\right)=0,\mathbf{t}\in\mathbb{R}^n",color=BLACK).scale(0.5).to_corner(UL)
        self.add_fixed_in_frame_mobjects(t15)
        self.play(Write(t15))
        self.wait(1)
        t16 = MathTex(r"\lambda\left(\text{Non-differentiable}\left(\mathbf{f}\right)\right)=0",color=BLACK).scale(0.5).next_to(t15,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t16)
        self.play(Write(t16))
        self.wait(1)
        t17 = MathTex(r"\exists \mathbf{p},f\left(\mathbf{p}\right)=0", color=BLACK).scale(
            0.5).next_to(t16, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t17)
        self.play(Write(t17))
        self.wait(1)
        t18 = MathTex(r"For\, almost\, every\, root\, \mathbf{p}: \exists i\, s.t. \frac{\partial\mathbf{p}_i}{\partial t_i}\not=0",color=BLACK).scale(0.5).next_to(t17,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t18)
        self.play(Write(t18))
        self.wait(1)
        t19 = MathTex(r"\mathbf{K}\left(\mathbf{t}\right)=\begin{bmatrix}\mathbf{t}\\f\left(\mathbf{t}\right)\end{bmatrix}",color=BLACK).scale(0.5).next_to(t18,DOWN,aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t19)
        self.play(Write(t19))
        def f(u,v):
            return np.array([u,v,0.3*(u**2+v**2)])+IN
        Q_K = Surface(lambda u,v:f(u,v), u_range=[-2, 2], v_range=[-2, 2],checkerboard_colors=[RED,RED_E],fill_opacity=0.5,resolution=4)
        self.play(Write(Q_K))
        self.wait(1)
        t20 = MathTex(
            r"\mathbf{J}\left(\mathbf{t}\right)=\begin{bmatrix}\mathbf{t}\\0\end{bmatrix}",
            color=BLACK).scale(0.5).next_to(t19, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t20)
        self.play(Write(t20))
        Q_J = Surface(lambda u, v: np.array([u,v,0]), u_range=[-2, 2], v_range=[-2, 2], checkerboard_colors=[GRAY, GRAY_E],
                      fill_opacity=0.5, resolution=4)
        self.play(Write(Q_J))
        self.wait(1)
        t21 = MathTex(
            r"\mathbf{S}=\mathbf{K}\cap\mathbf{J}",
            color=BLACK).scale(0.5).next_to(t20, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t21)
        self.play(Write(t21))
        Q_S = ParametricFunction(lambda t:np.array([sqrt(10/3)*cos(t),sqrt(10/3)*sin(t),0]),t_range=[0,2*PI],color=BLACK)
        self.play(Write(Q_S))
        self.wait(1)
        t22 = MathTex(
            r"\begin{bmatrix}\mathbf{p}\\0\end{bmatrix}:\text{Root}\left(f\right)\leftrightarrow\mathbf{S}",
            color=BLACK).scale(0.5).next_to(t21, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t22)
        self.play(Write(t22))
        self.wait(1)
        t23 = MathTex(
            r"\mathbf{p}\in\text{Root}\left(f\right),\exists i\, s.t. \frac{\partial\mathbf{p}_i}{\partial t_i}\not=0",
            color=BLACK).scale(0.5).next_to(t22, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t23)
        self.play(Write(t23))
        self.wait(1)
        t24 = MathTex(
            r"\mathbf{T}\left(\mathbf{t}\right)=\begin{bmatrix}\frac{\partial f}{\partial x_1}  &\frac{\partial f}{\partial x_2}&\cdots&\frac{\partial f}{\partial x_n}\end{bmatrix}\mathbf{t}+\mathbf{p}",
            color=BLACK).scale(0.5).next_to(t23, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t24)
        self.play(Write(t24))
        self.wait(1)
        t25 = MathTex(
            r"\lim _{\mathbf{t}\to\mathbf{0}}\mathbf{T}\cap\mathbf{J}\in\mathbf{K}\cap\mathbf{J}",
            color=BLACK).scale(0.5).next_to(t24, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t25)
        self.play(Write(t25))
        self.wait(1)

        t26 = MathTex(
            r"\lim _{\mathbf{t}\to\mathbf{0}}{\bigcup{\mathbf{T}_i\cap\mathbf{J}}}\cup\mathbf{NonNormalRoots}=\mathbf{S}",
            color=BLACK).scale(0.5).next_to(t25, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t26)
        self.play(Write(t26))
        self.wait(1)

        t27 = MathTex(
            r"\text{Dim}\left(\text{Root}\left(f\right)\right)=\text{Dim}\left(\mathbf{T}\cap\mathbf{J}\right)",
            color=BLACK).scale(0.5).next_to(t26, DOWN, aligned_edge=LEFT)
        self.add_fixed_in_frame_mobjects(t27)
        self.play(Write(t27))
        self.wait(1)

        t28 = MathTex(
            r"\begin{bmatrix} 1 & 0 & \cdots &  0&  -1& 0 & \cdots &0 \\ 0 &1  & \cdots & 0 & 0 & -1 & \cdots & 0\\ \vdots & \vdots & \ddots &\vdots &  \vdots & \vdots & \ddots &\vdots \\ 0 & 0 & \cdots & 1 & 0 &0  & \cdots &-1 \\\frac{\partial f}{\partial x_1} &  \frac{\partial f}{\partial x_2} &  \cdots& \frac{\partial f}{\partial x_n}  &0  & 0 & 0 &0\end{bmatrix}",
            color=BLACK).scale(0.5).to_corner(UR)
        self.add_fixed_in_frame_mobjects(t28)
        self.play(Write(t28))
        self.wait(1)

        HighLight_3D(self,t18)
        self.wait(1)
        t29 = MathTex(r"\text{Dim}=n-1",color=BLACK).scale(0.5).next_to(t28, DOWN, aligned_edge=RIGHT)
        self.add_fixed_in_frame_mobjects(t29)
        self.play(Write(t29))
        self.wait(1)

class test1(Scene):
    def construct(self):
        t16 = tex_with_gbk([_pair(
            r"\left\langle\overrightarrow{\mathbf{XY}},\mathbf{a} \right\rangle,\left\langle\overrightarrow{\mathbf{YX}},\overrightarrow{\mathbf{YK}} \right\rangle")
                               , _pair(r"是一对同旁内角", 1)]).scale(0.5)
        t16[0][0][:9].set_color(BLUE_E)
        t16[0][0][10:].set_color(PURPLE)
        self.add(t16)


class Postulation_1_and_2(Scene):
    def construct(self):
        self.wait(1)
        A = np.array([cos(30*DEGREES),sin(30*DEGREES),0])
        B = -A
        Q_A = Dot(A,color=PURE_RED)
        Q_B = Dot(B,color=PURE_RED)
        Q_L_AB = Line(A-10*(B-A),B+10*(B-A),color=PURE_RED)
        self.play(Write(Q_A))
        self.play(Write(Q_B))
        self.wait(1)
        self.play(Write(Q_L_AB))
        self.wait(1)
        t = ValueTracker(0)
        Q_D_AB = always_redraw(lambda:Line(A-t.get_value()*(B-A),B,color=PURE_RED))
        Q_C = always_redraw(lambda:Dot(A-t.get_value()*(B-A),color=PURE_RED))
        self.add(Q_D_AB,Q_C)
        self.play(FadeOut(Q_L_AB))
        self.wait(1)
        self.play(t.animate.set_value(0.5))
        self.wait(1)
class Postulation_3(Scene):
    def construct(self):
        self.wait(1)
        O = np.array([0,0,0])
        Q_O = Dot(O,color=PURE_RED)
        r = 2
        t = ValueTracker(0)
        Q_P = always_redraw(lambda:Dot(r*np.array([cos(t.get_value()),sin(t.get_value()),0]),color=PURE_RED))
        Q_R = always_redraw(lambda:DashedLine(O,r*np.array([cos(t.get_value()),sin(t.get_value()),0]),color=PURE_RED))
        Q_Circle = always_redraw(lambda:ParametricFunction(lambda t:r*np.array([cos(t),sin(t),0]),t_range=[0,t.get_value()],color=PURE_RED))
        self.add(Q_O,Q_P,Q_Circle,Q_R)
        self.play(t.animate.set_value(2*PI),)
        self.wait(1)

class Postulation_4(Scene):
    def construct(self):
        O = Dot([0,0,0],color=PURE_RED)
        L1 = Line([0,0,0],RIGHT,color=PURE_RED)
        L2 = Line([0, 0, 0], UP, color=PURE_RED)
        ANGLE = RightAngle(L1,L2,color=PURE_RED,stroke_width=10)
        self.add(L1,L2,ANGLE,O)

class Postulation_5(Scene):
    def construct(self):
        a = np.array([cos(-15*DEGREES),sin(-15*DEGREES),0])
        b = np.array([cos(5 * DEGREES), sin(5 * DEGREES), 0])
        X = UP
        Y = DOWN
        t = ValueTracker(1)
        Q_A = always_redraw(lambda:Line(X-1*a,X+1*t.get_value()*a,color=BLACK))
        Q_B = always_redraw(lambda:Line(Y-1*b,Y+1*t.get_value()*b,color=BLACK))
        Q_X = Dot(X,color=BLACK)
        Q_Y = Dot(Y,color=BLACK)
        Q_XY = Line(X-(Y-X),Y+(Y-X),color=BLACK)
        Q_A1 = ARC_V(a,Y-X,radius=0.25,color=BLACK,stroke_width=10).shift(X)
        Q_A2 = ARC_V(b, X - Y, radius=0.25, color=BLACK, stroke_width=10).shift(Y)
        Z = Dot(_Cross(a,X,b,Y),color=BLACK)
        self.play(Write(Q_A),Write(Q_B),run_time=0.46)
        self.play(Write_In_Group([Q_X,Q_Y,Q_XY]), run_time=0.46)
        self.play(Write_In_Group([Q_A1, Q_A2]), run_time=0.46)
        self.play(t.animate.set_value(10), run_time=0.46)
        self.play(Write_In_Group([Z]), run_time=0.46)
        self.wait(1)
        for i in self.mobjects:
            i.set_color(PURE_RED)
        self.wait(1)
class Postulation_5_Picture(Scene):
    def construct(self):
        a = np.array([cos(-15*DEGREES),sin(-15*DEGREES),0])
        b = np.array([cos(5 * DEGREES), sin(5 * DEGREES), 0])
        X = UP
        Y = DOWN
        t = ValueTracker(10)
        Q_A = always_redraw(lambda:Line(X-1*a,X+1*t.get_value()*a,color=BLACK))
        Q_B = always_redraw(lambda:Line(Y-1*b,Y+1*t.get_value()*b,color=BLACK))
        Q_X = Dot(X,color=BLACK)
        Q_Y = Dot(Y,color=BLACK)
        Q_XY = Line(X-(Y-X),Y+(Y-X),color=BLACK)
        Q_A1 = ARC_V(a,Y-X,radius=0.25,color=BLACK,stroke_width=10).shift(X)
        Q_A2 = ARC_V(b, X - Y, radius=0.25, color=BLACK, stroke_width=10).shift(Y)
        Z = Dot(_Cross(a,X,b,Y),color=BLACK)
        self.add(Q_A,Q_B,Q_X,Q_Y,Q_XY,Q_A1,Q_A2,Z)
        for i in self.mobjects:
            i.set_color(PURE_RED)

class s6_1_correct(Scene):
    def construct(self):
        t1 = tex_with_gbk([_pair(r"\mathbf{A}"),_pair("是n维的",1)]).set_color(BLACK)
        t2 = MathTex(r"\Leftrightarrow",color=BLACK)
        t3 = MathTex(r"\exists \mathbf{f}:\mathbb{N}\times\mathbb{R}^n\leftrightarrow\mathbf{A}",color=BLACK)
        t4 = Text(r"且f的不连续点至多可数",color=BLACK)
        VGroup(t1,t2,t3,t4).arrange(DOWN)
        self.add(t1,t2,t3,t4)

##中子星NeutronStar233制作